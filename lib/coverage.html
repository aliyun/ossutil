
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>lib: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">workspace/ossutil/lib/allpart_size.go (0.0%)</option>
				
				<option value="file1">workspace/ossutil/lib/append_file.go (0.0%)</option>
				
				<option value="file2">workspace/ossutil/lib/bucket_cors.go (0.0%)</option>
				
				<option value="file3">workspace/ossutil/lib/bucket_encryption.go (0.0%)</option>
				
				<option value="file4">workspace/ossutil/lib/bucket_inventory.go (0.0%)</option>
				
				<option value="file5">workspace/ossutil/lib/bucket_lifecycle.go (0.0%)</option>
				
				<option value="file6">workspace/ossutil/lib/bucket_logging.go (0.0%)</option>
				
				<option value="file7">workspace/ossutil/lib/bucket_policy.go (0.0%)</option>
				
				<option value="file8">workspace/ossutil/lib/bucket_qos.go (0.0%)</option>
				
				<option value="file9">workspace/ossutil/lib/bucket_referer.go (0.0%)</option>
				
				<option value="file10">workspace/ossutil/lib/bucket_tagging.go (0.0%)</option>
				
				<option value="file11">workspace/ossutil/lib/bucket_versioning.go (0.0%)</option>
				
				<option value="file12">workspace/ossutil/lib/bucket_website.go (0.0%)</option>
				
				<option value="file13">workspace/ossutil/lib/bucket_worm.go (0.0%)</option>
				
				<option value="file14">workspace/ossutil/lib/cat.go (0.0%)</option>
				
				<option value="file15">workspace/ossutil/lib/command.go (50.5%)</option>
				
				<option value="file16">workspace/ossutil/lib/command_manager.go (17.7%)</option>
				
				<option value="file17">workspace/ossutil/lib/config.go (32.6%)</option>
				
				<option value="file18">workspace/ossutil/lib/config_helper.go (84.5%)</option>
				
				<option value="file19">workspace/ossutil/lib/cors_options.go (0.0%)</option>
				
				<option value="file20">workspace/ossutil/lib/cp.go (33.3%)</option>
				
				<option value="file21">workspace/ossutil/lib/create_symlink.go (0.0%)</option>
				
				<option value="file22">workspace/ossutil/lib/du.go (0.0%)</option>
				
				<option value="file23">workspace/ossutil/lib/ecs_role.go (76.3%)</option>
				
				<option value="file24">workspace/ossutil/lib/error.go (20.0%)</option>
				
				<option value="file25">workspace/ossutil/lib/hash.go (0.0%)</option>
				
				<option value="file26">workspace/ossutil/lib/help.go (0.0%)</option>
				
				<option value="file27">workspace/ossutil/lib/lang.go (80.0%)</option>
				
				<option value="file28">workspace/ossutil/lib/listpart.go (0.0%)</option>
				
				<option value="file29">workspace/ossutil/lib/ls.go (13.9%)</option>
				
				<option value="file30">workspace/ossutil/lib/mb.go (47.5%)</option>
				
				<option value="file31">workspace/ossutil/lib/mkdir.go (0.0%)</option>
				
				<option value="file32">workspace/ossutil/lib/monitor.go (54.6%)</option>
				
				<option value="file33">workspace/ossutil/lib/object_tagging.go (0.0%)</option>
				
				<option value="file34">workspace/ossutil/lib/option.go (16.5%)</option>
				
				<option value="file35">workspace/ossutil/lib/ossutil_log.go (10.0%)</option>
				
				<option value="file36">workspace/ossutil/lib/probe.go (0.0%)</option>
				
				<option value="file37">workspace/ossutil/lib/read_symlink.go (0.0%)</option>
				
				<option value="file38">workspace/ossutil/lib/report_helper.go (8.7%)</option>
				
				<option value="file39">workspace/ossutil/lib/request_payment.go (0.0%)</option>
				
				<option value="file40">workspace/ossutil/lib/restore.go (0.0%)</option>
				
				<option value="file41">workspace/ossutil/lib/revert_versioning.go (0.0%)</option>
				
				<option value="file42">workspace/ossutil/lib/rm.go (51.6%)</option>
				
				<option value="file43">workspace/ossutil/lib/set_acl.go (6.8%)</option>
				
				<option value="file44">workspace/ossutil/lib/set_meta.go (3.8%)</option>
				
				<option value="file45">workspace/ossutil/lib/signurl.go (0.0%)</option>
				
				<option value="file46">workspace/ossutil/lib/stat.go (0.0%)</option>
				
				<option value="file47">workspace/ossutil/lib/storage_url.go (58.4%)</option>
				
				<option value="file48">workspace/ossutil/lib/sync.go (0.0%)</option>
				
				<option value="file49">workspace/ossutil/lib/update.go (0.0%)</option>
				
				<option value="file50">workspace/ossutil/lib/user_qos.go (0.0%)</option>
				
				<option value="file51">workspace/ossutil/lib/util.go (15.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package lib

import (
        "fmt"
        "net/url"
        "strconv"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseAllPartSize = SpecText{
        synopsisText: "获取bucket所有未完成上传的multipart object的分块大小以及总和",

        paramText: "bucket_url [options]",

        syntaxText: ` 
        ossutil getallpartsize oss://bucket [options]
`,

        detailHelpText: ` 
        该命令会获取bucket所有未完成上传的multipart object的分块大小以及总和
  

用法：

    该命令只有一种用法：

    1) ossutil getallpartsize oss://bucket [options]
      查询bucket的所有未完成上传的multipart object的块大小信息以及总和
`,

        sampleText: ` 
        1) 根据bucket查询所有未完成上传的multipart object的块大小信息以及总和
       ossutil getallpartsize oss://bucket
`,
}

var specEnglishAllPartSize = SpecText{
        synopsisText: "Get bucket all uncompleted multipart objects's parts size and sum size",

        paramText: "bucket_url [options]",

        syntaxText: ` 
        ossutil getallpartsize oss://bucket [options]
`,

        detailHelpText: ` 
        This command will list every uncompleted multipart objects's part size and sum size
  

Usages：

    There is only one usage for this command:

    1) ossutil getallpartsize oss://bucket [options]
       Get bucket all uncompleted mulitpart objects's parts size and sum size
`,

        sampleText: ` 
        1)  Get bucket all uncompleted multipart objects's parts size and sum size
       ossutil getallpartsize oss://bucket
`,
}

type allPartSizeOptionType struct {
        bucketName     string
        encodingType   string
        headLineShowed bool
        statList       []StatPartInfo
}

type AllPartSizeCommand struct {
        command  Command
        apOption allPartSizeOptionType
}

var allPartSizeCommand = AllPartSizeCommand{
        command: Command{
                name:        "getallpartsize",
                nameAlias:   []string{"getallpartsize"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseAllPartSize,
                specEnglish: specEnglishAllPartSize,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionEncodingType,
                        OptionLogLevel,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

type StatPartInfo struct {
        objectName string
        uploadId   string
}

// function for FormatHelper interface
func (apc *AllPartSizeCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return apc.command.formatHelpForWhole()
}</span>

func (apc *AllPartSizeCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return apc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (apc *AllPartSizeCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return apc.command.Init(args, options, apc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (apc *AllPartSizeCommand) RunCommand() error <span class="cov0" title="0">{
        srcBucketUrL, err := GetCloudUrl(apc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">apc.apOption.bucketName = srcBucketUrL.bucket
        apc.apOption.encodingType, _ = GetString(OptionEncodingType, apc.command.options)

        // first:get all object uploadid
        err = apc.GetAllStatInfo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //second:stat every object parts
        <span class="cov0" title="0">client, err := apc.command.ossClient(apc.apOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := client.Bucket(apc.apOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var totalPartCount int64 = 0
        var totalPartSize int64 = 0
        for _, v := range apc.apOption.statList </span><span class="cov0" title="0">{
                partCount, partSize, err := apc.GetObjectPartsSize(bucket, v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">totalPartCount += partCount
                totalPartSize += partSize</span>
        }

        <span class="cov0" title="0">if totalPartSize &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\ntotal part count:%d\ttotal part size(MB):%.2f\n\n", totalPartCount, float64(totalPartSize/1024)/1024)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (apc *AllPartSizeCommand) GetAllStatInfo() error <span class="cov0" title="0">{
        client, err := apc.command.ossClient(apc.apOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := client.Bucket(apc.apOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">keyMarker := ""
        uploadIdMarker := ""
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                lpOptions := []oss.Option{}
                lpOptions = append(lpOptions, oss.MaxParts(1000))
                lpOptions = append(lpOptions, oss.KeyMarker(keyMarker))
                lpOptions = append(lpOptions, oss.UploadIDMarker(uploadIdMarker))

                lpRes, err := bucket.ListMultipartUploads(lpOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, v := range lpRes.Uploads </span><span class="cov0" title="0">{
                        var statPartInfo StatPartInfo
                        statPartInfo.objectName = v.Key
                        statPartInfo.uploadId = v.UploadID
                        apc.apOption.statList = append(apc.apOption.statList, statPartInfo)
                }</span>

                <span class="cov0" title="0">if lpRes.IsTruncated </span><span class="cov0" title="0">{
                        keyMarker = lpRes.NextKeyMarker
                        uploadIdMarker = lpRes.NextUploadIDMarker
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (apc *AllPartSizeCommand) GetObjectPartsSize(bucket *oss.Bucket, statInfo StatPartInfo) (int64, int64, error) <span class="cov0" title="0">{
        var imur oss.InitiateMultipartUploadResult
        imur.Bucket = apc.apOption.bucketName
        imur.Key = statInfo.objectName
        imur.UploadID = statInfo.uploadId

        partNumberMarker := 0
        var totalPartCount int64 = 0
        var totalPartSize int64 = 0
        var cloudUrl CloudURL
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                lpOptions := []oss.Option{}
                lpOptions = append(lpOptions, oss.MaxParts(1000))
                lpOptions = append(lpOptions, oss.PartNumberMarker(partNumberMarker))

                lpRes, err := bucket.ListUploadedParts(imur, lpOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, err
                }</span> else<span class="cov0" title="0"> {
                        totalPartCount += int64(len(lpRes.UploadedParts))
                        if !apc.apOption.headLineShowed &amp;&amp; len(lpRes.UploadedParts) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("%-10s\t%-32s\t%-10s\t%s\n", "PartNumber", "UploadId", "Size(Byte)", "Path")
                                apc.apOption.headLineShowed = true
                        }</span>
                }

                <span class="cov0" title="0">for _, v := range lpRes.UploadedParts </span><span class="cov0" title="0">{
                        cloudUrl.bucket = apc.apOption.bucketName
                        if apc.apOption.encodingType == URLEncodingType </span><span class="cov0" title="0">{
                                cloudUrl.object = url.QueryEscape(imur.Key)
                        }</span> else<span class="cov0" title="0"> {
                                cloudUrl.object = imur.Key
                        }</span>

                        //PartNumber,uploadId,Size,Path
                        <span class="cov0" title="0">fmt.Printf("%-10d\t%-32s\t%-10d\t%s\n", v.PartNumber, imur.UploadID, v.Size, cloudUrl.ToString())
                        totalPartSize += int64(v.Size)</span>
                }

                <span class="cov0" title="0">if lpRes.IsTruncated </span><span class="cov0" title="0">{
                        partNumberMarker, err = strconv.Atoi(lpRes.NextPartNumberMarker)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, 0, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov0" title="0">return totalPartCount, totalPartSize, nil</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package lib

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseAppendFile = SpecText{
        synopsisText: "将本地文件内容以append上传方式上传到oss中的appendable object中",

        paramText: "local_file_name oss_object [options]",

        syntaxText: ` 
        ossutil appendfromfile local_file_name oss://bucket/object [options]
`,

        detailHelpText: ` 
        1) 如果object不存在，可以通过--meta设置object的meta信息，比如输入 --meta "x-oss-meta-author:luxun"
       可以设置x-oss-meta-author的值为luxun
    2) 如果object已经存在，不可以输入--meta信息,因为oss不支持在已经存在的append object上设置meta

用法：

    该命令只有一种用法：

    1) ossutil appendfromfile local_file_name oss://bucket/object [--meta=meta-value]
      将local_file_name内容以append方式上传到可追加的object
      如果输入--meta选项，可以设置object的meta信息
`,

        sampleText: ` 
        1) append上传文件内容，不设置meta信息
       ossutil appendfromfile local_file_name oss://bucket/object
        
    2) append上传文件内容，设置meta信息
       ossutil appendfromfile local_file_name oss://bucket/object --meta "x-oss-meta-author:luxun"
    
    3) 以访问者付费模式上传文件内容
       ossutil appendfromfile local_file_name oss://bucket/object --payer requester
`,
}

var specEnglishAppendFile = SpecText{
        synopsisText: "Upload the contents of the local file to the oss appendable object by append upload mode",

        paramText: "local_file_name oss_object [options]",

        syntaxText: ` 
        ossutil appendfromfile local_file_name oss://bucket/object [options]
`,

        detailHelpText: ` 
        1) If the object does not exist, you can set the meta information of the object with --meta
      for example:
      inputting --meta "x-oss-meta-author:luxun" can set the value of x-oss-meta-author to luxun
    2) If the object already exists, you can't input the --meta option,
      oss does not support setting the meta on the exist appendable object.

Usages：

    There is only one usage for this command:：

    1) ossutil appendfromfile local_file_name oss://bucket/object [--meta=meta-value]
      Upload the local_file_name content to the object by append mode
      If you input the --meta option, you can set the meta value of the object
`,

        sampleText: ` 
        1) Uploads file content by append mode without setting meta value
       ossutil appendfromfile local_file_name oss://bucket/object
        
    2) Uploads file content by append mode with setting meta value
       ossutil appendfromfile local_file_name oss://bucket/object --meta "x-oss-meta-author:luxun"
    
    3) Uploads file content with requester payment mode
       ossutil appendfromfile local_file_name oss://bucket/object --payer requester
`,
}

type AppendProgressListener struct {
        lastMilliSecond int64
        lastSize        int64
        currSize        int64
}

// ProgressChanged handle progress event
func (l *AppendProgressListener) ProgressChanged(event *oss.ProgressEvent) <span class="cov0" title="0">{
        if event.EventType == oss.TransferDataEvent || event.EventType == oss.TransferCompletedEvent </span><span class="cov0" title="0">{
                if l.lastMilliSecond == 0 </span><span class="cov0" title="0">{
                        l.lastSize = l.currSize
                        l.currSize = event.ConsumedBytes
                        l.lastMilliSecond = time.Now().UnixNano() / 1000 / 1000
                }</span> else<span class="cov0" title="0"> {
                        now := time.Now()
                        cost := now.UnixNano()/1000/1000 - l.lastMilliSecond
                        if cost &gt; 1000 || event.EventType == oss.TransferCompletedEvent </span><span class="cov0" title="0">{
                                l.lastSize = l.currSize
                                l.currSize = event.ConsumedBytes
                                l.lastMilliSecond = now.UnixNano() / 1000 / 1000

                                speed := (float64(l.currSize-l.lastSize) / 1024) / (float64(cost) / 1000)
                                rate := float64(l.currSize) * 100 / float64(event.TotalBytes)
                                fmt.Printf("\rtotal append %d(%.2f%%) byte,speed is %.2f(KB/s)", event.ConsumedBytes, rate, speed)
                        }</span>
                }
        }
}

type appendFileOptionType struct {
        bucketName   string
        objectName   string
        encodingType string
        fileName     string
        fileSize     int64
        ossMeta      string
}

type AppendFileCommand struct {
        command       Command
        afOption      appendFileOptionType
        commonOptions []oss.Option
}

var appendFileCommand = AppendFileCommand{
        command: Command{
                name:        "appendfromfile",
                nameAlias:   []string{"appendfromfile"},
                minArgc:     2,
                maxArgc:     2,
                specChinese: specChineseAppendFile,
                specEnglish: specEnglishAppendFile,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionEncodingType,
                        OptionMeta,
                        OptionMaxUpSpeed,
                        OptionLogLevel,
                        OptionRequestPayer,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (afc *AppendFileCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return afc.command.formatHelpForWhole()
}</span>

func (afc *AppendFileCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return afc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (afc *AppendFileCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return afc.command.Init(args, options, afc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (afc *AppendFileCommand) RunCommand() error <span class="cov0" title="0">{
        afc.afOption.encodingType, _ = GetString(OptionEncodingType, afc.command.options)
        afc.afOption.ossMeta, _ = GetString(OptionMeta, afc.command.options)

        srcBucketUrL, err := GetCloudUrl(afc.command.args[1], afc.afOption.encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if srcBucketUrL.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("object key is empty")
        }</span>

        <span class="cov0" title="0">payer, _ := GetString(OptionRequestPayer, afc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">afc.commonOptions = append(afc.commonOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        <span class="cov0" title="0">afc.afOption.bucketName = srcBucketUrL.bucket
        afc.afOption.objectName = srcBucketUrL.object

        // check input file
        fileName := afc.command.args[0]
        stat, err := os.Stat(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if stat.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is dir", fileName)
        }</span>

        <span class="cov0" title="0">if stat.Size() &gt; MaxAppendObjectSize </span><span class="cov0" title="0">{
                return fmt.Errorf("locafile:%s is bigger than %d, it is not supported by append", fileName, MaxAppendObjectSize)
        }</span>

        <span class="cov0" title="0">afc.afOption.fileName = fileName
        afc.afOption.fileSize = stat.Size()

        // check object exist or not
        client, err := afc.command.ossClient(afc.afOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := client.Bucket(afc.afOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">isExist, err := bucket.IsObjectExist(afc.afOption.objectName, afc.commonOptions...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if isExist &amp;&amp; afc.afOption.ossMeta != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("setting meta on existing append object is not supported")
        }</span>

        <span class="cov0" title="0">position := int64(0)
        if isExist </span><span class="cov0" title="0">{
                //get object size
                props, err := bucket.GetObjectMeta(afc.afOption.objectName, afc.commonOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">position, err = strconv.ParseInt(props.Get("Content-Length"), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = afc.AppendFromFile(bucket, position)

        return err</span>
}

func (afc *AppendFileCommand) AppendFromFile(bucket *oss.Bucket, position int64) error <span class="cov0" title="0">{
        file, err := os.OpenFile(afc.afOption.fileName, os.O_RDONLY, 0660)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var options []oss.Option
        if afc.afOption.ossMeta != "" </span><span class="cov0" title="0">{
                metas, err := afc.command.parseHeaders(afc.afOption.ossMeta, false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">options, err = afc.command.getOSSOptions(headerOptionMap, metas)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">var listener *AppendProgressListener = &amp;AppendProgressListener{}
        options = append(options, oss.Progress(listener))
        options = append(options, afc.commonOptions...)

        startT := time.Now()
        newPosition, err := bucket.AppendObject(afc.afOption.objectName, file, position, options...)
        endT := time.Now()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> {
                cost := endT.UnixNano()/1000/1000 - startT.UnixNano()/1000/1000
                speed := float64(afc.afOption.fileSize) / float64(cost)
                fmt.Printf("\nlocal file size is %d,the object new size is %d,average speed is %.2f(KB/s)\n\n", afc.afOption.fileSize, newPosition, speed)
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package lib

import (
        "encoding/xml"
        "fmt"
        "io/ioutil"
        "os"
        "strings"

        "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseCors = SpecText{
        synopsisText: "设置、查询或者删除bucket的cors配置",

        paramText: "bucket_url [local_xml_file] [options]",

        syntaxText: ` 
    ossutil cors --method put oss://bucket  local_xml_file
    ossutil cors --method get oss://bucket  [local_xml_file]
    ossuitl cors --method delete oss://bucket
`,
        detailHelpText: ` 
    cors命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的cors配置

用法:
    该命令有三种用法:
        
    1) ossutil cors --method put oss://bucket  local_xml_file
        这个命令从配置文件local_xml_file中读取cors配置，然后设置bucket的cors规则
        配置文件是一个xml格式的文件，举例如下
           
        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
          &lt;CORSConfiguration&gt;
            &lt;CORSRule&gt;
                &lt;AllowedOrigin&gt;www.aliyun.com&lt;/AllowedOrigin&gt;
                &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt;
                &lt;MaxAgeSeconds&gt;10000&lt;/MaxAgeSeconds&gt;
            &lt;/CORSRule&gt;
        &lt;/CORSConfiguration&gt;
        
    2) ossutil cors --method get oss://bucket  [local_xml_file]
        这个命令查询bucket的cors配置
        如果输入参数local_xml_file，cors配置将输出到该文件，否则输出到屏幕上
        
    3)  ossutil cors --method delete oss://bucket
        这个命令删除bucket的cors配置
`,
        sampleText: ` 
    1) 设置bucket的cors配置
       ossutil cors --method put oss://bucket  local_xml_file

    2) 查询bucket的cors配置，结果输出到标准输出
       ossutil cors --method get oss://bucket
        
    3) 查询bucket的cors配置，结果输出到本地文件
       ossutil cors --method get oss://bucket  local_xml_file
        
    4) 删除bucket的cors配置
       ossutil cors --method delete oss://bucket
`,
}

var specEnglishCors = SpecText{
        synopsisText: "Set, get or delete the cors configuration of the oss bucket",

        paramText: "bucket_url [local_xml_file] [options]",

        syntaxText: ` 
    ossutil cors --method put oss://bucket  local_xml_file
    ossutil cors --method get oss://bucket  [local_xml_file]
    ossuitl cors --method delete oss://bucket
`,
        detailHelpText: ` 
    cors command can set、get and delete the cors configuration of the oss bucket by
    set method option value to put, get,delete

Usage:
    There are three usages for this command:
        
    1) ossutil cors --method put oss://bucket  local_xml_file
           
        The command sets the cors configuration of bucket from local file local_xml_file
    the local_xml_file is xml format
        The following is an example of the contents of local_xml_file
           
        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
          &lt;CORSConfiguration&gt;
            &lt;CORSRule&gt;
                &lt;AllowedOrigin&gt;www.aliyun.com&lt;/AllowedOrigin&gt;
                &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt;
                &lt;MaxAgeSeconds&gt;10000&lt;/MaxAgeSeconds&gt;
            &lt;/CORSRule&gt;
        &lt;/CORSConfiguration&gt;
        
    2) ossutil cors --method get oss://bucket  [local_xml_file]
        The command gets the cors configuration of bucket
        if you input parameter local_xml_file,the configuration will be output to local_xml_file
        if you don't input parameter local_xml_file,the configuration will be output to stdout
        
    3)  ossutil cors --method delete oss://bucket
        The command deletes the cors configuration of bucket
`,
        sampleText: ` 
    1) put cors configuration
       ossutil cors --method put oss://bucket  local_xml_file

    2) get cors configuration to stdout
       ossutil cors --method get oss://bucket
        
    3) get cors configuration to local file
       ossutil cors --method get oss://bucket  local_xml_file
        
    4) delete cors configuration
       ossutil cors --method delete oss://bucket
`,
}

type corsOptionType struct {
        bucketName string
}

type CorsCommand struct {
        command  Command
        csOption corsOptionType
}

var corsCommand = CorsCommand{
        command: Command{
                name:        "cors",
                nameAlias:   []string{"cors"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseCors,
                specEnglish: specEnglishCors,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionMethod,
                        OptionLogLevel,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (corsc *CorsCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return corsc.command.formatHelpForWhole()
}</span>

func (corsc *CorsCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return corsc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (corsc *CorsCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return corsc.command.Init(args, options, corsc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (corsc *CorsCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, corsc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>
        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">bucketUrL, err := StorageURLFromString(corsc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !bucketUrL.IsCloudURL() </span><span class="cov0" title="0">{
                return fmt.Errorf("parameter is not a cloud url,url is %s", bucketUrL.ToString())
        }</span>

        <span class="cov0" title="0">cloudUrl := bucketUrL.(CloudURL)
        if cloudUrl.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("bucket name is empty,url is %s", bucketUrL.ToString())
        }</span>

        <span class="cov0" title="0">corsc.csOption.bucketName = cloudUrl.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = corsc.PutBucketCors()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = corsc.GetBucketCors()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = corsc.DeleteBucketCors()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("error:%s\n", err.Error())
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (corsc *CorsCommand) PutBucketCors() error <span class="cov0" title="0">{
        if len(corsc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameters,the local cors config file is empty")
        }</span>

        <span class="cov0" title="0">corsFile := corsc.command.args[1]
        fileInfo, err := os.Stat(corsFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is dir,not the expected file", corsFile)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is empty file", corsFile)
        }</span>

        // parsing the xml file
        <span class="cov0" title="0">file, err := os.Open(corsFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        text, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rulesConfig := oss.CORSXML{}
        err = xml.Unmarshal(text, &amp;rulesConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // put bucket cors
        <span class="cov0" title="0">client, err := corsc.command.ossClient(corsc.csOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketCORS(corsc.csOption.bucketName, rulesConfig.CORSRules)</span>
}

func (corsc *CorsCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("cors: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (corsc *CorsCommand) GetBucketCors() error <span class="cov0" title="0">{
        client, err := corsc.command.ossClient(corsc.csOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">corsRes, err := client.GetBucketCORS(corsc.csOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">output, err := xml.MarshalIndent(corsRes, "  ", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(corsc.command.args) &gt;= 2 </span><span class="cov0" title="0">{
                fileName := corsc.command.args[1]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := corsc.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(xml.Header))
        outFile.Write(output)

        fmt.Printf("\n\n")

        return nil</span>
}

func (corsc *CorsCommand) DeleteBucketCors() error <span class="cov0" title="0">{
        client, err := corsc.command.ossClient(corsc.csOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return client.DeleteBucketCORS(corsc.csOption.bucketName)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package lib

import (
        "fmt"
        "strings"

        "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseBucketEncryption = SpecText{
        synopsisText: "设置、查询或者删除bucket的encryption配置",

        paramText: "bucket_url [options]",

        syntaxText: ` 
    ossutil bucket-encryption --method put oss://bucket --sse-algorithm algorithmName [--kms-masterkey-id  keyid] [--kms-data-encryption SM4]
    ossutil bucket-encryption --method get oss://bucket 
    ossuitl bucket-encryption --method delete oss://bucket
`,
        detailHelpText: ` 
    bucket-encryption命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的encryption配置
    选项--sse-algorithm值只能是KMS、AES256、SM4
    当--sse-algorithm选项值为AES256时，不能输入选项--kms-masterkey-id
    当--sse-algorithm取值为KMS时, --kms-data-encryption可以取值SM4, 指定KMS服务使用SM4加密算法加密
    

用法:
    该命令有三种用法:
        
    1) ossutil bucket-encryption --method put oss://bucket --sse-algorithm algorithmName --kms-masterkey-id  keyid
        这个命令设置bucket的encryption配置,算法名为algorithmName，KMSMasterKeyID为keyid
        
    2) ossutil bucket-encryption --method get oss://bucket 
        这个命令查询bucket的encryption配置
        
    3) ossutil bucket-encryption --method delete oss://bucket
        这个命令删除bucket的encryption配置
`,
        sampleText: ` 
    1) 设置bucket的encryption配置，算法名为AES256
       ossutil bucket-encryption --method put oss://bucket --sse-algorithm AES256
    
    2) 设置bucket的encryption配置，算法名为KMS，KMSMasterKeyID为123
       ossutil bucket-encryption --method put oss://bucket --sse-algorithm KMS --kms-masterkey-id  123
    
    3) 设置bucket的encryption配置，算法名为SM4
       ossutil bucket-encryption --method put oss://bucket --sse-algorithm SM4
        
    4) 查询bucket的encryption配置
       ossutil bucket-encryption --method get oss://bucket
        
    5) 删除bucket的encryption配置
       ossutil bucket-encryption --method delete oss://bucket
    
    6) 使用kms服务加密,加密算法为SM4
       ossutil bucket-encryption --method put oss://bucket --sse-algorithm KMS --kms-data-encryption SM4
`,
}

var specEnglishBucketEncryption = SpecText{
        synopsisText: "Set, get or delete bucket encryption configuration",

        paramText: "bucket_url [options]",

        syntaxText: ` 
    ossutil bucket-encryption --method put oss://bucket --sse-algorithm algorithmName [--kms-masterkey-id  keyid] [--kms-data-encryption SM4]
    ossutil bucket-encryption --method get oss://bucket 
    ossuitl bucket-encryption --method delete oss://bucket
`,
        detailHelpText: ` 
    bucket-encryption command can set, get and delete the encryption configuration of the oss bucket by set method option value to put, get, delete
    The option --sse-algorithm value can only be KMS, AES256.
    If the --sse-algorithm option value is AES256, you cannot input the option --kms-masterkey-id
    If the --sse-algorithm is kms, the value of --kms-data-encryption can be SM4, specifying that the KMS service uses SM4 encryption algorithm to encrypt
Usage:
    There are three usages for this command:
        
    1) ossutil bucket-encryption --method put oss://bucket --sse-algorithm algorithmName --kms-masterkey-id  keyid
        The command sets the encryption configuration of the bucket, the algorithm name is algorithmName and KMSMasterKeyID is keyid.
        
    2) ossutil bucket-encryption --method get oss://bucket 
        The command gets the encryption configuration of bucket

    3) ossutil bucket-encryption --method delete oss://bucket
        The command deletes the encryption configuration of bucket
`,
        sampleText: ` 
    1) set the encryption configuration of the bucket. The algorithm name is AES256.
       ossutil bucket-encryption --method put oss://bucket --sse-algorithm AES256
    
    2) set the encryption configuration of the bucket. The algorithm name is KMS and the KMSMasterKeyID is 123.
       ossutil bucket-encryption --method put oss://bucket --sse-algorithm KMS --kms-masterkey-id 123
    
    3) set the encryption configuration of the bucket. The algorithm name is SM4
       ossutil bucket-encryption --method put oss://bucket --sse-algorithm SM4
        
    4) get bucket encryption configuration
       ossutil bucket-encryption --method get oss://bucket
        
    5) delete bucket encryption configuration
       ossutil bucket-encryption --method delete oss://bucket
    
    6) Using kms service encryption, the encryption algorithm is SM4
       ossutil bucket-encryption --method put oss://bucket --sse-algorithm KMS --kms-data-encryption SM4
`,
}

type BucketEncryptionCommand struct {
        command          Command
        bucketName       string
        encryptionResult oss.GetBucketEncryptionResult
}

var bucketEncryptionCommand = BucketEncryptionCommand{
        command: Command{
                name:        "bucket-encryption",
                nameAlias:   []string{"bucket-encryption"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseBucketEncryption,
                specEnglish: specEnglishBucketEncryption,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionMethod,
                        OptionLogLevel,
                        OptionSSEAlgorithm,
                        OptionKMSMasterKeyID,
                        OptionKMSDataEncryption,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (bec *BucketEncryptionCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return bec.command.formatHelpForWhole()
}</span>

func (bec *BucketEncryptionCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return bec.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (bec *BucketEncryptionCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return bec.command.Init(args, options, bec)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (bec *BucketEncryptionCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, bec.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(bec.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bec.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = bec.PutBucketEncryption()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = bec.GetBucketEncryption()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = bec.DeleteBucketEncryption()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (bec *BucketEncryptionCommand) PutBucketEncryption() error <span class="cov0" title="0">{
        strAlgorithm, _ := GetString(OptionSSEAlgorithm, bec.command.options)
        strKeyId, _ := GetString(OptionKMSMasterKeyID, bec.command.options)
        strKmsDataEncryption, _ := GetString(OptionKMSDataEncryption, bec.command.options)

        // support sm4 algorithm
        //if strAlgorithm != string(oss.KMSAlgorithm) &amp;&amp; strAlgorithm != string(oss.AESAlgorithm) {
        //        return fmt.Errorf("value of option --sse-algorithm must be KMS or AES256")
        //}

        if strAlgorithm == string(oss.AESAlgorithm) &amp;&amp; len(strKeyId) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("value of option --kms-masterkey-id must be empty if value of option --sse-algorithm is AES256")
        }</span>

        <span class="cov0" title="0">var encryptionRule oss.ServerEncryptionRule
        encryptionRule.SSEDefault.SSEAlgorithm = strAlgorithm
        encryptionRule.SSEDefault.KMSMasterKeyID = strKeyId
        encryptionRule.SSEDefault.KMSDataEncryption = strKmsDataEncryption

        // put bucket encryption
        client, err := bec.command.ossClient(bec.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketEncryption(bec.bucketName, encryptionRule)</span>
}

func (bec *BucketEncryptionCommand) GetBucketEncryption() error <span class="cov0" title="0">{
        client, err := bec.command.ossClient(bec.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bec.encryptionResult, err = client.GetBucketEncryption(bec.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("GetBucketEncryption error,info:%s\n", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("SSEAlgorithm:%s\n", bec.encryptionResult.SSEDefault.SSEAlgorithm)
        if bec.encryptionResult.SSEDefault.SSEAlgorithm == string(oss.KMSAlgorithm) </span><span class="cov0" title="0">{
                fmt.Printf("KMSMasterKeyID:%s\n", bec.encryptionResult.SSEDefault.KMSMasterKeyID)
                fmt.Printf("KMSDataEncryption:%s\n", bec.encryptionResult.SSEDefault.KMSDataEncryption)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n\n")

        return nil</span>
}

func (bec *BucketEncryptionCommand) DeleteBucketEncryption() error <span class="cov0" title="0">{
        client, err := bec.command.ossClient(bec.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return client.DeleteBucketEncryption(bec.bucketName)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package lib

import (
        "encoding/xml"
        "fmt"
        "io/ioutil"
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseBucketInventory = SpecText{
        synopsisText: "添加、查询、删除或者列举bucket的清单配置",

        paramText: "bucket_url [local_xml_file] [id] [options]",

        syntaxText: ` 
        ossutil inventory --method put oss://bucket local_xml_file [options]
    ossutil inventory --method get oss://bucket id [local_file] [options]
    ossuitl inventory --method delete oss://bucket id [options]
    ossuitl inventory --method list oss://bucket [local_file] [--marker marker] [options]
`,
        detailHelpText: ` 
    inventory命令通过设置method选项值为put、get、delete、list,可以添加、查询、删除、列举bucket的清单配置

用法:
    该命令有四种用法:
        
    1) ossutil inventory --method put oss://bucket local_xml_file [options]
        这个命令从配置文件local_xml_file中读取清单配置,然后添加一个bucket的清单规则
        配置文件是一个xml格式的文件,如果已经存在标识为配置文件中id的配置,则报错
        下面是一个配置文件例子
   
        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;InventoryConfiguration&gt;
            &lt;Id&gt;report1&lt;/Id&gt;
            &lt;IsEnabled&gt;true&lt;/IsEnabled&gt;
            &lt;Filter&gt;
                &lt;Prefix&gt;filterPrefix/&lt;/Prefix&gt;
            &lt;/Filter&gt;
            &lt;Destination&gt;
                &lt;OSSBucketDestination&gt;
                    &lt;Format&gt;CSV&lt;/Format&gt;
                    &lt;AccountId&gt;123456789012&lt;/AccountId&gt;
                    &lt;RoleArn&gt;acs:ram::1287905056319499:role/fsr7hs5tjnxkiepp2ka6&lt;/RoleArn&gt;
                    &lt;Bucket&gt;acs:oss:::destination-bucket&lt;/Bucket&gt;
                    &lt;Prefix&gt;prefix1&lt;/Prefix&gt;
                    &lt;Encryption&gt;
                        &lt;SSE-KMS&gt;
                            &lt;KeyId&gt;keyId&lt;/KeyId&gt;
                        &lt;/SSE-KMS&gt;
                    &lt;/Encryption&gt;
                &lt;/OSSBucketDestination&gt;
            &lt;/Destination&gt;
            &lt;Schedule&gt;
                &lt;Frequency&gt;Daily&lt;/Frequency&gt;
            &lt;/Schedule&gt;
            &lt;IncludedObjectVersions&gt;All&lt;/IncludedObjectVersions&gt;
            &lt;OptionalFields&gt;
                &lt;Field&gt;Size&lt;/Field&gt;
                &lt;Field&gt;LastModifiedDate&lt;/Field&gt;
                &lt;Field&gt;ETag&lt;/Field&gt;
                &lt;Field&gt;StorageClass&lt;/Field&gt;
                &lt;Field&gt;IsMultipartUploaded&lt;/Field&gt;
                &lt;Field&gt;EncryptionStatus&lt;/Field&gt;
            &lt;/OptionalFields&gt;
        &lt;/InventoryConfiguration&gt;
      
    2) ossutil inventory --method get oss://bucket id [local_xml_file] [options]
        这个命令查询bucket的标识为id的清单配置
        如果输入参数local_xml_file，清单配置将输出到该文件，否则输出到屏幕上
        
    3) ossutil inventory --method delete oss://bucket id [options]
        这个命令删除bucket的标识为id的清单配置
    
    4) ossutil inventory --method list oss://bucket [local_file] [--marker marker] [options]
        这个命令列举bucket的清单配置
`,
        sampleText: ` 
    1) 添加bucket的inventory配置
       ossutil inventory --method put oss://bucket local_xml_file

    2) 查询bucket的标识为id的inventory配置，结果输出到标准输出
       ossutil inventory --method get oss://bucket id
        
    3) 删除bucket的标识为id的inventory配置
       ossutil inventory --method delete oss://bucket id
    
    4) 列举bucket的所有inventory配置
       ossutil inventory --method list oss://bucket
`,
}

var specEnglishBucketInventory = SpecText{
        synopsisText: "Add, get, delete, or list bucket inventory configuration",

        paramText: "bucket_url [local_xml_file] [id] [options]",

        syntaxText: ` 
        ossutil inventory --method put oss://bucket local_xml_file [options]
    ossutil inventory --method get oss://bucket id [local_file] [options]
    ossuitl inventory --method delete oss://bucket id [options]
    ossuitl inventory --method list oss://bucket [local_file] [--marker marker] [options]
`,
        detailHelpText: ` 
    inventory command can add, get, delete or list the inventory configuration of the oss bucket by
    set method option value to put, get, delete, list

Usage:
    There are four usages for this command:
        
    1) ossutil inventory --method put oss://bucket local_xml_file [options]
        The command adds the inventory configuration of bucket from local file local_xml_file
        the local_xml_file is xml format, if there is exist same id of configuration, an error occurs.
        The following is an example xml file

        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;InventoryConfiguration&gt;
            &lt;Id&gt;report1&lt;/Id&gt;
            &lt;IsEnabled&gt;true&lt;/IsEnabled&gt;
            &lt;Filter&gt;
                &lt;Prefix&gt;filterPrefix/&lt;/Prefix&gt;
            &lt;/Filter&gt;
            &lt;Destination&gt;
                &lt;OSSBucketDestination&gt;
                    &lt;Format&gt;CSV&lt;/Format&gt;
                    &lt;AccountId&gt;123456789012&lt;/AccountId&gt;
                    &lt;RoleArn&gt;acs:ram::1287905056319499:role/fsr7hs5tjnxkiepp2ka6&lt;/RoleArn&gt;
                    &lt;Bucket&gt;acs:oss:::destination-bucket&lt;/Bucket&gt;
                    &lt;Prefix&gt;prefix1&lt;/Prefix&gt;
                    &lt;Encryption&gt;
                        &lt;SSE-KMS&gt;
                            &lt;KeyId&gt;keyId&lt;/KeyId&gt;
                        &lt;/SSE-KMS&gt;
                    &lt;/Encryption&gt;
                &lt;/OSSBucketDestination&gt;
            &lt;/Destination&gt;
            &lt;Schedule&gt;
                &lt;Frequency&gt;Daily&lt;/Frequency&gt;
            &lt;/Schedule&gt;
            &lt;IncludedObjectVersions&gt;All&lt;/IncludedObjectVersions&gt;
            &lt;OptionalFields&gt;
                &lt;Field&gt;Size&lt;/Field&gt;
                &lt;Field&gt;LastModifiedDate&lt;/Field&gt;
                &lt;Field&gt;ETag&lt;/Field&gt;
                &lt;Field&gt;StorageClass&lt;/Field&gt;
                &lt;Field&gt;IsMultipartUploaded&lt;/Field&gt;
                &lt;Field&gt;EncryptionStatus&lt;/Field&gt;
            &lt;/OptionalFields&gt;
        &lt;/InventoryConfiguration&gt;
        
    2) ossutil inventory --method get oss://bucket id [local_xml_file] [options]
       The command gets the inventory configuration of bucket, The identifier of the inventory is id
       If you input parameter local_xml_file,the configuration will be output to local_xml_file
       If you don't input parameter local_xml_file,the configuration will be output to stdout
        
    3) ossutil inventory --method delete oss://bucket id [options]
       The command deletes the inventory configuration of bucket, The identifier of the inventory is id
      
    4) ossutil inventory --method list oss://bucket [local_file] [--marker marker] [options]
       List the bucket's all inventory configuration
`,
        sampleText: ` 
    1) add bucket inventory
       ossutil inventory --method put oss://bucket local_xml_file

    2) get inventory configuration to stdout, The identifier of the inventory is id
       ossutil inventory --method get oss://bucket id
        
    3) delete inventory configuration, The identifier of the inventory is id
       ossutil inventory --method delete oss://bucket id
    
    4) list the bucket's all inventory configuration
       ossutil inventory --method list oss://bucket
`,
}

type BucketInventoryOptionType struct {
        bucketName string
}

type BucketInventoryCommand struct {
        command  Command
        bwOption BucketInventoryOptionType
}

var bucketInventoryCommand = BucketInventoryCommand{
        command: Command{
                name:        "inventory",
                nameAlias:   []string{"inventory"},
                minArgc:     1,
                maxArgc:     3,
                specChinese: specChineseBucketInventory,
                specEnglish: specEnglishBucketInventory,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionMethod,
                        OptionMarker,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (bic *BucketInventoryCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return bic.command.formatHelpForWhole()
}</span>

func (bic *BucketInventoryCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return bic.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (bic *BucketInventoryCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return bic.command.Init(args, options, bic)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (bic *BucketInventoryCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, bic.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" &amp;&amp; strMethod != "list" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete|list")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(bic.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bic.bwOption.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = bic.PutBucketInventory()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = bic.GetBucketInventory()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = bic.DeleteBucketInventory()
        }</span> else<span class="cov0" title="0"> if strMethod == "list" </span><span class="cov0" title="0">{
                err = bic.ListBucketInventory()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (bic *BucketInventoryCommand) PutBucketInventory() error <span class="cov0" title="0">{
        if len(bic.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("put bucket inventory need at least 2 parameters,the local xml file is empty")
        }</span>

        <span class="cov0" title="0">xmlFile := bic.command.args[1]
        fileInfo, err := os.Stat(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is dir,not the expected file", xmlFile)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is empty file", xmlFile)
        }</span>

        // parsing the xml file
        <span class="cov0" title="0">file, err := os.Open(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        text, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">inventoryConfig := oss.InventoryConfiguration{}
        err = xml.Unmarshal(text, &amp;inventoryConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //if len(bic.command.args) == 3 {
        //        inventoryConfig.Id = bic.command.args[2]
        //}

        // put bucket inventory
        <span class="cov0" title="0">client, err := bic.command.ossClient(bic.bwOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketInventory(bic.bwOption.bucketName, inventoryConfig)</span>
}

func (bic *BucketInventoryCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("bucket inventory: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (bic *BucketInventoryCommand) GetBucketInventory() error <span class="cov0" title="0">{
        if len(bic.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("get bucket inventory need at least 2 parameters,the parameter id is empty")
        }</span>

        <span class="cov0" title="0">inventoryId := bic.command.args[1]

        client, err := bic.command.ossClient(bic.bwOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">inventoryRes, err := client.GetBucketInventory(bic.bwOption.bucketName, inventoryId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">output, err := xml.MarshalIndent(inventoryRes, "  ", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(bic.command.args) &gt;= 3 </span><span class="cov0" title="0">{
                fileName := bic.command.args[2]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := bic.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(xml.Header))
        outFile.Write(output)

        fmt.Printf("\n\n")

        return nil</span>
}

func (bic *BucketInventoryCommand) DeleteBucketInventory() error <span class="cov0" title="0">{
        if len(bic.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("delete bucket inventory need at least 2 parameters,the parameter id is empty")
        }</span>

        <span class="cov0" title="0">inventoryId := bic.command.args[1]

        // delete bucket inventory
        client, err := bic.command.ossClient(bic.bwOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.DeleteBucketInventory(bic.bwOption.bucketName, inventoryId)</span>
}

func (bic *BucketInventoryCommand) ListBucketInventory() error <span class="cov0" title="0">{
        vmarker, _ := GetString(OptionMarker, bic.command.options)

        client, err := bic.command.ossClient(bic.bwOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var sumResult oss.ListInventoryConfigurationsResult
        for </span><span class="cov0" title="0">{
                listResult, err := client.ListBucketInventory(bic.bwOption.bucketName, vmarker)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sumResult.InventoryConfiguration = append(sumResult.InventoryConfiguration, listResult.InventoryConfiguration...)
                if listResult.IsTruncated != nil &amp;&amp; *listResult.IsTruncated </span><span class="cov0" title="0">{
                        vmarker = listResult.NextContinuationToken
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">output, err := xml.MarshalIndent(sumResult, "  ", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(bic.command.args) &gt;= 2 </span><span class="cov0" title="0">{
                fileName := bic.command.args[1]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := bic.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(xml.Header))
        outFile.Write(output)

        fmt.Printf("\n\ntotal inventory rule count:%d\n", len(sumResult.InventoryConfiguration))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package lib

import (
        "encoding/xml"
        "fmt"
        "io/ioutil"
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseBucketLifeCycle = SpecText{
        synopsisText: "设置、查询或者删除bucket的lifecycle配置",

        paramText: "bucket_url local_xml_file [options]",

        syntaxText: ` 
        ossutil lifecycle --method put oss://bucket local_xml_file [options]
    ossutil lifecycle --method get oss://bucket [local_file] [options]
    ossuitl lifecycle --method delete oss://bucket [options]
`,
        detailHelpText: ` 
    lifecycle命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的lifecycle配置

用法:
    该命令有三种用法:
        
    1) ossutil lifecycle --method put oss://bucket local_xml_file [options]
        这个命令从配置文件local_xml_file中读取lifecycle配置，然后设置bucket的lifecycle规则
        配置文件是一个xml格式的文件，可以选择只配置部分规则,下面是一个所有规则的例子
   
        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;LifecycleConfiguration&gt;
          &lt;Rule&gt;
            &lt;ID&gt;RuleID&lt;/ID&gt;
            &lt;Prefix&gt;Prefix&lt;/Prefix&gt;
            &lt;Status&gt;Status&lt;/Status&gt;
            &lt;Expiration&gt;
              &lt;Days&gt;Days&lt;/Days&gt;
            &lt;/Expiration&gt;
            &lt;Transition&gt;
              &lt;Days&gt;Days&lt;/Days&gt;
              &lt;StorageClass&gt;StorageClass&lt;/StorageClass&gt;
            &lt;/Transition&gt;
            &lt;AbortMultipartUpload&gt;
              &lt;Days&gt;Days&lt;/Days&gt;
            &lt;/AbortMultipartUpload&gt;
          &lt;/Rule&gt;
        &lt;/LifecycleConfiguration&gt;

    2) ossutil lifecycle --method get oss://bucket  [local_xml_file] [options]
        这个命令查询bucket的lifecycle配置
        如果输入参数local_xml_file，lifecycle配置将输出到该文件，否则输出到屏幕上
        
    3) ossutil lifecycle --method delete oss://bucket [options]
        这个命令删除bucket的lifecycle配置
`,
        sampleText: ` 
    1) 设置bucket的lifecycle配置
       ossutil lifecycle --method put oss://bucket local_xml_file

    2) 查询bucket的lifecycle配置，结果输出到标准输出
       ossutil lifecycle --method get oss://bucket
        
    3) 查询bucket的lifecycle配置，结果输出到本地文件
       ossutil lifecycle --method get oss://bucket local_xml_file
        
    4) 删除bucket的lifecycle配置
       ossutil lifecycle --method delete oss://bucket
`,
}

var specEnglishBucketLifeCycle = SpecText{
        synopsisText: "Set, get or delete bucket lifecycle configuration",

        paramText: "bucket_url lifecycle [options]",

        syntaxText: ` 
        ossutil lifecycle --method put oss://bucket local_xml_file [options]
    ossutil lifecycle --method get oss://bucket [local_xml_file] [options]
    ossuitl lifecycle --method delete oss://bucket [options]
`,
        detailHelpText: ` 
    lifecycle command can set, get and delete the lifecycle configuration of the oss bucket by
    set method option value to put, get, delete

Usage:
    There are three usages for this command:
        
    1) ossutil lifecycle --method put oss://bucket local_xml_file [options]
        The command sets the lifecycle configuration of bucket from local file local_xml_file
        the local_xml_file is xml format, you can choose to configure only some rules
        The following is an example of all rules:

        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;LifecycleConfiguration&gt;
          &lt;Rule&gt;
            &lt;ID&gt;RuleID&lt;/ID&gt;
            &lt;Prefix&gt;Prefix&lt;/Prefix&gt;
            &lt;Status&gt;Status&lt;/Status&gt;
            &lt;Expiration&gt;
              &lt;Days&gt;Days&lt;/Days&gt;
            &lt;/Expiration&gt;
            &lt;Transition&gt;
              &lt;Days&gt;Days&lt;/Days&gt;
              &lt;StorageClass&gt;StorageClass&lt;/StorageClass&gt;
            &lt;/Transition&gt;
            &lt;AbortMultipartUpload&gt;
              &lt;Days&gt;Days&lt;/Days&gt;
            &lt;/AbortMultipartUpload&gt;
          &lt;/Rule&gt;
        &lt;/LifecycleConfiguration&gt;
        
    2) ossutil lifecycle --method get oss://bucket  [local_xml_file] [options]
       The command gets the lifecycle configuration of bucket
       If you input parameter local_xml_file,the configuration will be output to local_xml_file
       If you don't input parameter local_xml_file,the configuration will be output to stdout
        
    3) ossutil lifecycle --method delete oss://bucket [options]
       The command deletes the lifecycle configuration of bucket
`,
        sampleText: ` 
    1) put bucket lifecycle
       ossutil lifecycle --method put oss://bucket local_xml_file

    2) get lifecycle configuration to stdout
       ossutil lifecycle --method get oss://bucket
        
    3) get lifecycle configuration to local file
       ossutil lifecycle --method get oss://bucket local_xml_file
        
    4) delete lifecycle configuration
       ossutil lifecycle --method delete oss://bucket
`,
}

type bucketLifeCycleOptionType struct {
        bucketName string
}

type BucketLifeCycleCommand struct {
        command  Command
        blOption bucketLifeCycleOptionType
}

var bucketLifeCycleCommand = BucketLifeCycleCommand{
        command: Command{
                name:        "lifecycle",
                nameAlias:   []string{"lifecycle"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseBucketLifeCycle,
                specEnglish: specEnglishBucketLifeCycle,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionMethod,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (blc *BucketLifeCycleCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return blc.command.formatHelpForWhole()
}</span>

func (blc *BucketLifeCycleCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return blc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (blc *BucketLifeCycleCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return blc.command.Init(args, options, blc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (blc *BucketLifeCycleCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, blc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(blc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">blc.blOption.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = blc.PutBucketLifecycle()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = blc.GetBucketLifecycle()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = blc.DeleteBucketLifecycle()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (blc *BucketLifeCycleCommand) PutBucketLifecycle() error <span class="cov0" title="0">{
        if len(blc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("put bucket lifecycle need at least 2 parameters,the local xml file is empty")
        }</span>

        <span class="cov0" title="0">xmlFile := blc.command.args[1]
        fileInfo, err := os.Stat(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is dir,not the expected file", xmlFile)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is empty file", xmlFile)
        }</span>

        // parsing the xml file
        <span class="cov0" title="0">file, err := os.Open(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        text, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rulesConfig := oss.LifecycleConfiguration{}
        err = xml.Unmarshal(text, &amp;rulesConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // put bucket lifecycle
        <span class="cov0" title="0">client, err := blc.command.ossClient(blc.blOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketLifecycle(blc.blOption.bucketName, rulesConfig.Rules)</span>
}

func (blc *BucketLifeCycleCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("bucket lifecycle: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (blc *BucketLifeCycleCommand) GetBucketLifecycle() error <span class="cov0" title="0">{
        client, err := blc.command.ossClient(blc.blOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">lifeCycleRes, err := client.GetBucketLifecycle(blc.blOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">output, err := xml.MarshalIndent(lifeCycleRes, "  ", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(blc.command.args) &gt;= 2 </span><span class="cov0" title="0">{
                fileName := blc.command.args[1]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := blc.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(xml.Header))
        outFile.Write(output)

        fmt.Printf("\n\n")

        return nil</span>
}

func (blc *BucketLifeCycleCommand) DeleteBucketLifecycle() error <span class="cov0" title="0">{
        // delete bucket lifecycle
        client, err := blc.command.ossClient(blc.blOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.DeleteBucketLifecycle(blc.blOption.bucketName)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package lib

import (
        "encoding/xml"
        "fmt"
        "os"
        "strings"
)

var specChineseBucketLog = SpecText{
        synopsisText: "设置、查询或者删除bucket的log配置",

        paramText: "src_bucket_url target_bucket_url [options]",

        syntaxText: ` 
        ossutil logging --method put oss://bucket oss://target-bucket/[prefix]
    ossutil logging --method get oss://bucket [local_xml_file]
    ossuitl logging --method delete oss://bucket
`,
        detailHelpText: ` 
    logging命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的log配置

用法:
    该命令有三种用法:
        
    1) ossutil logging --method put oss://bucket  oss://target-bucket/[prefix]
        这个命令将bucket的访问日志设置成输出到target-bucket中
        如果输入prefix，可以设置访问日志文件的前缀
        
    2) ossutil logging --method get oss://bucket  [local_xml_file]
        这个命令查询bucket的log配置
        如果输入参数local_xml_file，log配置将输出到该文件，否则输出到屏幕上
        
    3)  ossutil logging --method delete oss://bucket
        这个命令删除bucket的log配置
`,
        sampleText: ` 
    1) 设置bucket的日志配置
       ossutil logging --method put oss://bucket oss://target-bucket/

    2) 查询bucket的日志配置，结果输出到标准输出
       ossutil logging --method get oss://bucket
        
    3) 查询bucket的日志配置，结果输出到本地文件
       ossutil logging --method get oss://bucket local_xml_file
        
    4) 删除bucket的日志配置
       ossutil logging --method delete oss://bucket
`,
}

var specEnglishBucketLog = SpecText{
        synopsisText: "Set、get or delete bucket log configuration",

        paramText: "src_bucket_url target_bucket_url [options]",

        syntaxText: ` 
        ossutil logging --method put oss://bucket oss://target-bucket/[prefix]
    ossutil logging --method get oss://bucket [local_xml_file]
    ossuitl logging --method delete oss://bucket
`,
        detailHelpText: ` 
    logging command can set、get and delete the log configuration of the oss bucket by
    set method option value to put, get,delete

Usage:
    There are three usages for this command::
        
    1) ossutil logging --method put oss://bucket  oss://target-bucket/[prefix]
        The command sets the log configuration of bucket to output to target-bucket
        If prefix is set, bucket log objects will have this prefix
        
    2) ossutil logging --method get oss://bucket  [local_xml_file]
        The command gets the log configuration of bucket
        if you input parameter local_xml_file,the configuration will be output to local_xml_file
        if you don't input parameter local_xml_file,the configuration will be output to stdout
        
    3)  ossutil logging --method delete oss://bucket
        The command deletes the log configuration of bucket
`,
        sampleText: ` 
    1) put bucket log configuration  
       ossutil logging --method put oss://bucket  oss://target-bucket/

    2) get bucket log configuration to stdout
       ossutil logging --method get oss://bucket
        
    3) get bucket log configuration to local file
       ossutil logging --method get oss://bucket  local_xml_file
        
    4) delete bucket log configuration
       ossutil logging --method delete oss://bucket
`,
}

type bucketLogOptionType struct {
        srcBucketName  string
        destBucketName string
        destPrefix     string
}

type BucketLogCommand struct {
        command  Command
        blOption bucketLogOptionType
}

var bucketLogCommand = BucketLogCommand{
        command: Command{
                name:        "logging",
                nameAlias:   []string{"logging"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseBucketLog,
                specEnglish: specEnglishBucketLog,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionMethod,
                        OptionLogLevel,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (blc *BucketLogCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return blc.command.formatHelpForWhole()
}</span>

func (blc *BucketLogCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return blc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (blc *BucketLogCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return blc.command.Init(args, options, blc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (blc *BucketLogCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, blc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(blc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">blc.blOption.srcBucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = blc.PutBucketLog()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = blc.GetBucketLog()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = blc.DeleteBucketLog()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (blc *BucketLogCommand) PutBucketLog() error <span class="cov0" title="0">{
        if len(blc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter,the target bucket is empty")
        }</span>

        <span class="cov0" title="0">destBucketUrL, err := GetCloudUrl(blc.command.args[1], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">blc.blOption.destBucketName = destBucketUrL.bucket
        blc.blOption.destPrefix = destBucketUrL.object

        // put bucket log
        client, err := blc.command.ossClient(blc.blOption.srcBucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketLogging(blc.blOption.srcBucketName, blc.blOption.destBucketName, blc.blOption.destPrefix, true)</span>
}

func (blc *BucketLogCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("bucket log: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (blc *BucketLogCommand) GetBucketLog() error <span class="cov0" title="0">{
        client, err := blc.command.ossClient(blc.blOption.srcBucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logRes, err := client.GetBucketLogging(blc.blOption.srcBucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">output, err := xml.MarshalIndent(logRes, "  ", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(blc.command.args) &gt;= 2 </span><span class="cov0" title="0">{
                fileName := blc.command.args[1]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := blc.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(xml.Header))
        outFile.Write(output)

        fmt.Printf("\n\n")

        return nil</span>
}

func (blc *BucketLogCommand) DeleteBucketLog() error <span class="cov0" title="0">{
        client, err := blc.command.ossClient(blc.blOption.srcBucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return client.DeleteBucketLogging(blc.blOption.srcBucketName)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package lib

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "strings"
)

var specChineseBucketPolicy = SpecText{
        synopsisText: "设置、查询或者删除bucket的policy配置",

        paramText: "bucket_url [local_json_file] [options]",

        syntaxText: ` 
        ossutil bucket-policy --method put oss://bucket local_json_file [options]
    ossutil bucket-policy --method get oss://bucket [local_file] [options]
    ossuitl bucket-policy --method delete oss://bucket [options]
`,
        detailHelpText: ` 
    bucket-policy命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的policy配置

用法:
    该命令有三种用法:
        
    1) ossutil bucket-policy --method put oss://bucket local_json_file [options]
        这个命令从配置文件local_json_file中读取policy配置,然后设置bucket的policy规则
        配置文件是一个json格式的文件,举例如下
   
        {
            "Version": "1",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Action": [
                        "ram:ListObjects"
                    ],
                    "Principal": [
                        "1234567"
                    ],
                    "Resource": [
                        "*"
                    ],
                    "Condition": {}
                }
            ]
        }

    2) ossutil bucket-policy --method get oss://bucket [local_json_file] [options]
        这个命令查询bucket的policy配置,如果输入参数local_json_file,policy配置将输出到该文件,否则输出到屏幕上
        
    3) ossutil bucket-policy --method delete oss://bucket [options]
        这个命令删除bucket的policy配置
`,
        sampleText: ` 
    1) 设置bucket的policy配置
       ossutil bucket-policy --method put oss://bucket local_json_file

    2) 查询bucket的policy配置，结果输出到标准输出
       ossutil bucket-policy --method get oss://bucket
        
    3) 查询bucket的policy配置，结果输出到本地文件
       ossutil bucket-policy --method get oss://bucket local_json_file
        
    4) 删除bucket的policy配置
       ossutil bucket-policy --method delete oss://bucket
`,
}

var specEnglishBucketPolicy = SpecText{
        synopsisText: "Set, get or delete bucket policy configuration",

        paramText: "bucket_url [local_json_file] [options]",

        syntaxText: ` 
        ossutil bucket-policy --method put oss://bucket local_json_file [options]
    ossutil bucket-policy --method get oss://bucket [local_json_file] [options]
    ossuitl bucket-policy --method delete oss://bucket [options]
`,
        detailHelpText: ` 
    bucket-policy command can set, get and delete the policy configuration of the oss bucket by
    set method option value to put, get, delete

Usage:
    There are three usages for this command:
        
    1) ossutil bucket-policy --method put oss://bucket local_json_file [options]
        The command sets the policy configuration of bucket from local file local_json_file
        the local_json_file is xml format,for example

        {
            "Version": "1",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Action": [
                        "ram:ListObjects"
                    ],
                    "Principal": [
                        "1234567"
                    ],
                    "Resource": [
                        "*"
                    ],
                    "Condition": {}
                }
            ]
        }
        
    2) ossutil bucket-policy --method get oss://bucket  [local_json_file] [options]
       The command gets the policy configuration of bucket
       If you input parameter local_json_file,the configuration will be output to local_json_file
       If you don't input parameter local_json_file,the configuration will be output to stdout
        
    3) ossutil bucket-policy --method delete oss://bucket [options]
       The command deletes the policy configuration of bucket
`,
        sampleText: ` 
    1) put bucket policy
       ossutil bucket-policy --method put oss://bucket local_json_file

    2) get bucket policy configuration to stdout
       ossutil bucket-policy --method get oss://bucket
        
    3) get bucket policy configuration to local file
       ossutil bucket-policy --method get oss://bucket local_json_file
        
    4) delete bucket policy configuration
       ossutil bucket-policy --method delete oss://bucket
`,
}

type bucketPolicyOptionType struct {
        bucketName string
}

type BucketPolicyCommand struct {
        command  Command
        bpOption bucketPolicyOptionType
}

var bucketPolicyCommand = BucketPolicyCommand{
        command: Command{
                name:        "bucket-policy",
                nameAlias:   []string{"bucket-policy"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseBucketPolicy,
                specEnglish: specEnglishBucketPolicy,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionMethod,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (bpc *BucketPolicyCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return bpc.command.formatHelpForWhole()
}</span>

func (bpc *BucketPolicyCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return bpc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (bpc *BucketPolicyCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return bpc.command.Init(args, options, bpc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (bpc *BucketPolicyCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, bpc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(bpc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bpc.bpOption.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = bpc.PutBucketPolicy()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = bpc.GetBucketPolicy()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = bpc.DeleteBucketPolicy()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (bpc *BucketPolicyCommand) PutBucketPolicy() error <span class="cov0" title="0">{
        if len(bpc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("put bucket policy need at least 2 parameters,the local json file is empty")
        }</span>

        <span class="cov0" title="0">jsonFile := bpc.command.args[1]
        fileInfo, err := os.Stat(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is dir,not the expected file", jsonFile)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is empty file", jsonFile)
        }</span>

        // parsing the xml file
        <span class="cov0" title="0">file, err := os.Open(jsonFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        text, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // put bucket policy
        <span class="cov0" title="0">client, err := bpc.command.ossClient(bpc.bpOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketPolicy(bpc.bpOption.bucketName, string(text))</span>
}

func (bpc *BucketPolicyCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("bucket policy: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (bpc *BucketPolicyCommand) GetBucketPolicy() error <span class="cov0" title="0">{
        client, err := bpc.command.ossClient(bpc.bpOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">policyRes, err := client.GetBucketPolicy(bpc.bpOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(bpc.command.args) &gt;= 2 </span><span class="cov0" title="0">{
                fileName := bpc.command.args[1]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := bpc.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">var jsonText bytes.Buffer
        _ = json.Indent(&amp;jsonText, []byte(policyRes), "", "    ")
        outFile.Write(jsonText.Bytes())

        fmt.Printf("\n\n")

        return nil</span>
}

func (bpc *BucketPolicyCommand) DeleteBucketPolicy() error <span class="cov0" title="0">{
        // delete bucket policy
        client, err := bpc.command.ossClient(bpc.bpOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.DeleteBucketPolicy(bpc.bpOption.bucketName)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package lib

import (
        "encoding/xml"
        "fmt"
        "io/ioutil"
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseBucketQos = SpecText{
        synopsisText: "设置、查询或者删除bucket的qos配置",

        paramText: "bucket_url [local_xml_file] [options]",

        syntaxText: ` 
        ossutil bucket-qos --method put oss://bucket local_xml_file [options]
    ossutil bucket-qos --method get oss://bucket [local_file] [options]
    ossuitl bucket-qos --method delete oss://bucket [options]
`,
        detailHelpText: ` 
    bucket-qos命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的qos配置

用法:
    该命令有三种用法:
        
    1) ossutil bucket-qos --method put oss://bucket local_xml_file [options]
        这个命令从配置文件local_xml_file中读取qos配置,然后设置bucket的qos规则
        配置文件是一个xml格式的文件,举例如下
   
        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;QoSConfiguration&gt;
          &lt;TotalUploadBandwidth&gt;10&lt;/TotalUploadBandwidth&gt;
          &lt;IntranetUploadBandwidth&gt;-1&lt;/IntranetUploadBandwidth&gt;
          &lt;ExtranetUploadBandwidth&gt;-1&lt;/ExtranetUploadBandwidth&gt;
          &lt;TotalDownloadBandwidth&gt;10&lt;/TotalDownloadBandwidth&gt;
          &lt;IntranetDownloadBandwidth&gt;-1&lt;/IntranetDownloadBandwidth&gt;
          &lt;ExtranetDownloadBandwidth&gt;-1&lt;/ExtranetDownloadBandwidth&gt;
          &lt;TotalQps&gt;1000&lt;/TotalQps&gt;
          &lt;IntranetQps&gt;-1&lt;/IntranetQps&gt;
          &lt;ExtranetQps&gt;-1&lt;/ExtranetQps&gt;
        &lt;/QoSConfiguration&gt;

    2) ossutil bucket-qos --method get oss://bucket [local_xml_file] [options]
        这个命令查询bucket的qos配置,如果输入参数local_xml_file,qos配置将输出到该文件,否则输出到屏幕上
        
    3) ossutil bucket-qos --method delete oss://bucket [options]
        这个命令删除bucket的qos配置
`,
        sampleText: ` 
    1) 设置bucket的qos配置
       ossutil bucket-qos --method put oss://bucket local_xml_file

    2) 查询bucket的qos配置，结果输出到标准输出
       ossutil bucket-qos --method get oss://bucket
        
    3) 查询bucket的qos配置，结果输出到本地文件
       ossutil bucket-qos --method get oss://bucket local_xml_file
        
    4) 删除bucket的qos配置
       ossutil bucket-qos --method delete oss://bucket
`,
}

var specEnglishBucketQos = SpecText{
        synopsisText: "Set, get or delete bucket qos configuration",

        paramText: "bucket_url [local_xml_file] [options]",

        syntaxText: ` 
        ossutil bucket-qos --method put oss://bucket local_xml_file [options]
    ossutil bucket-qos --method get oss://bucket [local_xml_file] [options]
    ossuitl bucket-qos --method delete oss://bucket [options]
`,
        detailHelpText: ` 
    bucket-qos command can set, get and delete the qos configuration of the oss bucket by
    set method option value to put, get, delete

Usage:
    There are three usages for this command:
        
    1) ossutil bucket-qos --method put oss://bucket local_xml_file [options]
        The command sets the qos configuration of bucket from local file local_xml_file
        the local_xml_file is xml format,for example

        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;QoSConfiguration&gt;
          &lt;TotalUploadBandwidth&gt;10&lt;/TotalUploadBandwidth&gt;
          &lt;IntranetUploadBandwidth&gt;-1&lt;/IntranetUploadBandwidth&gt;
          &lt;ExtranetUploadBandwidth&gt;-1&lt;/ExtranetUploadBandwidth&gt;
          &lt;TotalDownloadBandwidth&gt;10&lt;/TotalDownloadBandwidth&gt;
          &lt;IntranetDownloadBandwidth&gt;-1&lt;/IntranetDownloadBandwidth&gt;
          &lt;ExtranetDownloadBandwidth&gt;-1&lt;/ExtranetDownloadBandwidth&gt;
          &lt;TotalQps&gt;1000&lt;/TotalQps&gt;
          &lt;IntranetQps&gt;-1&lt;/IntranetQps&gt;
          &lt;ExtranetQps&gt;-1&lt;/ExtranetQps&gt;
        &lt;/QoSConfiguration&gt;
        
    2) ossutil bucket-qos --method get oss://bucket  [local_xml_file] [options]
       The command gets the qos configuration of bucket
       If you input parameter local_xml_file,the configuration will be output to local_xml_file
       If you don't input parameter local_xml_file,the configuration will be output to stdout
        
    3) ossutil bucket-qos --method delete oss://bucket [options]
       The command deletes the qos configuration of bucket
`,
        sampleText: ` 
    1) put bucket qos
       ossutil bucket-qos --method put oss://bucket local_xml_file

    2) get bucket qos configuration to stdout
       ossutil bucket-qos --method get oss://bucket
        
    3) get bucket qos configuration to local file
       ossutil bucket-qos --method get oss://bucket local_xml_file
        
    4) delete bucket qos configuration
       ossutil bucket-qos --method delete oss://bucket
`,
}

type bucketQosOptionType struct {
        bucketName string
}

type BucketQosCommand struct {
        command  Command
        bqOption bucketQosOptionType
}

var bucketQosCommand = BucketQosCommand{
        command: Command{
                name:        "bucket-qos",
                nameAlias:   []string{"bucket-qos"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseBucketQos,
                specEnglish: specEnglishBucketQos,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionMethod,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (bqc *BucketQosCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return bqc.command.formatHelpForWhole()
}</span>

func (bqc *BucketQosCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return bqc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (bqc *BucketQosCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return bqc.command.Init(args, options, bqc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (bqc *BucketQosCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, bqc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(bqc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bqc.bqOption.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = bqc.PutBucketQos()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = bqc.GetBucketQos()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = bqc.DeleteBucketQos()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (bqc *BucketQosCommand) PutBucketQos() error <span class="cov0" title="0">{
        if len(bqc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("put bucket qos need at least 2 parameters,the local xml file is empty")
        }</span>

        <span class="cov0" title="0">xmlFile := bqc.command.args[1]
        fileInfo, err := os.Stat(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is dir,not the expected file", xmlFile)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is empty file", xmlFile)
        }</span>

        // parsing the xml file
        <span class="cov0" title="0">file, err := os.Open(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        text, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">qosConfig := oss.BucketQoSConfiguration{}
        err = xml.Unmarshal(text, &amp;qosConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // put bucket qos
        <span class="cov0" title="0">client, err := bqc.command.ossClient(bqc.bqOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketQoSInfo(bqc.bqOption.bucketName, qosConfig)</span>
}

func (bqc *BucketQosCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("bucket qos: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (bqc *BucketQosCommand) GetBucketQos() error <span class="cov0" title="0">{
        client, err := bqc.command.ossClient(bqc.bqOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">qosRes, err := client.GetBucketQosInfo(bqc.bqOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">output, err := xml.MarshalIndent(qosRes, "  ", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(bqc.command.args) &gt;= 2 </span><span class="cov0" title="0">{
                fileName := bqc.command.args[1]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := bqc.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(xml.Header))
        outFile.Write(output)

        fmt.Printf("\n\n")

        return nil</span>
}

func (bqc *BucketQosCommand) DeleteBucketQos() error <span class="cov0" title="0">{
        // delete bucket qos
        client, err := bqc.command.ossClient(bqc.bqOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.DeleteBucketQosInfo(bqc.bqOption.bucketName)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package lib

import (
        "encoding/xml"
        "fmt"
        "os"
        "strings"
)

var specChineseBucketReferer = SpecText{
        synopsisText: "设置、查询或者删除bucket的referer配置",

        paramText: "bucket_url referer [options]",

        syntaxText: ` 
        ossutil referer --method put oss://bucket referer [options]
    ossutil referer --method get oss://bucket [local_file]
    ossuitl referer --method delete oss://bucket
`,
        detailHelpText: ` 
    referer命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的referer配置

用法:
    该命令有三种用法:
        
    1) ossutil referer --method put oss://bucket referer [options]
       这个命令将bucket的referer设置成后面的referer值
       referer参数可以连续输入多个
        
    2) ossutil referer --method get oss://bucket  [local_xml_file]
        这个命令查询bucket的referer配置
        如果输入参数local_xml_file，referer配置将输出到该文件，否则输出到屏幕上
        
    3)  ossutil referer --method delete oss://bucket
        这个命令删除bucket的referer配置
`,
        sampleText: ` 
    1) 设置bucket的referer配置
       ossutil referer --method put oss://bucket www.test1.com www.test2.com
        
    2) 设置bucket的referer配置，且不允许referer为空
       ossutil referer --method put oss://bucket www.test1.com www.test2.com  --disable-empty-referer

    3) 查询bucket的referer配置，结果输出到标准输出
       ossutil referer --method get oss://bucket
        
    4) 查询bucket的referer配置，结果输出到本地文件
       ossutil referer --method get oss://bucket local_xml_file
        
    5) 删除bucket的referer配置
       ossutil referer --method delete oss://bucket
`,
}

var specEnglishBucketReferer = SpecText{
        synopsisText: "Set、get or delete bucket referer configuration",

        paramText: "bucket_url referer [options]",

        syntaxText: ` 
        ossutil referer --method put oss://bucket referer [options]
    ossutil referer --method get oss://bucket [local_file]
    ossuitl referer --method delete oss://bucket
`,
        detailHelpText: ` 
    referer command can set、get and delete the referer configuration of the oss bucket by
    set method option value to put, get,delete

Usage:
    There are three usages for this command:
        
    1) ossutil referer --method put oss://bucket referer [options]
       This command sets the referer of the bucket to the following referer value.
       You can input many referer parameter.
        
    2) ossutil referer --method get oss://bucket  [local_xml_file]
       The command gets the referer configuration of bucket
       If you input parameter local_xml_file,the configuration will be output to local_xml_file
       If you don't input parameter local_xml_file,the configuration will be output to stdout
        
    3)  ossutil referer --method delete oss://bucket
       The command deletes the referer configuration of bucket
`,
        sampleText: ` 
    1) put bucket referer
       ossutil referer --method put oss://bucket www.test1.com www.test2.com
        
    2) put bucket referer, empty referer is forbidden  
       ossutil referer --method put oss://bucket www.test1.com www.test2.com --disable-empty-referer

    3) get referer configuration to stdout
       ossutil referer --method get oss://bucket
        
    4) get referer configuration to local file
       ossutil referer --method get oss://bucket local_xml_file
        
    5) delete referer configuration
       ossutil referer --method delete oss://bucket
`,
}

type bucketReferOptionType struct {
        bucketName        string
        disableEmptyRefer bool
}

type BucketRefererCommand struct {
        command  Command
        brOption bucketReferOptionType
}

var bucketRefererCommand = BucketRefererCommand{
        command: Command{
                name:        "referer",
                nameAlias:   []string{"referer"},
                minArgc:     1,
                maxArgc:     MaxInt,
                specChinese: specChineseBucketReferer,
                specEnglish: specEnglishBucketReferer,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionDisableEmptyReferer,
                        OptionMethod,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (brc *BucketRefererCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return brc.command.formatHelpForWhole()
}</span>

func (brc *BucketRefererCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return brc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (brc *BucketRefererCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return brc.command.Init(args, options, brc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (brc *BucketRefererCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, brc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(brc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">brc.brOption.bucketName = srcBucketUrL.bucket
        brc.brOption.disableEmptyRefer, _ = GetBool(OptionDisableEmptyReferer, brc.command.options)

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = brc.PutBucketRefer()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = brc.GetBucketRefer()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = brc.DeleteBucketRefer()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (brc *BucketRefererCommand) PutBucketRefer() error <span class="cov0" title="0">{
        if len(brc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("put bucket referer need at least 2 parameters,the refer is empty")
        }</span>

        <span class="cov0" title="0">referers := brc.command.args[1:len(brc.command.args)]

        // put bucket refer
        client, err := brc.command.ossClient(brc.brOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketReferer(brc.brOption.bucketName, referers, !brc.brOption.disableEmptyRefer)</span>
}

func (brc *BucketRefererCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("bucket referer: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (brc *BucketRefererCommand) GetBucketRefer() error <span class="cov0" title="0">{
        client, err := brc.command.ossClient(brc.brOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">referRes, err := client.GetBucketReferer(brc.brOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">output, err := xml.MarshalIndent(referRes, "  ", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(brc.command.args) &gt;= 2 </span><span class="cov0" title="0">{
                fileName := brc.command.args[1]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := brc.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(xml.Header))
        outFile.Write(output)

        fmt.Printf("\n\n")

        return nil</span>
}

func (brc *BucketRefererCommand) DeleteBucketRefer() error <span class="cov0" title="0">{

        referers := []string{}

        // put bucket refer
        client, err := brc.command.ossClient(brc.brOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketReferer(brc.brOption.bucketName, referers, true)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package lib

import (
        "fmt"
        "strings"

        "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseBucketTag = SpecText{
        synopsisText: "设置、查询或者删除bucket的tag配置",

        paramText: "bucket_url [tag_parameter] [options]",

        syntaxText: ` 
    ossutil bucket-tagging --method put oss://bucket key#value
    ossutil bucket-tagging --method get oss://bucket 
    ossuitl bucket-tagging --method delete oss://bucket
`,
        detailHelpText: ` 
    bucket-tagging命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的tag配置
    每个tag的key和value必须以字符'#'分隔,最多可以连续输入10个tag信息

用法:
    该命令有三种用法:
        
    1) ossutil bucket-tagging --method put oss://bucket  tagkey#tagvalue
        这个命令设置bucket的tag配置,key和value分别为tagkey、tagvalue
        
    2) ossutil bucket-tagging --method get oss://bucket 
        这个命令查询bucket的tag配置
        
    3)  ossutil bucket-tagging --method delete oss://bucket
        这个命令删除bucket的tag配置
`,
        sampleText: ` 
    1) 设置bucket的tag配置
       ossutil bucket-tagging --method put oss://bucket  tagkey#tagvalue
    
    2) 设置bucket的多个tag配置
       ossutil bucket-tagging --method put oss://bucket  tagkey1#tagvalue1 tagkey2#tagvalue2
        
    3) 查询bucket的tag配置
       ossutil bucket-tagging --method get oss://bucket
        
    4) 删除bucket的tag配置
       ossutil bucket-tagging --method delete oss://bucket
`,
}

var specEnglishBucketTag = SpecText{
        synopsisText: "Set, get or delete bucket tag configuration",

        paramText: "bucket_url [tag_parameter] [options]",

        syntaxText: ` 
    ossutil bucket-tagging --method put oss://bucket key#value
    ossutil bucket-tagging --method get oss://bucket 
    ossuitl bucket-tagging --method delete oss://bucket
`,
        detailHelpText: ` 
    bucket-tagging command can set, get and delete the tag configuration of the oss bucket by set method option value to put, get, delete
    the key and value of each tag must be separated by the character '#', you can enter up to 10 tag parameters.
Usage:
    There are three usages for this command:
        
    1) ossutil bucket-tagging --method put oss://bucket tagkey#tagvalue
        The command sets the tag configuration of the bucket. The key and value are tagkey and tagvalue
        
    2) ossutil bucket-tagging --method get oss://bucket 
        The command gets the tag configuration of bucket

    3) ossutil bucket-tagging --method delete oss://bucket
        The command deletes the tag configuration of bucket
`,
        sampleText: ` 
    1) set bucket tag configuration with one tag   
       ossutil bucket-tagging --method put oss://bucket tagkey#tagvalue
    
    2) set bucket tag configuration with serveral tags
       ossutil bucket-tagging --method put oss://bucket tagkey1#tagvalue1 tagkey2#tagvalue2 

    3) get bucket tag configuration
       ossutil bucket-tagging --method get oss://bucket
        
    4) delete bucket tag configuration
       ossutil bucket-tagging --method delete oss://bucket
`,
}

type BucketTagCommand struct {
        command    Command
        bucketName string
        tagResult  oss.GetBucketTaggingResult
}

var bucketTagCommand = BucketTagCommand{
        command: Command{
                name:        "bucket-tagging",
                nameAlias:   []string{"bucket-tagging"},
                minArgc:     1,
                maxArgc:     11,
                specChinese: specChineseBucketTag,
                specEnglish: specEnglishBucketTag,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionMethod,
                        OptionLogLevel,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (btc *BucketTagCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return btc.command.formatHelpForWhole()
}</span>

func (btc *BucketTagCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return btc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (btc *BucketTagCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return btc.command.Init(args, options, btc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (btc *BucketTagCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, btc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(btc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">btc.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = btc.PutBucketTag()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = btc.GetBucketTag()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = btc.DeleteBucketTag()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (btc *BucketTagCommand) PutBucketTag() error <span class="cov0" title="0">{
        if len(btc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter,the tag value is empty")
        }</span>

        <span class="cov0" title="0">var tagging oss.Tagging
        tagList := btc.command.args[1:len(btc.command.args)]
        for _, tag := range tagList </span><span class="cov0" title="0">{
                pSlice := strings.Split(tag, "#")
                if len(pSlice) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s error,tag name and tag value must be separated by #", tag)
                }</span>
                <span class="cov0" title="0">tagging.Tags = append(tagging.Tags, oss.Tag{Key: pSlice[0], Value: pSlice[1]})</span>
        }

        // put bucket tag
        <span class="cov0" title="0">client, err := btc.command.ossClient(btc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketTagging(btc.bucketName, tagging)</span>
}

func (btc *BucketTagCommand) GetBucketTag() error <span class="cov0" title="0">{
        client, err := btc.command.ossClient(btc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">btc.tagResult, err = client.GetBucketTagging(btc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(btc.tagResult.Tags) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("%-10s%s\t%s\n", "index", "tag key", "tag value")
                fmt.Printf("---------------------------------------------------\n")
        }</span>

        <span class="cov0" title="0">for index, tag := range btc.tagResult.Tags </span><span class="cov0" title="0">{
                fmt.Printf("%-10d\"%s\"\t\"%s\"\n", index, tag.Key, tag.Value)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n\n")

        return nil</span>
}

func (btc *BucketTagCommand) DeleteBucketTag() error <span class="cov0" title="0">{
        client, err := btc.command.ossClient(btc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return client.DeleteBucketTagging(btc.bucketName)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package lib

import (
        "fmt"
        "strings"

        "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseBucketVersioning = SpecText{
        synopsisText: "设置、查询bucket的versioning配置",

        paramText: "bucket_url [versioning_parameter] [options]",

        syntaxText: ` 
    ossutil bucket-versioning --method put oss://bucket versioning_parameter
    ossutil bucket-versioning --method get oss://bucket 
`,
        detailHelpText: ` 
    bucket-versioning命令通过设置method选项值为put、get、可以设置、查询bucket的versioning配置
    选项--method为put时,versioning状态参数只能为enabled、suspended

用法:
    该命令有三种用法:
        
    1) ossutil bucket-versioning --method put oss://bucket enabled
        这个命令开通bucket的versioning功能
        
    2) ossutil bucket-versioning --method put oss://bucket suspended
        这个命令关闭bucket的versioning功能
        
    3)  ossutil bucket-versioning --method get oss://bucket
        这个命令查询bucket的vesioning状态
`,
        sampleText: ` 
    1) 开通bucket的versioning功能
       ossutil bucket-versioning --method put oss://bucket enabled
    
    2) 关闭bucket的versioning功能
       ossutil bucket-versioning --method put oss://bucket suspended
        
    3) 查询bucket的versioning状态
       ossutil bucket-versioning --method get oss://bucket
`,
}

var specEnglishBucketVersioning = SpecText{
        synopsisText: "Set, get bucket versioning configuration",

        paramText: "bucket_url [versioning_parameter] [options]",

        syntaxText: ` 
    ossutil bucket-versioning --method put oss://bucket versioning_parameter
    ossutil bucket-versioning --method get oss://bucket 
`,
        detailHelpText: ` 
    bucket-versioning command can set, get the versioning configuration of the oss bucket by set method option value to put, get
    If the --method option value is put,the versioning status value can only be enabled, suspended, 
Usage:
    There are three usages for this command:
        
    1) ossutil bucket-versioning --method put oss://bucket enabled
    This command enables the bucket versioning

    2) ossutil bucket-versioning --method put oss://bucket suspended
    This command disables the bucket versioning

    3)  ossutil bucket-versioning --method get oss://bucket
    This command query the bucket versioning status
`,
        sampleText: ` 
    1) set bucket versioning enabled
       ossutil bucket-versioning --method put oss://bucket enabled
    
    2) set bucket versioning disable
       ossutil bucket-versioning --method put oss://bucket suspended
        
    3) get bucket versioning status
       ossutil bucket-versioning --method get oss://bucket
`,
}

type BucketVersioningCommand struct {
        command          Command
        bucketName       string
        versioningResult oss.GetBucketVersioningResult
}

var bucketVersioningCommand = BucketVersioningCommand{
        command: Command{
                name:        "bucket-versioning",
                nameAlias:   []string{"bucket-versioning"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseBucketVersioning,
                specEnglish: specEnglishBucketVersioning,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionMethod,
                        OptionLogLevel,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (bvc *BucketVersioningCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return bvc.command.formatHelpForWhole()
}</span>

func (bvc *BucketVersioningCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return bvc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (bvc *BucketVersioningCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return bvc.command.Init(args, options, bvc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (bvc *BucketVersioningCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, bvc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(bvc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bvc.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = bvc.PutBucketVersioning()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = bvc.GetBucketVersioning()
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (bvc *BucketVersioningCommand) PutBucketVersioning() error <span class="cov0" title="0">{

        if len(bvc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter,versioning status is empty")
        }</span>

        <span class="cov0" title="0">strVersion := bvc.command.args[1]

        if strings.ToUpper(strVersion) != strings.ToUpper(string(oss.VersionEnabled)) &amp;&amp;
                strings.ToUpper(strVersion) != strings.ToUpper(string(oss.VersionSuspended)) </span><span class="cov0" title="0">{
                return fmt.Errorf("version status must be %s or %s", string(oss.VersionEnabled),
                        string(oss.VersionSuspended))
        }</span>

        // put bucket versioning
        <span class="cov0" title="0">client, err := bvc.command.ossClient(bvc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var versioningConfig oss.VersioningConfig
        if strings.ToUpper(strVersion) == strings.ToUpper(string(oss.VersionEnabled)) </span><span class="cov0" title="0">{
                versioningConfig.Status = string(oss.VersionEnabled)
        }</span> else<span class="cov0" title="0"> if strings.ToUpper(strVersion) == strings.ToUpper(string(oss.VersionSuspended)) </span><span class="cov0" title="0">{
                versioningConfig.Status = string(oss.VersionSuspended)

        }</span>
        <span class="cov0" title="0">return client.SetBucketVersioning(bvc.bucketName, versioningConfig)</span>
}

func (bvc *BucketVersioningCommand) GetBucketVersioning() error <span class="cov0" title="0">{
        client, err := bvc.command.ossClient(bvc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bvc.versioningResult, err = client.GetBucketVersioning(bvc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if bvc.versioningResult.Status == "" </span><span class="cov0" title="0">{
                bvc.versioningResult.Status = "null"
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nbucket versioning status:%s\n", bvc.versioningResult.Status)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package lib

import (
        "fmt"
        "io/ioutil"
        "os"
        "strings"
)

var specChineseBucketWebSite = SpecText{
        synopsisText: "设置、查询或者删除bucket的website配置",

        paramText: "bucket_url local_xml_file [options]",

        syntaxText: ` 
        ossutil website --method put oss://bucket local_xml_file [options]
    ossutil website --method get oss://bucket [local_file] [options]
    ossuitl website --method delete oss://bucket [options]
`,
        detailHelpText: ` 
    website命令通过设置method选项值为put、get、delete,可以设置、查询或者删除bucket的website配置

用法:
    该命令有三种用法:
        
    1) ossutil website --method put oss://bucket local_xml_file [options]
        这个命令从配置文件local_xml_file中读取website配置,然后设置bucket的website规则
        配置文件是一个xml格式的文件,可以选择只配置部分规则,下面是一个所有规则的例子
   
        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;WebsiteConfiguration&gt;
            &lt;IndexDocument&gt;
                &lt;Suffix&gt;index.html&lt;/Suffix&gt;
            &lt;/IndexDocument&gt;
            &lt;ErrorDocument&gt;
                &lt;Key&gt;error.html&lt;/Key&gt;
            &lt;/ErrorDocument&gt;
            &lt;RoutingRules&gt;
                &lt;RoutingRule&gt;
                    &lt;RuleNumber&gt;1&lt;/RuleNumber&gt;
                    &lt;Condition&gt;
                        &lt;KeyPrefixEquals&gt;abc/&lt;/KeyPrefixEquals&gt;
                        &lt;HttpErrorCodeReturnedEquals&gt;404&lt;/HttpErrorCodeReturnedEquals&gt;
                    &lt;/Condition&gt;
                    &lt;Redirect&gt;
                        &lt;RedirectType&gt;Mirror&lt;/RedirectType&gt;
                        &lt;PassQueryString&gt;true&lt;/PassQueryString&gt;
                        &lt;MirrorURL&gt;http://www.test.com/&lt;/MirrorURL&gt;
                        &lt;MirrorPassQueryString&gt;true&lt;/MirrorPassQueryString&gt;
                        &lt;MirrorFollowRedirect&gt;true&lt;/MirrorFollowRedirect&gt;
                        &lt;MirrorCheckMd5&gt;false&lt;/MirrorCheckMd5&gt;
                        &lt;MirrorHeaders&gt;
                          &lt;PassAll&gt;true&lt;/PassAll&gt;
                          &lt;Pass&gt;myheader-key1&lt;/Pass&gt;
                          &lt;Pass&gt;myheader-key2&lt;/Pass&gt;
                          &lt;Remove&gt;myheader-key3&lt;/Remove&gt;
                          &lt;Remove&gt;myheader-key4&lt;/Remove&gt;
                          &lt;Set&gt;
                            &lt;Key&gt;myheader-key5&lt;/Key&gt;
                            &lt;Value&gt;myheader-value5&lt;/Value&gt;
                          &lt;/Set&gt;
                        &lt;/MirrorHeaders&gt;
                    &lt;/Redirect&gt;
                &lt;/RoutingRule&gt;
                &lt;RoutingRule&gt;
                    &lt;RuleNumber&gt;2&lt;/RuleNumber&gt;
                    &lt;Condition&gt;
                      &lt;KeyPrefixEquals&gt;abc/&lt;/KeyPrefixEquals&gt;
                      &lt;HttpErrorCodeReturnedEquals&gt;404&lt;/HttpErrorCodeReturnedEquals&gt;
                      &lt;IncludeHeader&gt;
                        &lt;Key&gt;host&lt;/Key&gt;
                        &lt;Equals&gt;test.oss-cn-beijing-internal.aliyuncs.com&lt;/Equals&gt;
                      &lt;/IncludeHeader&gt;
                    &lt;/Condition&gt;
                    &lt;Redirect&gt;
                      &lt;RedirectType&gt;AliCDN&lt;/RedirectType&gt;
                      &lt;Protocol&gt;http&lt;/Protocol&gt;
                      &lt;HostName&gt;www.test.com&lt;/HostName&gt;
                      &lt;PassQueryString&gt;false&lt;/PassQueryString&gt;
                      &lt;ReplaceKeyWith&gt;prefix/${key}.suffix&lt;/ReplaceKeyWith&gt;
                      &lt;HttpRedirectCode&gt;301&lt;/HttpRedirectCode&gt;
                    &lt;/Redirect&gt;
                &lt;/RoutingRule&gt;
            &lt;/RoutingRules&gt;
        &lt;/WebsiteConfiguration&gt;

    2) ossutil website --method get oss://bucket  [local_xml_file] [options]
        这个命令查询bucket的website配置
        如果输入参数local_xml_file，website配置将输出到该文件，否则输出到屏幕上
        
    3) ossutil website --method delete oss://bucket [options]
        这个命令删除bucket的website配置
`,
        sampleText: ` 
    1) 设置bucket的website配置
       ossutil website --method put oss://bucket local_xml_file

    2) 查询bucket的website配置，结果输出到标准输出
       ossutil website --method get oss://bucket
        
    3) 查询bucket的website配置，结果输出到本地文件
       ossutil website --method get oss://bucket local_xml_file
        
    4) 删除bucket的website配置
       ossutil website --method delete oss://bucket
`,
}

var specEnglishBucketWebSite = SpecText{
        synopsisText: "Set, get or delete bucket website configuration",

        paramText: "bucket_url website [options]",

        syntaxText: ` 
        ossutil website --method put oss://bucket local_xml_file [options]
    ossutil website --method get oss://bucket [local_xml_file] [options]
    ossuitl website --method delete oss://bucket [options]
`,
        detailHelpText: ` 
    website command can set, get and delete the website configuration of the oss bucket by
    set method option value to put, get, delete

Usage:
    There are three usages for this command:
        
    1) ossutil website --method put oss://bucket local_xml_file [options]
        The command sets the website configuration of bucket from local file local_xml_file
        the local_xml_file is xml format,you can choose to configure only some rules
        The following is an example of all rules:

        &lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;WebsiteConfiguration&gt;
            &lt;IndexDocument&gt;
                &lt;Suffix&gt;index.html&lt;/Suffix&gt;
            &lt;/IndexDocument&gt;
            &lt;ErrorDocument&gt;
                &lt;Key&gt;error.html&lt;/Key&gt;
            &lt;/ErrorDocument&gt;
            &lt;RoutingRules&gt;
                &lt;RoutingRule&gt;
                    &lt;RuleNumber&gt;1&lt;/RuleNumber&gt;
                    &lt;Condition&gt;
                        &lt;KeyPrefixEquals&gt;abc/&lt;/KeyPrefixEquals&gt;
                        &lt;HttpErrorCodeReturnedEquals&gt;404&lt;/HttpErrorCodeReturnedEquals&gt;
                    &lt;/Condition&gt;
                    &lt;Redirect&gt;
                        &lt;RedirectType&gt;Mirror&lt;/RedirectType&gt;
                        &lt;PassQueryString&gt;true&lt;/PassQueryString&gt;
                        &lt;MirrorURL&gt;http://www.test.com/&lt;/MirrorURL&gt;
                        &lt;MirrorPassQueryString&gt;true&lt;/MirrorPassQueryString&gt;
                        &lt;MirrorFollowRedirect&gt;true&lt;/MirrorFollowRedirect&gt;
                        &lt;MirrorCheckMd5&gt;false&lt;/MirrorCheckMd5&gt;
                        &lt;MirrorHeaders&gt;
                          &lt;PassAll&gt;true&lt;/PassAll&gt;
                          &lt;Pass&gt;myheader-key1&lt;/Pass&gt;
                          &lt;Pass&gt;myheader-key2&lt;/Pass&gt;
                          &lt;Remove&gt;myheader-key3&lt;/Remove&gt;
                          &lt;Remove&gt;myheader-key4&lt;/Remove&gt;
                          &lt;Set&gt;
                            &lt;Key&gt;myheader-key5&lt;/Key&gt;
                            &lt;Value&gt;myheader-value5&lt;/Value&gt;
                          &lt;/Set&gt;
                        &lt;/MirrorHeaders&gt;
                    &lt;/Redirect&gt;
                &lt;/RoutingRule&gt;
                &lt;RoutingRule&gt;
                    &lt;RuleNumber&gt;2&lt;/RuleNumber&gt;
                    &lt;Condition&gt;
                      &lt;KeyPrefixEquals&gt;abc/&lt;/KeyPrefixEquals&gt;
                      &lt;HttpErrorCodeReturnedEquals&gt;404&lt;/HttpErrorCodeReturnedEquals&gt;
                      &lt;IncludeHeader&gt;
                        &lt;Key&gt;host&lt;/Key&gt;
                        &lt;Equals&gt;test.oss-cn-beijing-internal.aliyuncs.com&lt;/Equals&gt;
                      &lt;/IncludeHeader&gt;
                    &lt;/Condition&gt;
                    &lt;Redirect&gt;
                      &lt;RedirectType&gt;AliCDN&lt;/RedirectType&gt;
                      &lt;Protocol&gt;http&lt;/Protocol&gt;
                      &lt;HostName&gt;www.test.com&lt;/HostName&gt;
                      &lt;PassQueryString&gt;false&lt;/PassQueryString&gt;
                      &lt;ReplaceKeyWith&gt;prefix/${key}.suffix&lt;/ReplaceKeyWith&gt;
                      &lt;HttpRedirectCode&gt;301&lt;/HttpRedirectCode&gt;
                    &lt;/Redirect&gt;
                &lt;/RoutingRule&gt;
            &lt;/RoutingRules&gt;
        &lt;/WebsiteConfiguration&gt;
        
    2) ossutil website --method get oss://bucket  [local_xml_file] [options]
       The command gets the website configuration of bucket
       If you input parameter local_xml_file,the configuration will be output to local_xml_file
       If you don't input parameter local_xml_file,the configuration will be output to stdout
        
    3) ossutil website --method delete oss://bucket [options]
       The command deletes the website configuration of bucket
`,
        sampleText: ` 
    1) put bucket website
       ossutil website --method put oss://bucket local_xml_file

    2) get website configuration to stdout
       ossutil website --method get oss://bucket
        
    3) get website configuration to local file
       ossutil website --method get oss://bucket local_xml_file
        
    4) delete website configuration
       ossutil website --method delete oss://bucket
`,
}

type bucketWebSiteOptionType struct {
        bucketName string
}

type BucketWebSiteCommand struct {
        command  Command
        bwOption bucketWebSiteOptionType
}

var bucketWebsiteCommand = BucketWebSiteCommand{
        command: Command{
                name:        "website",
                nameAlias:   []string{"website"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseBucketWebSite,
                specEnglish: specEnglishBucketWebSite,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionMethod,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (bwc *BucketWebSiteCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return bwc.command.formatHelpForWhole()
}</span>

func (bwc *BucketWebSiteCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return bwc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (bwc *BucketWebSiteCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return bwc.command.Init(args, options, bwc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (bwc *BucketWebSiteCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, bwc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(bwc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bwc.bwOption.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = bwc.PutBucketWebsite()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = bwc.GetBucketWebsite()
        }</span> else<span class="cov0" title="0"> if strMethod == "delete" </span><span class="cov0" title="0">{
                err = bwc.DeleteBucketWebsite()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (bwc *BucketWebSiteCommand) PutBucketWebsite() error <span class="cov0" title="0">{
        if len(bwc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("put bucket website need at least 2 parameters,the local xml file is empty")
        }</span>

        <span class="cov0" title="0">xmlFile := bwc.command.args[1]
        fileInfo, err := os.Stat(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is dir,not the expected file", xmlFile)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is empty file", xmlFile)
        }</span>

        // parsing the xml file
        <span class="cov0" title="0">file, err := os.Open(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        text, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // put bucket website
        <span class="cov0" title="0">client, err := bwc.command.ossClient(bwc.bwOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.SetBucketWebsiteXml(bwc.bwOption.bucketName, string(text))</span>
}

func (bwc *BucketWebSiteCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("bucket website: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (bwc *BucketWebSiteCommand) GetBucketWebsite() error <span class="cov0" title="0">{
        client, err := bwc.command.ossClient(bwc.bwOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">output, err := client.GetBucketWebsiteXml(bwc.bwOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(bwc.command.args) &gt;= 2 </span><span class="cov0" title="0">{
                fileName := bwc.command.args[1]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := bwc.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(output))

        fmt.Printf("\n\n")

        return nil</span>
}

func (bwc *BucketWebSiteCommand) DeleteBucketWebsite() error <span class="cov0" title="0">{
        // delete bucket website
        client, err := bwc.command.ossClient(bwc.bwOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return client.DeleteBucketWebsite(bwc.bwOption.bucketName)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package lib

import (
        "encoding/xml"
        "fmt"
        "strconv"

        "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseWorm = SpecText{
        synopsisText: "设置、删除、修改、提交bucket的Worm配置",

        paramText: "command_name bucket_url [days] [wormId] [options]",

        syntaxText: ` 
    ossutil worm init  oss://bucket days
    ossutil worm abort oss://bucket
    ossutil worm complete oss://bucket wormId
    ossuitl worm extend oss://bucket days wormId
    ossuitl worm get oss://bucket

`,
        detailHelpText: ` 
    worm命令通过设置第一个参数为init、abort、complete、extend、get,可以创建、删除、提交、修改或者查询bucket的worm配置

用法:
    该命令有五种用法:
        
    1) ossutil worm init oss://bucket days
        这个命令创建worm配置，Object的保留天数为days
        
    2) ossutil worm abort oss://bucket
        这个命令删除bucket的Worm配置
        
    3) ossutil worm complete oss://bucket wormId
        这个命令提交worm配置，成功后worm状态将由InProgress变为Locked

    4) ossutil worm extend oss://bucket days wormId
        这个命令修改worm配置，将Object的保留天数修改为days
    
    5) ossutil worm get oss://bucket
        这个命令查询worm配置
    
`,
        sampleText: ` 
`,
}

var specEnglishWorm = SpecText{
        synopsisText: "set、delete、complete、get bucket's worm configuration",

        paramText: "command_name bucket_url [days] [wormId] [options]",

        syntaxText: ` 
    ossutil worm init  oss://bucket days
    ossutil worm abort oss://bucket
    ossutil worm complete oss://bucket wormId
    ossuitl worm extend oss://bucket days wormId
    ossuitl worm get oss://bucket

`,
        detailHelpText: ` 
    The worm command can create, delete, complete, modify or get the worm configuration of the bucket 
    by setting the first parameter to init, abort, complete, extend, and get

Usage:
    There are 5 usages for this command:
        
    1) ossutil worm init oss://bucket days
       This command creates a worm configuration, the object's retention period is days
        
    2) ossutil worm abort oss://bucket
       This command deletes the worm configuration of the bucket
        
    3) ossutil worm complete oss://bucket wormId
       This command complete the worm configuration. 
       After success, the worm status will change from InProgress to Locked

    4) ossutil worm extend oss://bucket days wormId
       This command modifies the worm configuration and changes the retention period of objects to days
    
    5) ossutil worm get oss://bucket
       This command get worm configuration
    
`,
        sampleText: ` 
`,
}

type wormOptionType struct {
        bucketName string
        wormConfig oss.WormConfiguration
}

type WormCommand struct {
        command  Command
        wmOption wormOptionType
}

var wormCommand = WormCommand{
        command: Command{
                name:        "worm",
                nameAlias:   []string{"worm"},
                minArgc:     2,
                maxArgc:     4,
                specChinese: specChineseWorm,
                specEnglish: specEnglishWorm,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (wormc *WormCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return wormc.command.formatHelpForWhole()
}</span>

func (wormc *WormCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return wormc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (wormc *WormCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return wormc.command.Init(args, options, wormc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (wormc *WormCommand) RunCommand() error <span class="cov0" title="0">{
        // init all command name
        commandDict := make(map[string]string)
        commandDict["init"] = "init"
        commandDict["abort"] = "abort"
        commandDict["complete"] = "complete"
        commandDict["extend"] = "extend"
        commandDict["get"] = "get"

        // check command name
        strCommand := wormc.command.args[0]
        _, ok := commandDict[strCommand]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid parameter %s,which must be init, abort, complete, extend, get", strCommand)
        }</span>

        <span class="cov0" title="0">bucketUrL, err := StorageURLFromString(wormc.command.args[1], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !bucketUrL.IsCloudURL() </span><span class="cov0" title="0">{
                return fmt.Errorf("parameter is not a cloud url,url is %s", bucketUrL.ToString())
        }</span>

        <span class="cov0" title="0">cloudUrl := bucketUrL.(CloudURL)
        if cloudUrl.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("bucket name is empty,url is %s", bucketUrL.ToString())
        }</span>

        <span class="cov0" title="0">wormc.wmOption.bucketName = cloudUrl.bucket

        if strCommand == "init" </span><span class="cov0" title="0">{
                err = wormc.InitiateBucketWorm()
        }</span> else<span class="cov0" title="0"> if strCommand == "abort" </span><span class="cov0" title="0">{
                err = wormc.AbortBucketWorm()
        }</span> else<span class="cov0" title="0"> if strCommand == "complete" </span><span class="cov0" title="0">{
                err = wormc.CompleteBucketWorm()
        }</span> else<span class="cov0" title="0"> if strCommand == "extend" </span><span class="cov0" title="0">{
                err = wormc.ExtendBucketWorm()
        }</span> else<span class="cov0" title="0"> if strCommand == "get" </span><span class="cov0" title="0">{
                err = wormc.GetBucketWorm()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (wormc *WormCommand) InitiateBucketWorm() error <span class="cov0" title="0">{
        if len(wormc.command.args) &lt; 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter,the parameter day is empty")
        }</span>

        <span class="cov0" title="0">retentionDays, err := strconv.Atoi(wormc.command.args[2])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client, err := wormc.command.ossClient(wormc.wmOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wormID, err := client.InitiateBucketWorm(wormc.wmOption.bucketName, retentionDays)
        if wormID != "" </span><span class="cov0" title="0">{
                fmt.Printf("init success,worm id is %s", wormID)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (wormc *WormCommand) AbortBucketWorm() error <span class="cov0" title="0">{
        client, err := wormc.command.ossClient(wormc.wmOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return client.AbortBucketWorm(wormc.wmOption.bucketName)</span>
}

func (wormc *WormCommand) CompleteBucketWorm() error <span class="cov0" title="0">{
        if len(wormc.command.args) &lt; 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter,the wormId is empty")
        }</span>

        <span class="cov0" title="0">client, err := wormc.command.ossClient(wormc.wmOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return client.CompleteBucketWorm(wormc.wmOption.bucketName, wormc.command.args[2])</span>
}

func (wormc *WormCommand) ExtendBucketWorm() error <span class="cov0" title="0">{
        if len(wormc.command.args) &lt; 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter, need 4 parameters")
        }</span>

        <span class="cov0" title="0">retentionDays, err := strconv.Atoi(wormc.command.args[2])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client, err := wormc.command.ossClient(wormc.wmOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return client.ExtendBucketWorm(wormc.wmOption.bucketName, retentionDays, wormc.command.args[3])</span>
}

func (wormc *WormCommand) GetBucketWorm() error <span class="cov0" title="0">{
        client, err := wormc.command.ossClient(wormc.wmOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wormConfig, err := client.GetBucketWorm(wormc.wmOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wormc.wmOption.wormConfig = wormConfig
        output, err := xml.MarshalIndent(wormConfig, "  ", "    ")
        if err == nil </span><span class="cov0" title="0">{
                fmt.Println(string(output))
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package lib

import (
        "fmt"
        "io"
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseCat = SpecText{
        synopsisText: "将文件内容输出到标准输出",

        paramText: "object [options]",

        syntaxText: ` 
        ossutil cat oss://bucket/object [--payer requester] [--version-id versionId]
`,
        detailHelpText: ` 
    cat命令可以将oss的object内容输出到标准输出,object内容最好是文本格式

用法:
    该命令仅有一种用法:
        
    1) ossutil cat oss://bucket/object [--version-id versionId] [--payer requester]
       将object内容输出到标准输出
`,
        sampleText: ` 
    1) 将object内容输出到标准输出
       ossutil cat oss://bucket/object
    
    2) 将object指定版本内容输出到标准输出
       ossutil cat oss://bucket/object --version-id versionId
    
    3) 访问者付费模式
       ossutil cat oss://bucket/object --payer requester
`,
}

var specEnglishCat = SpecText{
        synopsisText: "Output object content to standard output",

        paramText: "object [options]",

        syntaxText: ` 
        ossutil cat oss://bucket/object [--payer requester] [--version-id versionId]
`,
        detailHelpText: ` 
        The cat command can output the object content of oss to standard output
    The object content is preferably text format

Usage:
    There is only one usage for this command:
        
    1) ossutil cat oss://bucket/object [--version-id versionId] [--payer requester]
       The command output object content to standard output
`,
        sampleText: ` 
    1) output object content to standard output
       ossutil cat oss://bucket/object
    
    2) output the object's specified version content to standard output
       ossutil cat oss://bucket/object --version-id versionId
    
    3) output object content with requester payment
       ossutil cat oss://bucket/object --payer requester
`,
}

type catOptionType struct {
        bucketName   string
        objectName   string
        encodingType string
}

type CatCommand struct {
        command       Command
        catOption     catOptionType
        commonOptions []oss.Option
}

var catCommand = CatCommand{
        command: Command{
                name:        "cat",
                nameAlias:   []string{"cat"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseCat,
                specEnglish: specEnglishCat,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionEncodingType,
                        OptionLogLevel,
                        OptionVersionId,
                        OptionRequestPayer,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (catc *CatCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return catc.command.formatHelpForWhole()
}</span>

func (catc *CatCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return catc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (catc *CatCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return catc.command.Init(args, options, catc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (catc *CatCommand) RunCommand() error <span class="cov0" title="0">{
        catc.catOption.encodingType, _ = GetString(OptionEncodingType, catc.command.options)
        srcBucketUrL, err := GetCloudUrl(catc.command.args[0], catc.catOption.encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if srcBucketUrL.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("object key is empty")
        }</span>

        <span class="cov0" title="0">catc.catOption.bucketName = srcBucketUrL.bucket
        catc.catOption.objectName = srcBucketUrL.object

        // check object exist or not
        client, err := catc.command.ossClient(catc.catOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := client.Bucket(catc.catOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">payer, _ := GetString(OptionRequestPayer, catc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">catc.commonOptions = append(catc.commonOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        <span class="cov0" title="0">var options []oss.Option
        options = append(options, catc.commonOptions...)

        versionId, _ := GetString(OptionVersionId, catc.command.options)
        if len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, oss.VersionId(versionId))
        }</span>

        <span class="cov0" title="0">body, err := bucket.GetObject(catc.catOption.objectName, options...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer body.Close()
        io.Copy(os.Stdout, body)
        fmt.Printf("\n")

        return err</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package lib

import (
        "fmt"
        "net"
        "net/http"
        "net/url"
        "reflect"
        "strconv"
        "strings"
        "time"

        "workspace/ossutil/sts"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

// group spec text of all commands
const (
        GroupTypeNormalCommand string = "\nCommands:\n"

        GroupTypeAdditionalCommand string = "\nAdditional Commands:\n"

        GroupTypeDeprecatedCommand string = "\nDeprecated Commands:\n"
)

// CommandGroups is the array of all group types
var CommandGroups = []string{
        GroupTypeNormalCommand,
        GroupTypeAdditionalCommand,
        GroupTypeDeprecatedCommand,
}

// SpecText is the spec text of a command
type SpecText struct {
        synopsisText   string
        paramText      string
        syntaxText     string
        detailHelpText string
        sampleText     string
}

// Command contains all elements of a command, it's the base class of all commands
type Command struct {
        name             string
        nameAlias        []string
        minArgc          int
        maxArgc          int
        specChinese      SpecText
        specEnglish      SpecText
        validOptionNames []string
        group            string
        args             []string
        options          OptionMapType
        configOptions    OptionMapType
        inputKeySecret   string
}

// Commander is the interface of all commands
type Commander interface {
        RunCommand() error
        Init(args []string, options OptionMapType) error
}

// RewriteLoadConfiger is the interface for those commands, which do not need to load config, or have other action
type RewriteLoadConfiger interface {
        rewriteLoadConfig(string) error
}

// RewriteAssembleOptioner is the interface for those commands, which do not need to assemble options
type RewriteAssembleOptioner interface {
        rewriteAssembleOptions()
}

// Init is the common functions for all commands, they use Init to initialize itself
func (cmd *Command) Init(args []string, options OptionMapType, cmder interface{}) error <span class="cov7" title="67">{
        cmd.args = args
        cmd.options = options
        cmd.configOptions = OptionMapType{}

        if err := cmd.checkArgs(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="67">val, _ := GetString(OptionConfigFile, cmd.options)
        if err := cmd.loadConfig(val, cmder); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="67">if err := cmd.checkOptions(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="67">cmd.assembleOptions(cmder)
        return nil</span>
}

func (cmd *Command) checkArgs() error <span class="cov7" title="67">{
        str := ""
        if cmd.minArgc &gt; 1 </span><span class="cov5" title="24">{
                str = "s"
        }</span>
        <span class="cov7" title="67">if len(cmd.args) &lt; cmd.minArgc </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("the command needs at least %d argument%s", cmd.minArgc, str)
                return CommandError{cmd.name, msg}
        }</span>

        <span class="cov7" title="67">str = ""
        if cmd.minArgc &gt; 1 </span><span class="cov5" title="24">{
                str = "s"
        }</span>

        <span class="cov7" title="67">if len(cmd.args) &gt; cmd.maxArgc </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("the command needs at most %d argument%s", cmd.maxArgc, str)
                return CommandError{cmd.name, msg}
        }</span>
        <span class="cov7" title="67">return nil</span>
}

func (cmd *Command) loadConfig(configFile string, cmder interface{}) error <span class="cov7" title="67">{
        if cmdder, ok := cmder.(RewriteLoadConfiger); ok </span><span class="cov1" title="1">{
                return cmdder.rewriteLoadConfig(configFile)
        }</span>
        <span class="cov7" title="66">var err error
        if cmd.configOptions, err = LoadConfig(configFile); err != nil &amp;&amp; cmd.needConfigFile() </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="66">return nil</span>
}

func (cmd *Command) needConfigFile() bool <span class="cov0" title="0">{
        for _, name := range []string{OptionEndpoint, OptionAccessKeyID, OptionAccessKeySecret, OptionSTSToken} </span><span class="cov0" title="0">{
                val, _ := GetString(name, cmd.options)
                if val != "" </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (cmd *Command) checkOptions() error <span class="cov7" title="67">{
        for name := range cmd.options </span><span class="cov10" title="533">{
                msg := fmt.Sprintf("the command does not support option: \"%s\"", name)
                switch OptionMap[name].optionType </span>{
                case OptionTypeFlagTrue:<span class="cov7" title="120">
                        if val, _ := GetBool(name, cmd.options); val </span><span class="cov7" title="100">{
                                if FindPos(name, cmd.validOptionNames) == -1 </span><span class="cov0" title="0">{
                                        return CommandError{cmd.name, msg}
                                }</span>
                        }
                default:<span class="cov9" title="413">
                        if val, _ := GetString(name, cmd.options); val != "" </span><span class="cov8" title="180">{
                                if FindPos(name, cmd.validOptionNames) == -1 </span><span class="cov0" title="0">{
                                        return CommandError{cmd.name, msg}
                                }</span>
                        }
                }
        }
        <span class="cov7" title="67">return nil</span>
}

func (cmd *Command) assembleOptions(cmder interface{}) <span class="cov7" title="67">{
        if cmdder, ok := cmder.(RewriteAssembleOptioner); ok </span><span class="cov1" title="1">{
                cmdder.rewriteAssembleOptions()
                return
        }</span>

        <span class="cov7" title="66">for name, option := range cmd.configOptions </span><span class="cov9" title="324">{
                if _, ok := cmd.options[name]; ok </span><span class="cov8" title="188">{
                        if OptionMap[name].optionType != OptionTypeFlagTrue </span><span class="cov8" title="188">{
                                if val, _ := GetString(name, cmd.options); val == "" </span><span class="cov8" title="162">{
                                        opval := option.(string)
                                        cmd.options[name] = &amp;opval
                                        delete(cmd.configOptions, name)
                                }</span> else<span class="cov5" title="26"> if name == OptionEndpoint </span><span class="cov4" title="10">{
                                        delete(cmd.configOptions, BucketCnameSection)
                                        delete(cmd.configOptions, BucketEndpointSection)
                                }</span>
                        }
                }
        }

        <span class="cov7" title="66">for name := range cmd.options </span><span class="cov9" title="527">{
                if OptionMap[name].def != "" </span><span class="cov6" title="50">{
                        switch OptionMap[name].optionType </span>{
                        case OptionTypeInt64:<span class="cov5" title="26">
                                if val, _ := GetString(name, cmd.options); val == "" </span><span class="cov0" title="0">{
                                        def, _ := strconv.ParseInt(OptionMap[name].def, 10, 64)
                                        cmd.options[name] = &amp;def
                                }</span>
                        case OptionTypeAlternative:<span class="cov0" title="0">
                                fallthrough</span>
                        case OptionTypeString:<span class="cov5" title="24">
                                if val, _ := GetString(name, cmd.options); val == "" </span><span class="cov0" title="0">{
                                        def := OptionMap[name].def
                                        cmd.options[name] = &amp;def
                                }</span>
                        }
                }
        }
}

// FormatHelper is the interface for all commands to format spec information
type FormatHelper interface {
        formatHelpForWhole() string
        formatIndependHelp() string
}

func (cmd *Command) formatHelpForWhole() string <span class="cov0" title="0">{
        formatStr := "  %-" + strconv.Itoa(MaxCommandNameLen) + "s%s\n%s%s%s\n"
        spec := cmd.getSpecText()
        return fmt.Sprintf(formatStr, cmd.name, spec.paramText, FormatTAB, FormatTAB, spec.synopsisText)
}</span>

func (cmd *Command) getSpecText() SpecText <span class="cov0" title="0">{
        val, _ := GetString(OptionLanguage, helpCommand.command.options)
        switch strings.ToLower(val) </span>{
        case LEnglishLanguage:<span class="cov0" title="0">
                return cmd.specEnglish</span>
        default:<span class="cov0" title="0">
                return cmd.specChinese</span>
        }
}

func (cmd *Command) formatIndependHelp() string <span class="cov0" title="0">{
        spec := cmd.getSpecText()
        text := fmt.Sprintf("SYNOPSIS\n\n%s%s\n", FormatTAB, strings.TrimSpace(spec.synopsisText))
        if spec.syntaxText != "" </span><span class="cov0" title="0">{
                text += fmt.Sprintf("\nSYNTAX\n\n%s%s\n", FormatTAB, strings.TrimSpace(spec.syntaxText))
        }</span>
        <span class="cov0" title="0">if spec.detailHelpText != "" </span><span class="cov0" title="0">{
                text += fmt.Sprintf("\nDETAIL DESCRIPTION\n\n%s%s\n", FormatTAB, strings.TrimSpace(spec.detailHelpText))
        }</span>
        <span class="cov0" title="0">if spec.sampleText != "" </span><span class="cov0" title="0">{
                text += fmt.Sprintf("\nSAMPLE\n\n%s%s\n", FormatTAB, strings.TrimSpace(spec.sampleText))
        }</span>
        <span class="cov0" title="0">if len(cmd.validOptionNames) != 0 </span><span class="cov0" title="0">{
                text += fmt.Sprintf("\nOPTIONS\n\n%s\n", cmd.formatOptionsHelp(cmd.validOptionNames))
        }</span>
        <span class="cov0" title="0">return text</span>
}

func (cmd *Command) formatOptionsHelp(validOptionNames []string) string <span class="cov0" title="0">{
        text := ""
        for _, optionName := range validOptionNames </span><span class="cov0" title="0">{
                if option, ok := OptionMap[optionName]; ok </span><span class="cov0" title="0">{
                        text += cmd.formatOption(option)
                }</span>
        }
        <span class="cov0" title="0">return text</span>
}

func (cmd *Command) formatOption(option Option) string <span class="cov0" title="0">{
        text := FormatTAB
        if option.name != "" </span><span class="cov0" title="0">{
                text += option.name
                if option.def != "" </span><span class="cov0" title="0">{
                        text += " " + option.def
                }</span>
        }

        <span class="cov0" title="0">if option.name != "" &amp;&amp; option.nameAlias != "" </span><span class="cov0" title="0">{
                text += ", "
        }</span>

        <span class="cov0" title="0">if option.nameAlias != "" </span><span class="cov0" title="0">{
                text += option.nameAlias
                if option.def != "" </span><span class="cov0" title="0">{
                        text += fmt.Sprintf("=%s", option.def)
                }</span>
        }

        <span class="cov0" title="0">val, _ := GetString(OptionLanguage, helpCommand.command.options)
        val = strings.ToLower(val)
        opHelp := option.getHelp(val)
        if opHelp != "" </span><span class="cov0" title="0">{
                text += fmt.Sprintf("\n%s%s%s\n\n", FormatTAB, FormatTAB, opHelp)
        }</span>

        <span class="cov0" title="0">return text</span>
}

// OSS common function
// get oss client according to bucket(if bucket not empty)
func (cmd *Command) ossClient(bucket string) (*oss.Client, error) <span class="cov7" title="66">{
        endpoint, isCname := cmd.getEndpoint(bucket)
        accessKeyID, _ := GetString(OptionAccessKeyID, cmd.options)
        accessKeySecret, _ := GetString(OptionAccessKeySecret, cmd.options)
        stsToken, _ := GetString(OptionSTSToken, cmd.options)
        disableCRC64, _ := GetBool(OptionDisableCRC64, cmd.options)
        proxyHost, _ := GetString(OptionProxyHost, cmd.options)
        proxyUser, _ := GetString(OptionProxyUser, cmd.options)
        proxyPwd, _ := GetString(OptionProxyPwd, cmd.options)

        mode, _ := GetString(OptionMode, cmd.options)
        ramRoleName, _ := GetString(OptionRamRoleName, cmd.options)

        strExpireSeconds, _ := GetString(OptionExpiredSeconds, cmd.options)
        ramRoleArn, _ := GetString(OptionRamRoleArn, cmd.options)
        roleSessionName, _ := GetString(OptionRoleSessionName, cmd.options)

        strReadTimeout, _ := GetString(OptionReadTimeout, cmd.options)
        strConnectTimeout, _ := GetString(OptionConnectTimeout, cmd.options)

        stsRegion, _ := GetString(OptionSTSRegion, cmd.options)

        ecsUrl := ""

        localHost, _ := GetString(OptionLocalHost, cmd.options)

        bPassword, _ := GetBool(OptionPassword, cmd.options)

        if bPassword </span><span class="cov0" title="0">{
                if cmd.inputKeySecret == "" </span><span class="cov0" title="0">{
                        strPwd, err := GetPassword("input access key secret:")
                        fmt.Printf("\r")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">cmd.inputKeySecret = string(strPwd)</span>
                }
                <span class="cov0" title="0">accessKeySecret = cmd.inputKeySecret</span>
        }

        <span class="cov7" title="66">options := []oss.ClientOption{}

        if strings.EqualFold(mode, "AK") </span><span class="cov1" title="2">{
                if err := cmd.checkCredentials(endpoint, accessKeyID, accessKeySecret); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov6" title="64"> if strings.EqualFold(mode, "StsToken") </span><span class="cov1" title="1">{

                if err := cmd.checkCredentials(endpoint, accessKeyID, accessKeySecret); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">if stsToken == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("stsToken is empty")
                }</span>
                <span class="cov0" title="0">options = append(options, oss.SecurityToken(stsToken))</span>

        } else<span class="cov6" title="63"> if strings.EqualFold(mode, "RamRoleArn") </span><span class="cov4" title="9">{
                if err := cmd.checkCredentials(endpoint, accessKeyID, accessKeySecret); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="9">if ramRoleArn == "" </span><span class="cov2" title="3">{
                        ramRoleArn, _ = cmd.getRamRoleArnService()
                }</span>
                <span class="cov4" title="9">if ramRoleArn == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("ramRoleArn is empty")
                }</span>
                <span class="cov3" title="8">if roleSessionName == "" </span><span class="cov3" title="8">{
                        roleSessionName = "SessNameRand" + randStr(5)
                }</span>
                // sts.NewClient(stsaccessID, stsaccessKey, stsARN, "oss_test_sess")
                <span class="cov3" title="8">stsClient := sts.NewClient(accessKeyID, accessKeySecret, ramRoleArn, roleSessionName)

                if strExpireSeconds == "" </span><span class="cov3" title="6">{
                        strExpireSeconds = "3600"
                }</span>
                <span class="cov3" title="8">intExpireSeconds, err := strconv.Atoi(strExpireSeconds)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="8">expireSeconds := uint(intExpireSeconds)

                stsEndPoint := ""
                if stsRegion == "" </span><span class="cov3" title="6">{
                        stsEndPoint = ""
                }</span> else<span class="cov1" title="2"> {
                        stsEndPoint = "https://sts.cn-" + stsRegion + ".aliyuncs.com"
                }</span>

                <span class="cov3" title="8">resp, err := stsClient.AssumeRole(expireSeconds, stsEndPoint)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov3" title="8">accessKeyID = resp.Credentials.AccessKeyId
                accessKeySecret = resp.Credentials.AccessKeySecret
                stsToken = resp.Credentials.SecurityToken
                options = append(options, oss.SecurityToken(stsToken))</span>

        } else<span class="cov6" title="54"> if strings.EqualFold(mode, "EcsRamRole") </span><span class="cov3" title="5">{
                if ramRoleName != "" </span><span class="cov1" title="2">{
                        ecsUrl = "http://100.100.100.200/latest/meta-data/Ram/security-credentials/" + ramRoleName
                }</span> else<span class="cov2" title="3"> {
                        ecsUrl, _ = cmd.getEcsRamAkService()
                }</span>

                <span class="cov3" title="5">if ecsUrl == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("ecsUrl is empty")
                }</span>
                <span class="cov2" title="4">ecsRoleAKBuild := EcsRoleAKBuild{url: ecsUrl}
                options = append(options, oss.SetCredentialsProvider(&amp;ecsRoleAKBuild))</span>

        } else<span class="cov6" title="49"> if mode == "" </span><span class="cov6" title="49">{

                ecsUrl, _ = cmd.getEcsRamAkService()
                if accessKeyID == "" &amp;&amp; ecsUrl == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("accessKeyID and ecsUrl are both empty")
                }</span>
                <span class="cov6" title="48">if ecsUrl == "" </span><span class="cov6" title="46">{
                        if err := cmd.checkCredentials(endpoint, accessKeyID, accessKeySecret); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov6" title="48">if accessKeyID == "" </span><span class="cov1" title="2">{
                        LogInfo("using user ak service:%s\n", ecsUrl)
                        ecsRoleAKBuild := EcsRoleAKBuild{url: ecsUrl}
                        options = append(options, oss.SetCredentialsProvider(&amp;ecsRoleAKBuild))
                }</span>

                <span class="cov6" title="48">options = append(options, oss.SecurityToken(stsToken))</span>
        }

        <span class="cov6" title="62">if strConnectTimeout == "" </span><span class="cov6" title="60">{
                strConnectTimeout = "120"
        }</span>
        <span class="cov6" title="62">if strReadTimeout == "" </span><span class="cov6" title="60">{
                strReadTimeout = "1200"
        }</span>
        <span class="cov6" title="62">connectTimeout, err := strconv.ParseInt(strConnectTimeout, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="62">readTimeout, err := strconv.ParseInt(strReadTimeout, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="62">options = append(options, oss.UseCname(isCname), oss.UserAgent(getUserAgent()), oss.Timeout(connectTimeout, readTimeout))

        if disableCRC64 </span><span class="cov0" title="0">{
                options = append(options, oss.EnableCRC(false))
        }</span> else<span class="cov6" title="62"> {
                options = append(options, oss.EnableCRC(true))
        }</span>

        <span class="cov6" title="62">if proxyHost != "" </span><span class="cov0" title="0">{
                if proxyUser != "" </span><span class="cov0" title="0">{
                        options = append(options, oss.AuthProxy(proxyHost, proxyUser, proxyPwd))
                }</span> else<span class="cov0" title="0"> {
                        options = append(options, oss.Proxy(proxyHost))
                }</span>
        }

        <span class="cov6" title="62">if localHost != "" </span><span class="cov0" title="0">{
                ipAddr, err := net.ResolveIPAddr("ip", localHost)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("net.ResolveIPAddr error,%s", err.Error())
                }</span>
                <span class="cov0" title="0">localTCPAddr := &amp;(net.TCPAddr{IP: ipAddr.IP})
                options = append(options, oss.SetLocalAddr(localTCPAddr))</span>
        }

        <span class="cov6" title="62">if logLevel &gt; oss.LogOff </span><span class="cov0" title="0">{
                options = append(options, oss.SetLogLevel(logLevel))
                options = append(options, oss.SetLogger(utilLogger))
        }</span>

        <span class="cov6" title="62">client, err := oss.New(endpoint, accessKeyID, accessKeySecret, options...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="62">maxUpSpeed, errUp := GetInt(OptionMaxUpSpeed, cmd.options)
        if errUp == nil </span><span class="cov0" title="0">{
                if maxUpSpeed &gt;= 0 </span><span class="cov0" title="0">{
                        errUp = client.LimitUploadSpeed(int(maxUpSpeed))
                        if errUp != nil </span><span class="cov0" title="0">{
                                return nil, errUp
                        }</span> else<span class="cov0" title="0"> {
                                LogInfo("set maxupspeed success,value is %d(KB/s)\n", maxUpSpeed)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("invalid value,maxupspeed %d less than 0", maxUpSpeed)
                }</span>
        }

        <span class="cov6" title="62">return client, nil</span>
}

func (cmd *Command) checkCredentials(endpoint, accessKeyID, accessKeySecret string) error <span class="cov6" title="58">{
        if strings.TrimSpace(endpoint) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid endpoint, endpoint is empty, please check your config")
        }</span>
        <span class="cov6" title="58">if strings.TrimSpace(accessKeyID) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid accessKeyID, accessKeyID is empty, please check your config")
        }</span>
        <span class="cov6" title="58">if strings.TrimSpace(accessKeySecret) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid accessKeySecret, accessKeySecret is empty, please check your config")
        }</span>
        <span class="cov6" title="58">return nil</span>
}

func (cmd *Command) getEcsRamAkService() (string, bool) <span class="cov6" title="52">{
        if urlMap, ok := cmd.configOptions[AkServiceSection]; ok </span><span class="cov2" title="4">{
                if strUrl, ok := urlMap.(map[string]string)[ItemEcsAk]; ok </span><span class="cov2" title="4">{
                        if strUrl != "" </span><span class="cov2" title="4">{
                                return strUrl, true
                        }</span> else<span class="cov0" title="0"> {
                                return "", false
                        }</span>
                }
        }
        <span class="cov6" title="48">return "", false</span>
}

func (cmd *Command) getRamRoleArnService() (string, bool) <span class="cov2" title="3">{
        if arnMap, ok := cmd.configOptions[CREDSection]; ok </span><span class="cov2" title="3">{
                if strArn, ok := arnMap.(map[string]string)[ItemRamRoleArn]; ok </span><span class="cov1" title="2">{
                        if strArn != "" </span><span class="cov1" title="2">{
                                return strArn, true
                        }</span> else<span class="cov0" title="0"> {
                                return "", false
                        }</span>
                }
        }
        <span class="cov1" title="1">return "", false</span>
}

func (cmd *Command) getEndpoint(bucket string) (string, bool) <span class="cov7" title="66">{
        if cnameMap, ok := cmd.configOptions[BucketCnameSection]; ok </span><span class="cov0" title="0">{
                if endpoint, ok := cnameMap.(map[string]string)[bucket]; ok </span><span class="cov0" title="0">{
                        return endpoint, true
                }</span>
        }

        <span class="cov7" title="66">if eMap, ok := cmd.configOptions[BucketEndpointSection]; ok </span><span class="cov0" title="0">{
                if endpoint, ok := eMap.(map[string]string)[bucket]; ok </span><span class="cov0" title="0">{
                        return endpoint, false
                }</span>
        }

        <span class="cov7" title="66">endpoint, _ := GetString(OptionEndpoint, cmd.options)
        return endpoint, false</span>
}

// get oss operable bucket
func (cmd *Command) ossBucket(bucketName string) (*oss.Bucket, error) <span class="cov6" title="52">{
        client, err := cmd.ossClient(bucketName)
        if err != nil </span><span class="cov2" title="4">{
                return nil, err
        }</span>

        <span class="cov6" title="48">bucket, err := client.Bucket(bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="48">return bucket, nil</span>
}

func (cmd *Command) ossListObjectsRetry(bucket *oss.Bucket, options ...oss.Option) (oss.ListObjectsResult, error) <span class="cov6" title="52">{
        retryTimes, _ := GetInt(OptionRetryTimes, cmd.options)
        for i := 1; ; i++ </span><span class="cov6" title="52">{
                lor, err := bucket.ListObjects(options...)
                if err == nil </span><span class="cov6" title="48">{
                        return lor, err
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov2" title="3">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov2" title="3">{
                        return lor, ObjectError{err, bucket.BucketName, ""}
                }</span>

                // wait 1 second
                <span class="cov0" title="0">time.Sleep(time.Duration(1) * time.Second)</span>
        }
}

func (cmd *Command) ossListObjectVersionsRetry(bucket *oss.Bucket, options ...oss.Option) (oss.ListObjectVersionsResult, error) <span class="cov5" title="28">{
        retryTimes, _ := GetInt(OptionRetryTimes, cmd.options)
        for i := 1; ; i++ </span><span class="cov5" title="28">{
                lor, err := bucket.ListObjectVersions(options...)
                if err == nil </span><span class="cov5" title="24">{
                        return lor, err
                }</span>
                <span class="cov2" title="4">if int64(i) &gt;= retryTimes </span><span class="cov2" title="4">{
                        return lor, BucketError{err, bucket.BucketName}
                }</span>
        }
}

func (cmd *Command) ossListMultipartUploadsRetry(bucket *oss.Bucket, options ...oss.Option) (oss.ListMultipartUploadResult, error) <span class="cov5" title="24">{
        retryTimes, _ := GetInt(OptionRetryTimes, cmd.options)
        for i := 1; ; i++ </span><span class="cov5" title="24">{
                lmr, err := bucket.ListMultipartUploads(options...)
                if err == nil </span><span class="cov5" title="24">{
                        return lmr, err
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov0" title="0">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                        return lmr, ObjectError{err, bucket.BucketName, ""}
                }</span>

                // wait 1 second
                <span class="cov0" title="0">time.Sleep(time.Duration(1) * time.Second)</span>
        }
}

func (cmd *Command) ossGetObjectStatRetry(bucket *oss.Bucket, object string, options ...oss.Option) (http.Header, error) <span class="cov5" title="20">{
        retryTimes, _ := GetInt(OptionRetryTimes, cmd.options)
        for i := 1; ; i++ </span><span class="cov5" title="20">{
                props, err := bucket.GetObjectDetailedMeta(object, options...)
                if err == nil </span><span class="cov5" title="20">{
                        return props, err
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov0" title="0">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                        return props, ObjectError{err, bucket.BucketName, object}
                }</span>

                // wait 1 second
                <span class="cov0" title="0">time.Sleep(time.Duration(1) * time.Second)</span>
        }
}

func (cmd *Command) ossGetObjectMetaRetry(bucket *oss.Bucket, object string, options ...oss.Option) (http.Header, error) <span class="cov4" title="10">{
        retryTimes, _ := GetInt(OptionRetryTimes, cmd.options)
        for i := 1; ; i++ </span><span class="cov4" title="10">{
                props, err := bucket.GetObjectMeta(object, options...)
                if err == nil </span><span class="cov0" title="0">{
                        return props, err
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov4" title="10">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov4" title="10">{
                        return props, ObjectError{err, bucket.BucketName, object}
                }</span>

                // wait 1 second
                <span class="cov0" title="0">time.Sleep(time.Duration(1) * time.Second)</span>
        }
}

func (cmd *Command) objectStatistic(bucket *oss.Bucket, cloudURL CloudURL, monitor Monitorer, filters []filterOptionType, options ...oss.Option) <span class="cov0" title="0">{
        if monitor == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">pre := oss.Prefix(cloudURL.object)
        marker := oss.Marker("")
        for </span><span class="cov0" title="0">{
                listOptions := append(options, marker, pre)
                lor, err := cmd.ossListObjectsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        monitor.setScanError(err)
                        return
                }</span>

                <span class="cov0" title="0">for _, object := range lor.Objects </span><span class="cov0" title="0">{
                        if doesSingleObjectMatchPatterns(object.Key, filters) </span><span class="cov0" title="0">{
                                monitor.updateScanNum(1)
                        }</span>
                }

                <span class="cov0" title="0">marker = oss.Marker(lor.NextMarker)
                if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">monitor.setScanEnd()</span>
}

func (cmd *Command) objectProducer(bucket *oss.Bucket, cloudURL CloudURL, chObjects chan&lt;- string, chError chan&lt;- error, filters []filterOptionType, options ...oss.Option) <span class="cov0" title="0">{
        pre := oss.Prefix(cloudURL.object)
        marker := oss.Marker("")
        for </span><span class="cov0" title="0">{
                listOptions := append(options, marker, pre)
                lor, err := cmd.ossListObjectsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        break</span>
                }

                <span class="cov0" title="0">for _, object := range lor.Objects </span><span class="cov0" title="0">{
                        if doesSingleObjectMatchPatterns(object.Key, filters) </span><span class="cov0" title="0">{
                                chObjects &lt;- object.Key
                        }</span>
                }

                <span class="cov0" title="0">pre = oss.Prefix(lor.Prefix)
                marker = oss.Marker(lor.NextMarker)
                if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">defer close(chObjects)
        chError &lt;- nil</span>
}

func (cmd *Command) getRawMarker(str string) (string, error) <span class="cov1" title="2">{
        encodingType, _ := GetString(OptionEncodingType, cmd.options)
        if encodingType == URLEncodingType </span><span class="cov0" title="0">{
                unencodedStr, err := url.QueryUnescape(str)
                if err != nil </span><span class="cov0" title="0">{
                        return str, err
                }</span>
                <span class="cov0" title="0">return unencodedStr, nil</span>
        }
        <span class="cov1" title="2">return str, nil</span>
}

func (cmd *Command) updateMonitor(err error, monitor *Monitor) <span class="cov0" title="0">{
        if monitor == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                monitor.updateOKNum(1)
        }</span> else<span class="cov0" title="0"> {
                monitor.updateErrNum(1)
        }</span>
        <span class="cov0" title="0">fmt.Printf(monitor.progressBar(false, normalExit))</span>
}

func (cmd *Command) report(msg string, err error, option *batchOptionType) <span class="cov0" title="0">{
        if cmd.filterError(err, option) </span><span class="cov0" title="0">{
                option.reporter.ReportError(fmt.Sprintf("%s error, info: %s", msg, err.Error()))
                option.reporter.Prompt(err)
        }</span>
}

func (cmd *Command) filterError(err error, option *batchOptionType) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">errorTypeName := reflect.TypeOf(err).String()
        if !strings.Contains(errorTypeName, "ObjectError") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">err = err.(ObjectError).err

        switch err.(type) </span>{
        case oss.ServiceError:<span class="cov0" title="0">
                code := err.(oss.ServiceError).Code
                if code == "NoSuchBucket" || code == "InvalidAccessKeyId" || code == "SignatureDoesNotMatch" || code == "AccessDenied" || code == "RequestTimeTooSkewed" || code == "InvalidBucketName" </span><span class="cov0" title="0">{
                        option.ctnu = false
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (cmd *Command) getOSSOptions(hopMap map[string]interface{}, headers map[string]string) ([]oss.Option, error) <span class="cov0" title="0">{
        options := []oss.Option{}
        for name, value := range headers </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.ToLower(name), strings.ToLower(oss.HTTPHeaderOssMetaPrefix)) </span><span class="cov0" title="0">{
                        options = append(options, oss.Meta(name[len(oss.HTTPHeaderOssMetaPrefix):], value))
                }</span> else<span class="cov0" title="0"> {
                        option, err := getOSSOption(hopMap, name, value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">options = append(options, option)</span>
                }
        }
        <span class="cov0" title="0">return options, nil</span>
}

func (cmd *Command) getOSSTagging(strTagging string) ([]oss.Tag, error) <span class="cov0" title="0">{
        tags := []oss.Tag{}
        strKeys := strings.Split(strTagging, "&amp;")
        for _, v := range strKeys </span><span class="cov0" title="0">{
                if v == "" </span><span class="cov0" title="0">{
                        return tags, fmt.Errorf("tagging value is empty,maybe exist &amp;&amp;")
                }</span>
                <span class="cov0" title="0">tagNode := strings.Split(v, "=")
                if len(tagNode) &gt;= 3 </span><span class="cov0" title="0">{
                        return tags, fmt.Errorf("tagging value error %s", v)
                }</span>

                // value maybe empty
                <span class="cov0" title="0">tagNode = append(tagNode, "")
                tags = append(tags, oss.Tag{
                        Key:   tagNode[0],
                        Value: tagNode[1],
                })</span>
        }
        <span class="cov0" title="0">return tags, nil</span>
}

// GetAllCommands returns all commands list
func GetAllCommands() []interface{} <span class="cov1" title="1">{
        return []interface{}{
                &amp;helpCommand,
                &amp;configCommand,
                &amp;makeBucketCommand,
                &amp;listCommand,
                &amp;removeCommand,
                &amp;statCommand,
                &amp;setACLCommand,
                &amp;setMetaCommand,
                &amp;copyCommand,
                &amp;restoreCommand,
                &amp;createSymlinkCommand,
                &amp;readSymlinkCommand,
                &amp;signURLCommand,
                &amp;hashCommand,
                &amp;updateCommand,
                &amp;probeCommand,
                &amp;mkdirCommand,
                &amp;corsCommand,
                &amp;bucketLogCommand,
                &amp;bucketRefererCommand,
                &amp;listPartCommand,
                &amp;allPartSizeCommand,
                &amp;appendFileCommand,
                &amp;catCommand,
                &amp;bucketTagCommand,
                &amp;bucketEncryptionCommand,
                &amp;corsOptionsCommand,
                &amp;bucketLifeCycleCommand,
                &amp;bucketWebsiteCommand,
                &amp;bucketQosCommand,
                &amp;userQosCommand,
                &amp;bucketVersioningCommand,
                &amp;duSizeCommand,
                &amp;bucketPolicyCommand,
                &amp;requestPaymentCommand,
                &amp;objectTagCommand,
                &amp;bucketInventoryCommand,
                &amp;revertCommand,
                &amp;syncCommand,
                &amp;wormCommand,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package lib

import (
        "fmt"
        "os"
        "reflect"
        "runtime"
        "strings"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var commandLine string

func LogEnd(startT time.Time) <span class="cov0" title="0">{
        LogInfo("ossutil run end,cost:%d(ms).\n", time.Now().UnixNano()/1000/1000-startT.UnixNano()/1000/1000)
        UnInitLogger()
}</span>

// ParseAndRunCommand parse command line user input, get command and options, then run command
func ParseAndRunCommand() error <span class="cov0" title="0">{
        ts := time.Now().UnixNano()

        commandLine = getCommandLine()

        clearEnv()

        args, options, err := ParseArgOptions()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var level = oss.LogOff
        strLevel, err := GetString(OptionLogLevel, options)
        if strLevel == "info" </span><span class="cov0" title="0">{
                level = oss.Info
        }</span> else<span class="cov0" title="0"> if strLevel == "debug" </span><span class="cov0" title="0">{
                level = oss.Debug
        }</span> else<span class="cov0" title="0"> if len(strLevel) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("loglevel must be:info|debug")
        }</span>

        <span class="cov0" title="0">if level &gt; oss.LogOff </span><span class="cov0" title="0">{
                InitLogger(level, logName)
        }</span>

        <span class="cov0" title="0">startT := time.Now()
        LogInfo("ossutil run begin,cmd:%s\n", commandLine)
        LogInfo("ossutil version is %s\n", Version)
        LogInfo("oss go sdk version is %s\n", oss.Version)
        LogInfo("go version is %s\n", runtime.Version())
        LogInfo("runtime.NumCPU is %d\n", runtime.NumCPU())

        defer LogEnd(startT)

        showElapse, err := RunCommand(args, options)
        if err != nil </span><span class="cov0" title="0">{
                LogError("%s.\n", err.Error())
                return err
        }</span>
        <span class="cov0" title="0">if showElapse </span><span class="cov0" title="0">{
                te := time.Now().UnixNano()
                fmt.Printf("\n%.6f(s) elapsed\n", float64(te-ts)/1e9)
                return nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getCommandLine() string <span class="cov0" title="0">{
        return strings.Join(os.Args, " ")
}</span>

func clearEnv() <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                _, renameFilePath := getBinaryPath()
                os.Remove(renameFilePath)
        }</span>
}

func RunCommand(args []string, options OptionMapType) (bool, error) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                if val, _ := GetBool(OptionVersion, options); val </span><span class="cov0" title="0">{
                        fmt.Printf("ossutil version: %s\n", Version)
                        return false, nil
                }</span>
                <span class="cov0" title="0">args = append(args, "help")</span>
        }
        <span class="cov0" title="0">command := args[0]
        args = args[1:]

        cm := CommandManager{}
        cm.Init()
        showElapse, err := cm.RunCommand(command, args, options)
        return showElapse, err</span>
}

// CommandManager is used to manager commands, such as build command map and run command
type CommandManager struct {
        commandMap map[string]interface{}
}

// Init build command map
func (cm *CommandManager) Init() <span class="cov1" title="1">{
        commandList := GetAllCommands()
        cm.commandMap = make(map[string]interface{}, len(commandList))

        for _, cmd := range commandList </span><span class="cov8" title="40">{
                name := reflect.ValueOf(cmd).Elem().FieldByName("command").FieldByName("name").String()
                cm.commandMap[name] = cmd
        }</span>
}

// RunCommand select command from command map, initialize command and run command
func (cm *CommandManager) RunCommand(commandName string, args []string, options OptionMapType) (bool, error) <span class="cov10" title="67">{

        if cmd, ok := cm.commandMap[commandName]; ok </span><span class="cov10" title="67">{
                if err := cmd.(Commander).Init(args, options); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov10" title="67">if err := cmd.(Commander).RunCommand(); err != nil </span><span class="cov5" title="8">{
                        return false, err
                }</span>
                <span class="cov9" title="59">group := reflect.ValueOf(cmd).Elem().FieldByName("command").FieldByName("group").String()
                return group == GroupTypeNormalCommand, nil</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("no such command: \"%s\", please try \"help\" for more information", commandName)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package lib

import (
        "bufio"
        "fmt"
        "os"
        "runtime"
        "strings"

        configparser "github.com/alyu/configparser"
)

var specChineseConfig = SpecText{

        synopsisText: "创建配置文件用以存储配置项",

        paramText: "[options]",

        syntaxText: ` 
    ossutil config [-e endpoint] [-i id] [-k key] [-t token] [-L language] [--output-dir outdir] [-c file] 
`,

        detailHelpText: ` 
    该命令创建配置文件，将用户设置的配置项信息存储进该配置文件，配置项用
    以访问OSS时提供访问信息（某命令是否需要配置项，参见其是否支持
    --config-file选项，具体可见该命令的帮助）。

    配置文件路径可由用户指定，默认为` + DecideConfigFile("") + `。如果配置
    文件存在，假设其为:a，ossutil会将文件a另存为：a.bak，然后重新创建文件a
    并写入配置，此时，如果a.bak存在，其会被文件a覆盖。

    注意：
    （1）如果指定的配置文件路径非默认路径，在使用命令时请将--config-file选
    项设置为你配置时指定的配置文件路径（如果不指定--config-file选项，则运
    行命令时默认会读取` + DecideConfigFile("") + `）。

    （2）某些配置可在使用命令时通过选项进行设置，如--endpoint，--access-key-id，
    等选项（具体请见每个命令的帮助），如果使用命令时指定了这些选项，并且同
    时配置文件中也配置了这些信息，则优先级为：选项 &gt; 配置文件。

    （3）如果使用命令时指定了--endpoint、--access-key-id、--access-key-secret
    或--sts-token选项，则ossutil不强求配置文件一定要存在。

用法:

    该命令有两种用法，交互式1)和非交互式2)，推荐用法为交互式，因为交互
    式用法拥有更好的安全性。

    1) ossutil config [-c file]
        该用法提供一种交互式的方法来配置信息，ossutil交互式地询问用户如下
    信息：
        (1) config file
            配置文件路径，如果用户键入回车，ossutil会使用默认的配置文件：
        ` + DecideConfigFile("") + `。
            如果用户自己指定了配置文件，在使用命令时需要将--config-file选项
        设置为用户设置的配置文件路径。哪些命令支持--config-file选项可由查看
        每个命令的帮助。
        (2) language
            当首次配置（配置文件不存在）时，ossutil会向用户询问语言设置，可
        选值为中文或者英文（` + OptionMap[OptionLanguage].minVal + `），如果键入回车，ossutil将根据用户输入的
        --language选项配置，如果此时用户也未输入--language选项，将配置成默认
        语言中文。
            如果配置文件已存在，ossutil会综合用户输入的language选项和配置文件
        中的语言信息，配置该项，而不会询问。
            ossutil在运行时会从配置文件中读取该language选项，如果该选项不存在
        或者非法，将采用默认语言：` + DefaultLanguage + `。
            注意：该配置项在此次config成功结束后才会生效，在执行config命令过
        程中语言显示不会受用户的选择影响。
        (3) endpoint, accessKeyID, accessKeySecret
            回车代表着跳过相应配置项的设置。注意：endpoint应该为一个二级域
        名(SLD)，例如：` + DefaultEndpoint + `。
            以上选项一般为必选项。
        (4) stsToken
            如果用户需要使用临时token来访问oss，用户需要填入该项，否则请输入
        回车跳过该项配置。
            关于stsToken的更多信息，请参考：https://help.aliyun.com/document_detail/31931.html?spm=5176.doc31867.6.632.hZFNSv
        (5) outputDir
            该选项配置输出文件所在目录的路径。交互式模式时不提供该选项的配置，
        但配置文件中该项配置起效。
            outputDir的默认目录为：当前目录下的：` + DefaultOutputDir + `，ossutil会在
        运行过程中将输出文件都生成到该文件夹下。输出文件目前包含：在cp命令中
        批量操作出错时，记录每个文件操作的错误信息的report文件。
            关于outputDir和report文件的更多信息请参见cp命令的帮助。
            注意：outputDir如果不存在，ossutil在产生输出文件时会自动创建该目录，
        如果outputDir存在且并非目录，将会报错。

        下述交互式Bucket-Endpoint和Bucket-Cname配置被取消，但配置文件中该两项
        配置仍然起效。
        (6) Bucket-Endpoint
            Bucket-Endpoint对每个指定的bucket单独配置endpoint，此配置会优先于
        配置文件中关于默认endpoint的配置。
            在该版本中，ossutil取消了交互式配置中，关于Bucket-Endpoint配对的配
        置，但配置文件中该项配置仍然起效，所以如果用户想对每个bucket单独指定
        endpoint，仍然可以在配置文件中进行配置。注意：此处的endpoint应该为一个
        二级域名(SLD)，例如：` + DefaultEndpoint + `。
            如果配置了Bucket-Endpoint选项，当对某bucket进行操作时，ossutil会在
        该选项中寻找该bucket对应的endpoint，如果找到，该endpoint会覆盖基本配置
        中endpoint。但是运行命令时如果指定了--endpoint选项，--endpoint选项为最
        高优先级。
        (7) Bucket-Cname
            Bucket-Cname为每个指定的bucket单独配置CNAME域名（CDN加速域名），此
        配置会优先于配置文件中Bucket-Endpoint及endpoint的配置。
            关于CNAME域名的更多信息见：https://help.aliyun.com/document_detail/27112.html?spm=5176.product27099.4.6.Lf06oS#1.
            在该版本中，ossutil取消了交互式配置中，关于Bucket-Cname配对的配置，
        但配置文件中该项配置仍然起效，所以如果用户想对每个bucket单独指定CNAME
        域名，仍然可以在配置文件中进行配置。
            如果配置了Bucket-Cname选项，当对某bucket进行操作时，ossutil会在该
        选项中寻找该bucket对应的CNAME域名，如果找到，则找到的CNAME域名会覆盖
        Bucket-Endpoint选项和基本配置中的endpoint。运行命令时如果指定了--endpoint
        选项，--endpoint选项为最高优先级。
        
        优先级：--endpoint &gt; Bucket-Cname &gt; Bucket-Endpoint &gt; endpoint &gt; 默认endpoint

    2) ossutil config options
        如果用户使用命令时输入了除--language和--config-file之外的任何选项，则
    该命令进入非交互式模式。所有的配置项应当使用选项指定。


配置文件格式：

    [Credentials]
        language = CH 
        endpoint = ` + DefaultEndpoint + `
        accessKeyID = your_key_id
        accessKeySecret = your_key_secret
        stsToken = your_sts_token
        outputDir = your_output_dir
    [Bucket-Endpoint]
        bucket1 = endpoint1
        bucket2 = endpoint2
        ...
    [Bucket-Cname]
        bucket1 = cname1
        bucket2 = cname2
        ...
`,

        sampleText: ` 
    ossutil config
    ossutil config -e oss-cn-hangzhou.aliyuncs.com -c ~/.myconfig
`,
}

var specEnglishConfig = SpecText{

        synopsisText: "Create configuration file to store credentials",

        paramText: "[options]",

        syntaxText: ` 
    ossutil config [-e endpoint] [-i id] [-k key] [-t token] [-L language] [--output-dir outdir] [-c file] 
`,

        detailHelpText: ` 
    The command create a configuration file and stores credentials
    information user specified. Credentials information is used when
    access OSS(if a command supports --config-file option, then the 
    information is useful to the command).

    The configuration file can be specified by user, which in default
    is ` + DecideConfigFile("") + `. If the configuration file exist, suppose
    the file is: a, ossutil will save a as a.bak, and rewrite file a, 
    at this time, if file a.bak exists, a.bak will be rewrited.

    Note:
    (1) If the configuration file path you specified is not the default 
    path, please specify --config-file option to the path when use other 
    commands. If you do not specify the --config-file option, ossutil 
    will read the configuration file: ` + DecideConfigFile("") + `.

    (2) Several configuration can be specified through option, eg: --endpoint, 
    --access-key-id etc(for more see the help of each command). If you 
    specified those options when use command, and meanwhile those configurations 
    exist in configurations file, PRI: option &gt; configurations file. 

    (3) If you specified --endpoint or --access-key-id or --access-key-secret 
    or --sts-token option when use command, then ossutil does not insist 
    on configurations file. 

Usage:

    There are two usages for the command, one is interactive(shows
    in 1) ), which is recommended because of safety problem. another is
    non interactive(shows in 2) ).

    1) ossutil config [-c file]
        The usage provides an interactive way to configure credentials.
    Interactively ossutil asks you for:
        (1) config file
            If user enter carriage return, ossutil use the default file: 
        ` + DecideConfigFile("") + `.
            If you specified the config file, please specify --config-file 
        option to the path when use other command that needs configuration. 
        To see the commands who support --config-file option please see the 
        help of each command.
        (2) language
            When configure for the first time(config file not exit), ossutil 
        will ask user to set the language(support Chinese or English at this 
        time), if user did not input the language, ossutil will set language 
        to the value of --language option, if user did not specify --language 
        option, ossutil will set it to Chinese.
            If config file exists, ossutil will set the language according to 
        --language option and configuration in config file, instead of asking 
        user for it.
            ossutil will read the language configuration when run command, if 
        the configuration does not exist or is invalid, ossutil will show in 
        default language: ` + DefaultLanguage + `.
            Notice that the configuration will go into effect after the config 
        command successfully executed, it's dimmed while execute the command.
        (3) endpoint, accessKeyID, accessKeySecret
            Carriage return means skip the configuration of these options.
        Note: Endpoint means a second-level domain(SLD), eg: ` + DefaultEndpoint + `.
            The three options are necessary in normal condition.
        (4) stsToken
            If you use stsToken to access oss, please enter your stsToken. If not, 
        please enter carriage return to skip the configuration.
            For more information about stsToken, see: https://help.aliyun.com/document_detail/31931.html?spm=5176.doc31867.6.632.hZFNSv
        (5) outputDir
            The section config the directory to place output file in. The section 
        can not be configed through interactive mode, but the section in config 
        file are still effective. 
            The default directory of outputDir is: ` + DefaultOutputDir + ` in current 
        directory. ossutil will place all output files generated during running 
        in this directory. Output files include: report file(generated when error 
        occurs in cp command while batch upload/downlaod/copy files). 
            More information about report file, see help of cp command.
            Note: if outputDir is not exist, ossutil will create the directory 
        automatically, if outputDir you specified exists and is not a directory, 
        ossutil will return an error. 

        In interactive config, Bucket-Endpoint and Bucket-Cname is removed, but 
        the two sections in config file are still effective. 
        (6) Bucket-Endpoint
            Bucket-Endpoint specify endpoint for every individual bucket, the 
        section is prior to endpoint in base section.  
            In current version, Bucket-Endpoint interactive configuration is 
        removed, but the option in config file is still effective. Note, the 
        endpoint should be a second-level domain(SLD), eg: ` + DefaultEndpoint + `. 
            When access a bucket, ossutil will search for endpoint corresponding 
        to the bucket in this section, if found, the endpoint is prior to the 
        endpoint in the base section. If --endpoint option is specified, --endpoint 
        option has the highest priority.
        (7) Bucket-Cname
            Bucket-Cname specify CNAME host for every individual bucket, the section 
        is prior to Bucket-Endpoint and endpoint in the base section.
            More information about CNAME host see: https://help.aliyun.com/document_detail/27112.html?spm=5176.product27099.4.6.Lf06oS#1. 
            In current version, Bucket-Cname interactive configuration is removed, 
        but the option in config file is still effective.
            When access a bucket, ossutil will search for endpoint corresponding 
        tothe bucket in this section, if found, the endpoint has priority over 
        the endpoint in Bucket-Endpoint and the endpoint in the base section. If 
        --endpoint option is specified, --endpoint option has the highest priority.

        PRI: --endpoint option &gt; Bucket-Cname &gt; Bucket-Endpoint &gt; endpoint &gt; default endpoint

    2) ossutil config options
        If any options except --language and --config-file is specified, the 
    command enter the non interactive mode. All the configurations should be 
    specified by options.


Credential File Format:

    [Credentials]
        language = EN 
        endpoint = ` + DefaultEndpoint + ` 
        accessKeyID = your_key_id
        accessKeySecret = your_key_secret
        stsToken = your_sts_token
        outputDir = your_output_dir
    [Bucket-Endpoint]
        bucket1 = endpoint1
        bucket2 = endpoint2
        ...
    [Bucket-Cname]
        bucket1 = cname1
        bucket2 = cname2
        ...
`,

        sampleText: ` 
    ossutil config
    ossutil config -e oss-cn-hangzhou.aliyuncs.com -c ~/.myconfig
`,
}

// ConfigCommand is the command config user's credentials information
type ConfigCommand struct {
        command Command
}

var configCommand = ConfigCommand{
        command: Command{
                name:        "config",
                nameAlias:   []string{"cfg", "config"},
                minArgc:     0,
                maxArgc:     0,
                specChinese: specChineseConfig,
                specEnglish: specEnglishConfig,
                group:       GroupTypeAdditionalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionOutputDir,
                        OptionLanguage,
                        OptionLogLevel,
                        OptionRamRoleArn,
                },
        },
}

// function for RewriteLoadConfiger interface
func (cc *ConfigCommand) rewriteLoadConfig(configFile string) error <span class="cov1" title="1">{
        // read config file, if error exist, do not print error
        var err error
        if cc.command.configOptions, err = LoadConfig(configFile); err != nil </span><span class="cov1" title="1">{
                cc.command.configOptions = OptionMapType{}
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// function for AssembleOptioner interface
func (cc *ConfigCommand) rewriteAssembleOptions() <span class="cov1" title="1">{
        // only assemble language option
        if val, _ := GetString(OptionLanguage, cc.command.options); val == "" </span><span class="cov1" title="1">{
                if val, ok := cc.command.configOptions[OptionLanguage]; ok </span><span class="cov0" title="0">{
                        opval := val.(string)
                        cc.command.options[OptionLanguage] = &amp;opval
                        delete(cc.command.configOptions, OptionLanguage)
                }</span>
        }

        <span class="cov1" title="1">if val, _ := GetString(OptionLanguage, cc.command.options); val == "" </span><span class="cov1" title="1">{
                def := OptionMap[OptionLanguage].def
                cc.command.options[OptionLanguage] = &amp;def
        }</span>
}

// function for FormatHelper interface
func (cc *ConfigCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return cc.command.formatHelpForWhole()
}</span>

func (cc *ConfigCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return cc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (cc *ConfigCommand) Init(args []string, options OptionMapType) error <span class="cov1" title="1">{
        return cc.command.Init(args, options, cc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (cc *ConfigCommand) RunCommand() error <span class="cov1" title="1">{
        configFile, _ := GetString(OptionConfigFile, cc.command.options)
        delete(cc.command.options, OptionConfigFile)
        language, _ := GetString(OptionLanguage, cc.command.options)
        delete(cc.command.options, OptionLanguage)

        // filter user input options
        cc.filterNonInputOptions()

        var err error
        if len(cc.command.options) == 0 </span><span class="cov0" title="0">{
                err = cc.runCommandInteractive(configFile, language)
        }</span> else<span class="cov1" title="1"> {
                err = cc.runCommandNonInteractive(configFile, language)
        }</span>
        <span class="cov1" title="1">return err</span>
}

func (cc *ConfigCommand) filterNonInputOptions() <span class="cov1" title="1">{
        for name := range cc.command.options </span><span class="cov9" title="5">{
                if val, err := GetString(name, cc.command.options); err != nil || val == "" </span><span class="cov1" title="1">{
                        delete(cc.command.options, name)
                }</span>
        }
}

func (cc *ConfigCommand) runCommandInteractive(configFile, language string) error <span class="cov0" title="0">{
        llanguage := strings.ToLower(language)
        if llanguage == LEnglishLanguage </span><span class="cov0" title="0">{
                fmt.Println("The command creates a configuration file and stores credentials.")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("该命令创建将一个配置文件，在其中存储配置信息。")
        }</span>

        <span class="cov0" title="0">if configFile == "" </span><span class="cov0" title="0">{
                if llanguage == LEnglishLanguage </span><span class="cov0" title="0">{
                        fmt.Printf("\nPlease enter the config file name,the file name can include path(default " + DecideConfigFile("") + ", carriage return will use the default file. If you specified this option to other file, you should specify --config-file option to the file when you use other commands):")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("\n请输入配置文件名,文件名可以带路径(默认为：" + DecideConfigFile("") + "，回车将使用默认配置文件。如果用户设置为其它文件，在使用命令时需要将--config-file选项设置为该文件）：")
                }</span>

                <span class="cov0" title="0">if _, err := fmt.Scanln(&amp;configFile); err != nil </span><span class="cov0" title="0">{
                        if llanguage == LEnglishLanguage </span><span class="cov0" title="0">{
                                fmt.Println("No config file entered, will use the default config file " + DecideConfigFile("") + "\n")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("未输入配置文件，将使用默认配置文件：" + DecideConfigFile("") + "。\n")
                        }</span>
                }
        }

        <span class="cov0" title="0">configFile = DecideConfigFile(configFile)
        if llanguage == LEnglishLanguage </span><span class="cov0" title="0">{
                fmt.Println("For the following settings, carriage return means skip the configuration. Please try \"help config\" to see the meaning of the settings")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("对于下述配置，回车将跳过相关配置项的设置，配置项的具体含义，请使用\"help config\"命令查看。")
        }</span>

        <span class="cov0" title="0">if err := cc.configInteractive(configFile, language); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cc *ConfigCommand) configInteractive(configFile, language string) error <span class="cov0" title="0">{
        var val string
        config := configparser.NewConfiguration()
        section := config.NewSection(CREDSection)

        // if config file not exist, config Language
        llanguage := strings.ToLower(language)
        section.Add(OptionLanguage, language)
        if _, err := os.Stat(configFile); err != nil </span><span class="cov0" title="0">{
                if llanguage == LEnglishLanguage </span><span class="cov0" title="0">{
                        fmt.Printf("Please enter language(%s, default is:%s, the configuration will go into effect after the command successfully executed):", OptionMap[OptionLanguage].minVal, DefaultLanguage)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("请输入语言(%s，默认为：%s，该配置项将在此次config命令成功结束后生效)：", OptionMap[OptionLanguage].minVal, DefaultLanguage)
                }</span>
                <span class="cov0" title="0">if _, err := fmt.Scanln(&amp;val); err == nil </span><span class="cov0" title="0">{
                        vals := strings.Split(OptionMap[OptionLanguage].minVal, "/")
                        if FindPosCaseInsen(val, vals) == -1 </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid option value of %s, the value: %s is not anyone of %s", OptionLanguage, val, OptionMap[OptionLanguage].minVal)
                        }</span>
                        <span class="cov0" title="0">section.Add(OptionLanguage, val)</span>
                }
        }

        <span class="cov0" title="0">for name, option := range CredOptionMap </span><span class="cov0" title="0">{
                if !option.cfInteractive </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">str := ""
                if llanguage == LEnglishLanguage </span><span class="cov0" title="0">{
                        if OptionMap[name].def != "" </span><span class="cov0" title="0">{
                                str = fmt.Sprintf("(%sdefault is:%s, carriage return will use the default value)", option.helpEnglish, OptionMap[name].def)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("Please enter %s%s:", name, str)</span>
                } else<span class="cov0" title="0"> {
                        if OptionMap[name].def != "" </span><span class="cov0" title="0">{
                                str = fmt.Sprintf("（%s默认为：%s，回车将使用默认值）", option.helpChinese, OptionMap[name].def)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("请输入%s%s：", name, str)</span>
                }

                // fmt.Scanln have 256 length limit on windows platform,so use Reader
                <span class="cov0" title="0">val = ""
                valueReader := bufio.NewReader(os.Stdin)
                val, _ = valueReader.ReadString('\n') // Need to pass '\n' as char (byte)
                if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                        val = strings.TrimSuffix(val, "\r\n")
                }</span> else<span class="cov0" title="0"> {
                        val = strings.TrimSuffix(val, "\n")
                }</span>

                <span class="cov0" title="0">if len(val) &gt; 0 </span><span class="cov0" title="0">{
                        section.Add(name, val)
                }</span> else<span class="cov0" title="0"> if OptionMap[name].def != "" </span><span class="cov0" title="0">{
                        section.Add(name, OptionMap[name].def)
                }</span>
        }

        <span class="cov0" title="0">if err := configparser.Save(config, configFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cc *ConfigCommand) runCommandNonInteractive(configFile, language string) error <span class="cov1" title="1">{
        configFile = DecideConfigFile(configFile)
        config := configparser.NewConfiguration()
        section := config.NewSection(CREDSection)
        section.Add(OptionLanguage, language)
        for name := range CredOptionMap </span><span class="cov10" title="6">{
                if val, _ := GetString(name, cc.command.options); val != "" </span><span class="cov6" title="3">{
                        section.Add(name, val)
                }</span>
        }
        <span class="cov1" title="1">if err := configparser.Save(config, configFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package lib

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        configparser "github.com/alyu/configparser"
)

// sections in config file
const (
        CREDSection string = "Credentials"

        BucketEndpointSection string = "Bucket-Endpoint"

        BucketCnameSection string = "Bucket-Cname"

        AkServiceSection string = "AkService"
)

// config items in section AKSerivce
const (
        ItemEcsAk string = "ecsAk"
)

// config items in section Credentials
const (
        ItemRamRoleArn string = "ramRoleArn"
)

type configOption struct {
        showNames     []string
        cfInteractive bool
        reveal        bool
        helpChinese   string
        helpEnglish   string
}

// CredOptionList is all options in Credentials section
var CredOptionList = []string{
        OptionLanguage,
        OptionEndpoint,
        OptionAccessKeyID,
        OptionAccessKeySecret,
        OptionSTSToken,
        OptionOutputDir,
        OptionRamRoleArn,
}

// CredOptionMap allows alias name for options in Credentials section
// name, allow to show in screen
var CredOptionMap = map[string]configOption{
        OptionLanguage:        configOption{[]string{"language", "Language"}, false, true, "", ""},
        OptionEndpoint:        configOption{[]string{"endpoint", "host"}, true, true, "", ""},
        OptionAccessKeyID:     configOption{[]string{"accessKeyID", "accessKeyId", "AccessKeyID", "AccessKeyId", "access_key_id", "access_id", "accessid", "access-key-id", "access-id"}, true, false, "", ""},
        OptionAccessKeySecret: configOption{[]string{"accessKeySecret", "AccessKeySecret", "access_key_secret", "access_key", "accesskey", "access-key-secret", "access-key"}, true, false, "", ""},
        OptionSTSToken:        configOption{[]string{"stsToken", "ststoken", "STSToken", "sts_token", "sts-token"}, true, false, "", ""},
        OptionOutputDir:       configOption{[]string{"outputDir", "output-dir", "output_dir", "output_directory"}, false, true, "ossutil生成的文件的输出目录, ", "the directory to store files generated by ossutil, "},
        //OptionRamRoleArn:      configOption{[]string{"ramRoleArn", "RamRoleArn", "RamRolearn", "ram-role-arn", "ram_role_arn", "role_arn", "rolearn", "arn"}, false, true, "", ""},
}

// DecideConfigFile return the config file, if user not specified, return default one
func DecideConfigFile(configFile string) string <span class="cov5" title="75">{
        if configFile == "" </span><span class="cov3" title="6">{
                configFile = DefaultConfigFile
        }</span>

        <span class="cov5" title="75">if len(configFile) &gt;= 2 &amp;&amp; strings.HasPrefix(configFile, "~"+string(os.PathSeparator)) </span><span class="cov3" title="6">{
                homeDir := currentHomeDir()
                if homeDir != "" </span><span class="cov3" title="6">{
                        configFile = strings.Replace(configFile, "~", homeDir, 1)
                }</span>
        }
        <span class="cov5" title="75">return configFile</span>
}

// LoadConfig load the specified config file
func LoadConfig(configFile string) (OptionMapType, error) <span class="cov5" title="68">{
        var configMap OptionMapType
        var err error
        configMap, err = readConfigFromFile(configFile)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Read config file error: %s, please try \"help config\" to set configuration or use \"--config-file\" option", err)
        }</span>
        <span class="cov5" title="67">if err = checkConfig(configMap); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="67">return configMap, nil</span>
}

func readConfigFromFile(configFile string) (OptionMapType, error) <span class="cov5" title="68">{
        configFile = DecideConfigFile(configFile)

        config, err := configparser.Read(configFile)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="67">configMap := OptionMapType{}

        // get options in cred section
        credSection, err := config.Section(CREDSection)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="67">credOptions := credSection.Options()

        configMap[CREDSection] = map[string]string{}

        for name, option := range credOptions </span><span class="cov7" title="261">{
                if opName, ok := getOptionNameByStr(strings.TrimSpace(name)); ok </span><span class="cov7" title="258">{
                        configMap[strings.TrimSpace(opName)] = strings.TrimSpace(option)
                }</span>
                <span class="cov7" title="261">if name == ItemRamRoleArn </span><span class="cov2" title="3">{
                        (configMap[CREDSection]).(map[string]string)[strings.TrimSpace(name)] = strings.TrimSpace(option)
                }</span>
        }

        // get options in pair sections
        <span class="cov5" title="67">for _, sec := range []string{BucketEndpointSection, BucketCnameSection} </span><span class="cov6" title="134">{
                if section, err := config.Section(sec); err == nil </span><span class="cov0" title="0">{
                        configMap[sec] = map[string]string{}
                        options := section.Options()
                        for bucket, host := range options </span><span class="cov0" title="0">{
                                (configMap[sec]).(map[string]string)[strings.TrimSpace(bucket)] = strings.TrimSpace(host)
                        }</span>
                }
        }

        // get options in AKService for user-defined GetAk
        <span class="cov5" title="67">sec := AkServiceSection
        if section, err := config.Section(sec); err == nil </span><span class="cov2" title="4">{
                configMap[sec] = map[string]string{}
                options := section.Options()
                for ecsUrl, strUrl := range options </span><span class="cov2" title="4">{
                        (configMap[sec]).(map[string]string)[strings.TrimSpace(ecsUrl)] = strings.TrimSpace(strUrl)
                }</span>
        }

        <span class="cov5" title="67">return configMap, nil</span>
}

func getOptionNameByStr(name string) (string, bool) <span class="cov7" title="261">{
        for optionName, option := range CredOptionMap </span><span class="cov8" title="846">{
                for _, val := range option.showNames </span><span class="cov10" title="2744">{
                        if strings.EqualFold(name, val) </span><span class="cov7" title="258">{
                                return optionName, true
                        }</span>
                }
        }
        <span class="cov2" title="3">return "", false</span>
}

func checkConfig(configMap OptionMapType) error <span class="cov5" title="67">{
        for name, opval := range configMap </span><span class="cov7" title="329">{
                if option, ok := OptionMap[name]; ok </span><span class="cov7" title="258">{
                        if option.optionType == OptionTypeInt64 </span><span class="cov0" title="0">{
                                if _, err := strconv.ParseInt(opval.(string), 10, 64); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error value of option \"%s\", the value is: %s in config file, which needs int64 type", name, opval)
                                }</span>
                        }
                        <span class="cov7" title="258">if option.optionType == OptionTypeAlternative </span><span class="cov5" title="67">{
                                vals := strings.Split(option.minVal, "/")
                                if FindPosCaseInsen(opval.(string), vals) == -1 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error value of option \"%s\", the value is: %s in config file, which is not anyone of %s", name, opval, option.minVal)
                                }</span>
                        }
                }
        }
        <span class="cov5" title="67">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package lib

import (
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseOptions = SpecText{
        synopsisText: "向oss发送http options请求,用于CORS检测",

        paramText: "oss_url [options]",

        syntaxText: ` 
    ossutil cors-options --acr-method &lt;value&gt; --origin &lt;value&gt; --acr-headers &lt;value&gt; oss://bucket/[object] [options]
`,
        detailHelpText: ` 
    cors-options命令向oss发送http options请求
    --acr-method、--origin、--acr-headers分别对应http header:Access-Control-Request-Method、Origin、Access-Control-Request-Headers
    --acr-headers如果有多个取值,各个header用逗号分隔,再加上双引号,比如  --acr-headers "header1,header2,header3"

用法:
    该命令有一种用法:
        
    1) ossutil cors-options --acr-method PUT --origin "www.aliyuncs.com" --acr-header x-oss-meta-author oss://bucket/ [options]
       向oss发送options请求,Origin、Access-Control-Request-Method、Access-Control-Request-Headers分别为www.aliyuncs.com、PUT、x-oss-meta-author
`,
        sampleText: ` 
    1) 发送options请求,Access-Control-Request-Method为PUT
       ossutil cors-options --acr-method PUT --origin "www.aliyuncs.com" --acr-header x-oss-meta-author oss://bucket/
    
    2) 发送options请求,有多个header参数,Access-Control-Request-Method为GET
       ossutil cors-options --acr-method GET --origin "www.aliyuncs.com" --acr-header "x-oss-meta-author1,x-oss-meta-author2" oss://bucket/
`,
}

var specEnglishOptions = SpecText{
        synopsisText: "Send http options request to oss for CORS detection",

        paramText: "oss_url [options]",

        syntaxText: ` 
    ossutil cors-options --acr-method &lt;value&gt; --origin &lt;value&gt; --acr-headers &lt;value&gt; oss://bucket/[object] [options]
`,
        detailHelpText: ` 
    The cors-options command sends an http options request to oss
    --acr-method, --origin, --acr-headers correspond to http header:Access-Control-Request-Method, Origin, Access-Control-Request-Headers
    If --acr-headers have multiple values, each header is separated by a comma, followed by double quotes, for example: --acr-headers "header1,header2,header3"

Usage:
    There are one usage for this command:
        
    1) ossutil cors-options --acr-method PUT --origin "www.aliyuncs.com" --acr-header x-oss-meta-author oss://bucket/ [options]
       sends an http options request to oss,Origin、Access-Control-Request-Method、Access-Control-Request-Headers values are www.aliyuncs.com、PUT、x-oss-meta-author
`,
        sampleText: ` 
    1) sends an http options request,Access-Control-Request-Method value is PUT
    ossutil cors-options --acr-method PUT --origin "www.aliyuncs.com" --acr-header x-oss-meta-author oss://bucket/
 
    2) sends an http options request,there are multipule values for --acr-header,Access-Control-Request-Method value is GET
    ossutil cors-options --acr-method GET --origin "www.aliyuncs.com" --acr-header "x-oss-meta-author1,x-oss-meta-author2" oss://bucket/
`,
}

type OptionsCommand struct {
        command Command
}

var corsOptionsCommand = OptionsCommand{
        command: Command{
                name:        "cors-options",
                nameAlias:   []string{"cors-options"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseOptions,
                specEnglish: specEnglishOptions,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionEncodingType,
                        OptionOrigin,
                        OptionAcrMethod,
                        OptionAcrHeaders,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (opsc *OptionsCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return opsc.command.formatHelpForWhole()
}</span>

func (opsc *OptionsCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return opsc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (opsc *OptionsCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return opsc.command.Init(args, options, opsc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (opsc *OptionsCommand) RunCommand() error <span class="cov0" title="0">{
        strOrigin, _ := GetString(OptionOrigin, opsc.command.options)
        strMethod, _ := GetString(OptionAcrMethod, opsc.command.options)
        strAcrHeaders, _ := GetString(OptionAcrHeaders, opsc.command.options)

        strEncodingType, _ := GetString(OptionEncodingType, opsc.command.options)
        srcBucketUrL, err := GetCloudUrl(opsc.command.args[0], strEncodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">options := []oss.Option{}

        if len(strOrigin) &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, oss.Origin(strOrigin))
        }</span>
        <span class="cov0" title="0">if len(strMethod) &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, oss.ACReqMethod(strings.ToUpper(strMethod)))
        }</span>
        <span class="cov0" title="0">if len(strAcrHeaders) &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, oss.ACReqHeaders(strAcrHeaders))
        }</span>

        <span class="cov0" title="0">objectName := srcBucketUrL.object

        client, err := opsc.command.ossClient(srcBucketUrL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := client.Bucket(srcBucketUrL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">respHeader, err := bucket.OptionsMethod(objectName, options...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">exclude := map[string]bool{}
        exclude["Connection"] = true
        exclude["ontent-Length"] = true
        exclude["Date"] = true
        exclude["Server"] = true
        exclude["X-Oss-Request-Id"] = true
        exclude["X-Oss-Server-Time"] = true
        exclude["Content-Length"] = true

        respHeader.WriteSubset(os.Stdout, exclude)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package lib

import (
        "fmt"
        "hash/fnv"
        "io/ioutil"
        "math"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
        leveldb "github.com/syndtr/goleveldb/leveldb"
)

type operationType int

const (
        operationTypePut operationType = iota
        operationTypeGet
        operationTypeCopy
)

const (
        opUpload   string = "upload"
        opDownload        = "download"
        opCopy            = "copy"
)

/*
 * Put same type variables together to make them 64bits alignment to avoid
 * atomic.AddInt64() panic
 * Please guarantee the alignment if you add new filed
 */
type copyOptionType struct {
        cpDir             string
        snapshotPath      string
        vrange            string
        encodingType      string
        meta              string
        options           []oss.Option
        filters           []filterOptionType
        threshold         int64
        routines          int64
        reporter          *Reporter
        snapshotldb       *leveldb.DB
        recursive         bool
        force             bool
        update            bool
        ctnu              bool
        payerOptions      []oss.Option
        partitionInfo     string
        partitionIndex    int
        partitionCount    int
        versionId         string
        enableSymlinkDir  bool
        onlyCurrentDir    bool
        disableDirObject  bool
        disableAllSymlink bool
        tagging           string
        bSyncCommand      bool
}

type filterOptionType struct {
        name    string
        pattern string
}

type fileInfoType struct {
        filePath string
        dir      string
}

type objectInfoType struct {
        prefix       string
        relativeKey  string
        size         int64
        lastModified time.Time
}

var (
        mu               sync.RWMutex // mu is the mutex for interacting with user
        snapmu           sync.RWMutex
        chProgressSignal chan chProgressSignalType
        signalNum        = 0
)

type chProgressSignalType struct {
        finish   bool
        exitStat int
}

func freshProgress() <span class="cov10" title="100">{
        if len(chProgressSignal) &lt;= signalNum </span><span class="cov4" title="5">{
                chProgressSignal &lt;- chProgressSignalType{false, normalExit}
        }</span>
}

// OssProgressListener progress listener
type OssProgressListener struct {
        monitor     *CPMonitor
        lastSize    int64
        currSize    int64
        failedEvent bool
}

// ProgressChanged handle progress event
func (l *OssProgressListener) ProgressChanged(event *oss.ProgressEvent) <span class="cov0" title="0">{
        if event.EventType == oss.TransferDataEvent </span><span class="cov0" title="0">{
                l.monitor.updateTransferSize(event.RwBytes)
                l.monitor.updateDealSize(event.RwBytes)
                l.failedEvent = false
        }</span> else<span class="cov0" title="0"> if !l.failedEvent &amp;&amp; event.EventType == oss.TransferFailedEvent </span><span class="cov0" title="0">{
                l.monitor.updateDealSize(-event.ConsumedBytes)
                l.failedEvent = true
        }</span>
        <span class="cov0" title="0">freshProgress()</span>
}

// OssProgressListener resume progress listener
type OssResumeProgressListener struct {
        monitor        *CPMonitor
        lastSize       int64
        currSize       int64
        failedEvent    bool
        breakSizeAdded bool
}

// ProgressChanged handle resume progress event
func (l *OssResumeProgressListener) ProgressChanged(event *oss.ProgressEvent) <span class="cov9" title="60">{
        if event.EventType == oss.TransferStartedEvent &amp;&amp; !l.breakSizeAdded </span><span class="cov6" title="20">{
                l.monitor.updateDealSize(event.ConsumedBytes)
                l.breakSizeAdded = true
        }</span> else<span class="cov8" title="40"> if event.EventType == oss.TransferDataEvent </span><span class="cov6" title="20">{
                l.monitor.updateTransferSize(event.RwBytes)
                l.monitor.updateDealSize(event.RwBytes)
        }</span>
        <span class="cov9" title="60">freshProgress()</span>
}

var specChineseCopy = SpecText{

        synopsisText: "上传，下载或拷贝Objects",

        paramText: "src_url dest_url [options]",

        syntaxText: ` 
    ossutil cp file_url cloud_url  [-r] [-f] [-u] [--enable-symlink-dir] [--disable-all-symlink] [--disable-ignore-error] [--only-current-dir] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--snapshot-path=sdir] [--payer requester]
    ossutil cp cloud_url file_url  [-r] [-f] [-u] [--only-current-dir] [--disable-ignore-error] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--range=x-y] [--payer requester] [--version-id versionId]
    ossutil cp cloud_url cloud_url [-r] [-f] [-u] [--only-current-dir] [--disable-ignore-error] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--payer requester] [--version-id versionId]
`,

        detailHelpText: ` 
    该命令允许：从本地文件系统上传文件到oss，从oss下载object到本地文件系统，在oss
    上进行object拷贝。分别对应下述三种操作：
        ossutil cp file_url oss://bucket[/prefix] [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--snapshot-path=sdir] [--payer requester]
        ossutil cp oss://bucket[/prefix] file_url [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--range=x-y] [--payer requester]
        ossutil cp oss://src_bucket[/src_prefix] oss://dest_bucket[/dest_prefix] [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--payer requester]

    其中file_url代表本地文件系统中的文件路径，支持相对路径或绝对路径，请遵循本地文
    件系统的使用格式；
    oss://bucket[/prefix]代表oss上的object，支持前缀匹配，不支持通配符。
    ossutil通过oss://前缀区分本地文件系统的文件和oss文件。

    注意：在oss间拷贝文件，目前只支持拷贝object，不支持拷贝未complete的Multipart。


--recursive选项

    （1）上传文件到oss时，如果file_url为目录，则必须指定--recursive选项，否则无需指
        定--recursive选项。

    （2）从oss下载或在oss间拷贝文件时：
        如果未指定--recursive选项，则认为拷贝单个object，此时请确保src_url精确指定待
        拷贝的object，如果object不存在，则报错。

        如果指定了--recursive选项，ossutil会对src_url进行prefix匹配查找，对这些objects
        批量拷贝，如果拷贝失败，已经执行的拷贝不会回退。

    在进行批量文件上传（或下载、拷贝）时，如果其中某个文件操作失败，ossutil不会退出，
    而是继续进行其他文件的上传（或下载、拷贝）动作，并将出错文件的错误信息记录到report
    文件中。成功上传（或下载、拷贝）的文件信息将不会被记录到report文件中。

    注意：批量操作出错时不继续运行，而是终止运行的情况：
    （1）如果未进入批量文件迭代过程，错误已经发生，则不会产生report文件，ossutil会终止
    运行，不继续迭代过程。如，用户输入cp命令出错时，不会产生report文件，而是屏幕输出错
    误并退出。
    （2）如果批量操作过程某文件发生的错误为：Bucket不存在、accessKeyID/accessKeySecret
    错误造成的权限验证非法等错误，ossutil会屏幕输出错误并退出。

    report文件名为：` + ReportPrefix + `日期_时间` + ReportSuffix + `。report文件是ossutil输出文件的一种，
    被放置在ossutil的输出目录下，该目录的路径可以用配置文件中的outputDir选项或命令行
    --output-dir选项指定，如果未指定，会使用默认的输出目录：当前目录下的` + DefaultOutputDir + `目录。

    注意：ossutil不做report文件的维护工作，请自行查看及清理用户的report文件，避免产生
    过多的report文件。

--include和--exclude选项

    当指定--recursive选项时，可以指定该选项以指定规则筛选要操作的文件/object。默认情况下，
    指定目录中所有项都包含在cp操作中。

    规则支持以下格式：
    *：匹配索引
    ?：匹配单个字符
    [sequence]：匹配sequence的任意字符
    [!sequence]：匹配不在sequence的任意字符
    注意：规则不支持带目录的格式，e.g.，--include "/usr/*/test/*.jpg"。

    --include和--exclude可以出现多次。当多个规则出现时，这些规则按从左往右的顺序应用。例如：
    当前目录下包含3个文件：
    testfile1.jpg
    testfiel2.txt
    testfile33.jpg

    $ ossutil cp . oss://my-bucket/path --exclude '*.jpg'
    上传testfile2.txt到oss://my-bucket/path/testfile2.txt

    $ ossutil cp . oss://my-bucket/path --exclude '*.jpg' --include 'testfile*.jpg'
    上传testfile1.jpg到oss://my-bucket/path/testfile1.jpg
    上传testfile33.jpg到oss://my-bucket/path/testfile33.jpg
    上传testfile2.txt到oss://my-bucket/path/testfile2.txt

    $ ossutil cp . oss://my-bucket/path --exclude '*.jpg' --include 'testfile*.jpg' --exclude 'testfile?.jpg'
    上传testfile2.txt到oss://my-bucket/path/testfile2.txt
    上传testfile33.jpg到oss://my-bucket/path/testfile33.jpg

--meta选项

    该选项在上传文件的同时设置object的meta信息。当指定--recursive选项时，会设置所有上传的
    objects的meta信息。
        
    可选的header列表如下：
        ` + formatHeaderString(headerOptionMap, "\n        ") + `
        以及以` + oss.HTTPHeaderOssMetaPrefix + `开头的header
            
    注意：header不区分大小写，但value区分大小写。设置后将用指定的meta代替原来的meta。没有指定的
    HTTP HEADER将保留，没有指定的user meta将会被删除。

--tagging选项
    该选项在上传文件的同时设置object的tagging信息。当指定--recursive选项时，会设置所有上传的
    objects的tagging信息。
    如果一次设置多个tagging,必须使用双引号,比如 "tagA=A&amp;tagB=B"
    
--acl选项

    该选项在上传文件的同时设置object的acl信息。当指定--recursive选项时，会设置所有上传的
    objects的acl信息。

    object的acl有四种：
        ` + formatACLString(objectACL, "\n        ") + `

    acl的详细信息请参见：https://help.aliyun.com/document_detail/31867.html

--output-dir选项
    
    该选项指定ossutil输出文件存放的目录，默认为：当前目录下的` + DefaultOutputDir + `目录。如果指定
    的目录不存在，ossutil会自动创建该目录，如果用户指定的路径已存在并且不是目录，会报错。
    输出文件表示ossutil在运行过程中产生的输出文件，目前包含：在cp命令中ossutil运行出错时
    产生的report文件，在批量set-acl、set-meta、restore出错时产生的report文件。


增量上传/下载/拷贝：

--update选项（-u）
    
    如果指定了该选项，ossutil只有当目标文件（或object）不存在，或源文件（或object）新于
    目标文件（或object）时，才执行上传、下载、拷贝。当指定了该选项时，无论--force选项是
    否指定了，在目标文件存在时，ossutil都不会提示，直接采取上述策略。
    该选项可用于当批量拷贝失败时，重传时跳过已经成功的文件。实现增量上传。

--snapshot-path选项

    该选项用于在某些场景下加速增量上传批量文件（目前，下载和拷贝不支持该选项）。此场景为：
    文件数较多且两次上传期间没有其他用户更改了oss上的对应object。

    在cp上传文件时使用该选项，ossutil在指定的目录下生成文件记录文件上传的快照信息，在下一
    次指定该选项上传时，ossutil会读取指定路径下的快照信息进行增量上传。用户指定的snapshot-path
    必须为本地文件系统上的可写目录，若该路径目录不存在，ossutil会创建该文件用于记录快照信息，
    如果该路径文件已存在，ossutil会读取里面的快照信息，根据快照信息进行增量上传（只上传上次
    未成功上传的文件和本地进行过修改的文件），并更新快照信息。

    注意：
    （1）因为该命令通过在本地记录成功上传的文件的本地lastModifiedTime，从而在下次上传时通过
    比较lastModifiedTime来决定是否跳过相同文件的上传，所以在使用该选项时，请确保两次上传期
    间没有其他用户更改了oss上的对应object。当不满足该场景时，如果想要增量上传批量文件，请使
    用--update选项。
    （2）ossutil不会主动删除snapshot-path下的快照信息，为了避免快照信息过多，当用户确定快照信
    息无用时，请用户自行清理snapshot-path。
    （3）由于读写snapshot信息需要额外开销，当要批量上传的文件数比较少或网络状况比较好或有其
    他用户操作相同object时，并不建议使用该选项。可以使用--update选项来增量上传。

注意：--update选项和--snapshot-path选项可以同时使用，ossutil会优先根据snapshot-path信息判断
    是否跳过上传，如果不满足跳过条件，再根据--update判断是否跳过上传。如果指定了这两种增量上
    传策略之中的任何一种，ossutil将根据策略判断是否进行上传/下载/拷贝，当遇到目标端的文件已
    存在，也不会询问用户是否进行替换操作，此时--force选项不再生效。

    另外，增量下载策略不会考虑--range选项的值，即增量下载策略只参考文件是否存在和lastModifiedTime
    信息来决定，即如果满足跳过下载的条件，就算两次下载指定的range不一样，也同样会跳过文件。
    所以请避免两者共同使用！
    

其他选项：

--force选项

    如果dest_url指定的文件或objects在oss上已经存在，并且未指定--update或--snapshot-path选项，
    ossutil会询问是否进行替换操作（输入非法时默认不替换），如果指定了--force选项，则不询问，
    强制替换。该选项只有在未指定--update或--snapshot-path选项时有效，否则按指定的选项操作。

--range选项

    如果下载文件时只需要下载文件内容的部分，可以通过--range选项来指定下载的文件内容范围，如
    果指定了该选项，则大文件的多线程下载和断点续传默认无效。

    文件偏移从0开始，有三种形式：0-9或3-或-9。
    比如指定--range=0-9，表示下载指定文件的第0到第9这10个字符；
    指定--range=3-，表示下载指定文件第3字符到文件结尾的内容；
    指定--range=-9，表示下载指定文件结尾的9个字符。
    如果指定的范围超过文件长度范围，会下载整个文件。
    关于range的更多信息见：https://help.aliyun.com/document_detail/31980.html?spm=5176.doc31994.6.860.YH7LL1
    
    如果想下载整个文件请不要指定这个选项。
    目前上传和拷贝文件，不支持--range选项。

    注意：指定了增量下载策略时（-u选项），策略决定是否跳过下载不会考虑range范围是否变化，即
    使前后几次下载range范围不一样，满足增量下载条件时，ossutil同样会跳过下载，所以请避免两者
    同时使用！

--encoding-type选项

    如果指定该选项为url，则表示输入的object名和文件名都是经过url编码的。

--enable-symlink-dir选项

    允许传输链接子目录下文件,如果存在死循环链接文件或者目录,会导致错误,使用前建议用probe命令
    检测是否存在死循环链接文件或者目录

--disable-all-symlink选项

    上传目录时,忽略掉该目录下所有的链接文件以及链接子目录

--only-current-dir
    
    和-r选项一起使用,表示只操作当前目录下的文件, 会忽略当前目录下的子目录, 如果是下载或者拷贝oss
    的目录，目录后面要加上反斜线/


大文件断点续传：

    如果源文件大小超过--bigfile-threshold选项指定的大小（默认为100M），ossutil会认为该文件
    为大文件，并自动使用断点续传策略，策略如下：
    （1）上传到oss时：ossutil会对大文件自动分片，进行multipart分片上传，如果上传失败，会
        在本地的.ossutil_checkpoint目录记录失败信息，下次重传时会读取.ossutil_checkpoint目
        录中的信息进行断点续传，当上传成功时会删除.ossutil_checkpoint目录。
    （2）从oss下载时：ossutil会自动对大文件分片下载，组装成一个文件，如果下载失败，同样会
        在.ossutil_checkpoint目录记录失败信息，重试成功后会删除.ossutil_checkpoint目录。
    （3）在oss间拷贝：ossutil会自动对大文件分片，使用Upload Part Copy方式拷贝，同样会在
        .ossutil_checkpoint目录记录失败信息，重试成功后会删除.ossutil_checkpoint目录。

    注意：
    1）小文件不会采用断点续传策略，失败后下次直接重传。
    2）在操作（1）和（3）中，如果操作失败，oss上可能会产生未complete的uploadId，但是只要最
    终操作成功，就不会存在未complete的uploadId（被组装成object）。
    3）上传到oss时，如果.ossutil_checkpoint目录包含在file_url中，.ossutil_checkpoint目录不会
    被上传到oss。该目录路径可以用--checkpoint-dir选项指定，如果指定了该选项，请确保指定的目录
    可以被删除。
    4）如果使用rm命令删除了未complete的Multipart Upload，可能会造成下次cp命令断点续传失败（报
    错：NoSuchUpload），这种时候如果想要重新上传整个文件，请删除相应的checkpoint文件。


性能调优：

--jobs选项和--parallel选项（并发控制）

    --jobs选项控制多个文件上传/下载/拷贝时，文件间启动的并发数，--parallel控制上传/下载/拷
    贝大文件时，分片间的并发数。默认情况下，ossutil会根据文件大小来计算parallel个数（该选项
    对于小文件不起作用，进行分片上传/下载/拷贝的大文件文件阈值可由--bigfile-threshold选项来
    控制），当进行批量大文件的上传/下载/拷贝时，实际的并发数为jobs个数乘以parallel个数。该
    两个选项可由用户调整，当ossutil自行设置的默认并发达不到用户的性能需求时，用户可以自行调
    整该两个选项来升降性能。

    注意：
    1）如果并发数调得太大，由于线程间资源切换及抢夺等，ossutil上传/下载/拷贝性能可能会下降，
    所以请根据实际的机器情况调整这两个选项的数值，如果要进行压测，可以一开始将两个数值调低，
    慢慢调大寻找最优值。
    2）如果--jobs选项和--parallel选项值太大，在机器资源有限的情况下，可能会因为网络传输太慢，
    产生EOF错误，这个时候请适当降低--jobs选项和--parallel选项值。

--part-size选项
    
    该选项设置大文件分片上传/下载/拷贝时，每个分片的大小。默认情况下，不需要设置该值，ossutil
    会根据文件大小自行决定分片大小和分片并发，当用户上传/下载/拷贝性能达不到需求时，或有其他
    特殊需求时，可以设置这些选项。
    
    如果设置了该选项（分片大小），分片个数为：向上取整（文件大小/分片大小），注意如果--parallel
    选项值大于分片个数，则多余的parallel不起作用，实际的并发数为分片个数。

    如果将part size值设置得过小，可能会影响ossutil文件上传/下载/拷贝的性能，设置得过大，会影
    响实际起作用的分片并发数，所以请合理设置part size选项值。


批量文件迁移：

    ossutil支持批量文件迁移，在这种场景下，通常的使用方式是：
    （1）批量上传：
        ossutil cp your_dir oss://your_bucket -r -f -u
        ossutil cp your_dir oss://your_bucket -r -f -u --include "*.jpg"
        ossutil cp your_dir oss://your_bucket -r -f -u --exclude "*.html"
    （2）批量下载：
        ossutil cp oss://your_bucket your_dir -r -f -u
        ossutil cp oss://your_bucket your_dir -r -f -u --include "*.jpg"
    （3）同region的Bucket间迁移：
        ossutil cp oss://your_src_bucket oss://your_dest_bucket -r -f -u

    具体每个选项的意义，请见上文帮助。
    在运行完一轮文件迁移后，请根据屏幕提示查看report文件，处理出错文件。

    在批量上传时，如果文件数比较多且没有其他用户操作相同object时，可以使用--snapshot-path选项
    进行额外的增量上传加速，更多信息参考上文关于--snapshot-path选项的介绍。命令为：
        ossutil cp your_dir oss://your_bucket -r -f -u --shapshot-path=your-path


用法：

    该命令有三种用法：

    1) ossutil cp file_url oss://bucket[/prefix] [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--snapshot-path=sdir]
        该用法上传本地文件系统中文件或目录到oss。file_url可以为文件或目录。当file_url为文件
    时，无论是否指定--recursive选项都不会影响结果。当file_url为目录时，即使目录为空或者只含
    有一个文件，也必须使用--recursive选项，注意，此时ossutil会将file_url下的文件或子目录上传
    到oss，但不同于shell拷贝，file_url所代表的首层目录不会被创建。
    object命名规则：
        当file_url为文件时，如果prefix为空或以/结尾，object名为：dest_url+文件名。
                            否则，object名为：dest_url。
        当file_url为目录时，如果prefix为空或以/结尾，object名为：dest_url+文件或子目录相对
                            file_url的路径。
                            否则，object名为：dest_url+/+文件或子目录相对file_url的路径。

    2) ossutil cp oss://bucket[/prefix] file_url [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--range=x-y]
        该用法下载oss上的单个或多个Object到本地文件系统。如果未指定--recursive选项，则ossutil
    认为src_url精确指定了待拷贝的单个object，此时不支持prefix匹配，如果object不存在则报错。如
    果指定了--recursive选项，ossutil会搜索prefix匹配的objects，批量拷贝这些objects，此时file_url
    必须为目录，如果该目录不存在，ossutil自动创建该目录。
    文件命名规则：
        当file_url为文件时，下载到file_url指定的文件，文件名与file_url保持一致。
        当file_url为目录时，下载到file_url指定的目录中，文件名为：object名称，当object名称中含有/或\\时，会创建相应子目录。
    注意：对于以/结尾且大小为0的object，会在本地文件系统创建一个目录，而不是尝试创建一个文件。
    对于其他object会尝试创建文件。

    3) ossutil cp oss://src_bucket[/src_prefix] oss://dest_bucket[/dest_prefix] [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] 
        该用法在oss间进行object的拷贝。其中src_bucket与dest_bucket可以相同，注意，当src_url与
    dest_url完全相同时，ossutil不会做任何事情，直接提示退出（除非指定--meta选项）。如果未指定
    --recursive选项，则认为ossutil会搜索prefix匹配的objects，批量拷贝这些objects。
    注意：批量拷贝时，src_url包含dest_url，或dest_url包含src_url是不允许的（dest_url以src_url为
    前缀时，会产生递归拷贝，src_url以dest_url为前缀时，会覆盖待拷贝文件）。单个拷贝时，该情况是
    允许的。
    object命名规则：
        当src_url为单个文件时，如果dest_url的prefix为空或以/结尾，object名为：dest_url+object名去除所在父目录的路径。
                               否则，object名为：dest_url。
        当src_url为多个文件时，object名为：dest_url+源object名去除src_prefix。

    以上三种用法中如果指定了--recursive选项，均可以使用--include或--exclude选项使用通配符的方式过滤要操作的文件。
`,

        sampleText: ` 
    1) 上传文件到oss
    假设本地local_dir目录中有文件a，b，目录c和d，目录c为空，目录d中包含文件dd。
    
    ossutil cp local_dir/a oss://bucket1
    生成：
        oss://bucket1/a

    ossutil cp local_dir/a oss://bucket1/b
    生成：
        oss://bucket1/b

    ossutil cp local_dir/a oss://bucket1/b/
    生成：
        oss://bucket1/b/a

    ossutil cp local_dir oss://bucket1/b/
    报错

    ossutil cp local_dir oss://bucket1/b -r
    生成：
        oss://bucket1/b/a
        oss://bucket1/b/b
        oss://bucket1/b/c/
        oss://bucket1/b/d/
        oss://bucket1/b/d/dd

    ossutil cp local_dir oss://bucket1/b -r
    如果某文件上传发生服务器内部错误等失败，会在当前目录下的ossutil_output目录中产生report文件
    记录错误信息，并尝试其他文件的上传操作。

    ossutil cp local_dir oss://bucket1/b -r --output-dir=your_dir 
    如果某文件上传发生服务器内部错误等失败，会在your_dir中产生report文件记录错误信息，并尝试其
    他文件的上传操作。

    ossutil cp local_dir oss://bucket1/b -r -u
    使用--update策略进行增量上传

    ossutil cp local_dir oss://bucket1/b -r --snapshot-path=your_local_path
    使用--snapshot-path策略进行增量上传

    ossutil cp local_dir oss://bucket1/b -r -u --snapshot-path=your_local_path
    同时使用--snapshot-path和--update策略进行增量上传

    ossutil cp %e4%b8%ad%e6%96%87 oss://bucket1/%e6%b5%8b%e8%af%95 --encoding-type url
    在本地查找文件名为“中文”的文件，并上传到bucket1生成名称为”测试“的object

    ossutil cp local_dir oss://bucket1/b -r --enable-symlink-dir
    支持上传符号链接子目录下的文件

    ossutil cp local_dir oss://bucket1/b -r --only-current-dir
    只上传当前目录的下文件,忽略其他的子目录

    ossutil cp local_dir oss://bucket1/b -r --disable-all-symlink
    忽略所有的链接子文件以及链接子目录

    ossutil cp local_dir oss://bucket1/b --tagging "tagA=A&amp;tagB=B" -r
    上传的同时设置两个tagging,key分别为tagA和tagB,value分别为A和B

    2) 从oss下载object
    假设oss上有下列objects：
        oss://bucket/abcdir1/a
        oss://bucket/abcdir1/b
        oss://bucket/abcdir1/c
        oss://bucket/abcdir2/a/
        oss://bucket/abcdir2/b/e
    其中oss://bucket/abcdir2/a/的size为0。

    ossutil cp oss://bucket/abcdir1/a b
    生成文件b

    ossutil cp oss://bucket/abcdir1/a b --update
    如果文件b已存在，且更新时间不晚于oss://bucket/abcdir1/a，则跳过本次操作。    

    ossutil cp oss://bucket/abcdir1/a b/
    在目录b下生成文件a

    ossutil cp oss://bucket/abcdir1/a b/ --range=30-90
    在目录b下生成文件a，内容为object：abcdir1/a的第30到第90个字符

    ossutil cp oss://bucket/abcdir2/a/ b
    如果b为已存在文件，报错。
    如果b为已存在目录，在目录b下生成目录a

    ossutil cp oss://bucket/abc b
    报错，object不存在。

    ossutil cp oss://bucket/abc b -r
    如果b为已存在文件，报错    
    否则在目录b下生成目录abcdir1和abcdir2，
        目录abcdir1中生成文件a，b，c
        目录abcdir2中生成目录a和b，目录b中生成文件e

    ossutil cp oss://bucket/ local_dir -r
    如果某文件下载发生服务器内部错误等失败，会在当前目录下的ossutil_output目录中产生report文件
    记录错误信息，并尝试其他文件的下载操作。

    ossutil cp oss://bucket/ local_dir -r --output-dir=your_dir 
    如果某文件下载发生服务器内部错误等失败，会在your_dir中产生report文件记录错误信息，并尝试其
    他文件的下载操作。
        
    ossutil cp oss://bucket/ local_dir -r -u
    使用--update策略进行增量下载

    ossutil cp oss://bucket1/%e6%b5%8b%e8%af%95 %e4%b8%ad%e6%96%87 --encoding-type url
    下载bucket1中名称为”测试“的object到本地，生成文件名为“中文”的文件

    ossutil cp oss://bucket/object local_file --version-id versionId
    指定object版本下载

    ossutil cp oss://bucket/dir/ local_dir -r --only-current-dir
    只下载当前目录下的object, 忽略其他子目录

    3) 在oss间拷贝
    假设oss上有下列objects：
        oss://bucket/abcdir1/a
        oss://bucket/abcdir1/b
        oss://bucket/abcdir1/c
        oss://bucket/abcdir2/a/
        oss://bucket/abcdir2/b/e

    ossutil cp oss://bucket/abcdir1/a oss://bucket1
    生成：
        oss://bucket1/a

    ossutil cp oss://bucket/abcdir1/a oss://bucket1/b
    生成:
        oss://bucket1/b

    ossutil cp oss://bucket/abcdir1/a oss://bucket/abcdir1/a/ 
    生成:
        oss://bucket/abcdir1/a/a

    ossutil cp oss://bucket/abcdir1/a/ oss://bucket/abcdir1/b/ 
    生成：
        oss://bucket/abcdir1/b/a/

    ossutil cp oss://bucket/abcdir1/a oss://bucket/abcdir1/a/ -r 
    报错，递归拷贝

    ossutil cp oss://bucket/abcdir1/a oss://bucket1/b/
    生成：
        oss://bucket1/b/a

    ossutil cp oss://bucket/abc oss://bucket1/b/
    报错，object不存在

    ossutil cp oss://bucket/abc oss://bucket1/123 -r
    生成：
        oss://bucket1/123dir1/a
        oss://bucket1/123dir1/b
        oss://bucket1/123dir1/c
        oss://bucket1/123dir2/a/
        oss://bucket1/123dir2/b/e

    ossutil cp oss://bucket/abc oss://bucket1/123/ -r
    生成：
        oss://bucket1/123/dir1/a
        oss://bucket1/123/dir1/b
        oss://bucket1/123/dir1/c
        oss://bucket1/123/dir2/a/
        oss://bucket1/123/dir2/b/e

    ossutil cp oss://bucket/abcdir1/a oss://bucket1/ -r
    报错，因为此时目标object名称为空，非法

    ossutil cp oss://bucket/ oss://bucket1/ -r
    如果某文件拷贝发生服务器内部错误等失败，会在当前目录下的ossutil_output目录中产生report文件
    记录错误信息，并尝试其他文件的拷贝操作。

    ossutil cp oss://bucket/ oss://bucket1/ -r --output-dir=your_dir 
    如果某文件拷贝发生服务器内部错误等失败，会在your_dir中产生report文件记录错误文件的信息，并
    尝试其他文件的拷贝操作。

    ossutil cp oss://bucket/ oss://bucket1/ -r -u
    使用--update策略进行增量拷贝

    ossutil cp oss://bucket1/%e6%b5%8b%e8%af%95 oss://bucket2/%e4%b8%ad%e6%96%87 --encoding-type url
    拷贝bucket1中名称为”测试“的object到bucket2，生成object名为“中文”的object

    ossutil cp oss://bucket/object1 oss://bucket/object2 --version-id versionId
    指定object版本copy 

    ossutil cp oss://bucket/dir/ oss://bucket1/ -r --only-current-dir
    只copy当前目录下的object, 忽略其他子目录

    ossutil cp oss://bucket/object1 oss://bucket/object2 --tagging "tagA=A&amp;tagB=B"
    copy的同时设置两个tagging,key分别为tagA和tagB,value分别为A和B
`,
}

var specEnglishCopy = SpecText{

        synopsisText: "Upload, Download or Copy Objects",

        paramText: "src_url dest_url [options]",

        syntaxText: ` 
    ossutil cp file_url cloud_url  [-r] [-f] [-u] [--enable-symlink-dir] [--disable-all-symlink] [--disable-ignore-error] [--only-current-dir] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--snapshot-path=sdir] [--payer requester]
    ossutil cp cloud_url file_url  [-r] [-f] [-u] [--only-current-dir] [--output-dir=odir] [--disable-ignore-error] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--range=x-y] [--payer requester]
    ossutil cp cloud_url cloud_url [-r] [-f] [-u] [--only-current-dir] [--output-dir=odir] [--disable-ignore-error] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--payer requester]
`,

        detailHelpText: ` 
    The command allows: 
    1. Upload file from local file system to oss 
    2. Download object from oss to local file system
    3. Copy objects between oss
    Which matches with the following three kinds of operations:
        ossutil cp file_url oss://bucket[/prefix] [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--snapshot-path=sdir] [--payer requester]
        ossutil cp oss://bucket[/prefix] file_url [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--range=x-y] [--payer requester]
        ossutil cp oss://src_bucket[/src_prefix] oss://dest_bucket[/dest_prefix] [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--payer requester]

    file_url means the file in local file system, it supports relative path and absolute 
    path, the usage of file_url is same with your local file system. oss://bucket[/prefix] 
    means object in oss, it supports prefix matching, but not support wildcard.

    ossutil sperate file of local system and oss objects by the prefix of oss://, which means 
    if the url starts with oss://, ossutil considers it as object, else, ossutil considers it 
    as file in local system. 

    Note: when copy between oss, ossutil only support copy objects, the uncompleted Multipart 
    Uploads are not supported.


--recursive option:

    (1) Upload file to oss: if file_url is directory, the --recursive option must be specified. 

    (2) When download objects or copy objects between oss:
        If --recursive option is not specified, ossutil download or copy the specified single 
    object, in the usage, please make sure url exactly specified the object you want to set meta 
    on, if object not exist, error occurs. 
        If --recursive option is specified, ossutil will search for prefix-matching objects and 
    download or copy these objects. If error occurs, objects which has been download or copyed 
    will not rollback. 

    By default, if an error occurs to a file in batch upload(/download/copy) files operation, 
    ossutil will continue to attempt to copy the remaining files, and ossutil will record the 
    error message to report file. The files succeed copied will not be recorded to report file.   

    Note: Ossutil will print error information and exit, instead of continue to run if an error 
    occurs in batch upload(/download/copy) files operation in several situations:
    (1) If the error occurs before of entering the upload(/download/copy) iteration, ossutil will 
        print error message and return, and the report file will not be generated. eg. user enter 
        an invalid cp command.
    (2) If the error occurs during upload(/download/copy) iteration is: NoSuchBucket, AccessDenied 
        caused by unauthorized authentication and other errors. ossutil will print error message 
        and return, the report file that has been generated will not be deleted.

    Report file name is: ` + ReportPrefix + `Date_Time` + ReportSuffix + `. Report file is one kind 
    of output files, and will be putted in output directory, the directory can be specified by 
    --output-dir option or outputDir option in config file. If it's not specified, ossutil will use 
    the default directory: ` + DefaultOutputDir + ` in current directory.

    Note: ossutil will not mainten the report file, please check and clear your output directory 
    regularlly to avoid too many report files in your output directory. 

--include and --exclude option:

    When --recursive is specified, these parameters perform pattern matching to either exclude or
    include a particular file or object. By default, all files/objects are included.

    The following pattern symbols are supported.
    *: Matches everything
    ?: Matches any single character
    [sequence]: Matches any character in sequence
    [!sequence]: Matches any character not in sequence
    Note: does not support patterns containing directory info. e.g., --include "/usr/*/test/*.jpg" 

    Any number of these parameters can be passed to a command. You can do this by providing an --exclude
    or --include argument multiple times, e.g.,
      --include "*.txt" --include "*.png". 
    When there are multi filters, the rule is the filters that appear later in the command take precedence
    over filters that appear earlier in the command. e.g.,

    --exclude "*" --include "*.txt"
    All files will be excluded from the command except for files ending with .txt

    --include "*.txt" --exclude "*"
    All files will be excluded from the command.

    e.g., 3 files in current dir
    testfile1.jpg
    testfiel2.txt
    testfile33.jpg

    $ ossutil cp . oss://my-bucket/path --exclude '*.jpg'
    upload testfile2.txt to oss://my-bucket/path/testfile2.txt

    $ ossutil cp . oss://my-bucket/path --exclude '*.jpg' --include 'testfile*.jpg'
    upload testfile1.jpg to oss://my-bucket/path/testfile1.jpg
    upload testfile33.jpg to oss://my-bucket/path/testfile33.jpg
    upload testfile2.txt to oss://my-bucket/path/testfile2.txt

    $ ossutil cp . oss://my-bucket/path --exclude '*.jpg' --include 'testfile*.jpg' --exclude 'testfile?.jpg'
    upload testfile2.txt to oss://my-bucket/path/testfile2.txt
    upload testfile33.jpg to oss://my-bucket/path/testfile33.jpg

--meta option

    This option will set the specified objects' meta data. If --recursive option is specified, 
    ossutil will set meta for all uploaded objects.  

    ossutil supports following headers:
        ` + formatHeaderString(headerOptionMap, "\n        ") + `
        and headers starts with: ` + oss.HTTPHeaderOssMetaPrefix + `

    Note: headers are case-insensitive, but value are case-sensitive. After setting, origin meta will be
    replaced with specified meta. HTTP HEADER will be reserved if no speified value. User meta will be
    deleted if no specified value.

--tagging option

    This option will set the specified objects' tagging data. If --recursive option is specified, 
    ossutil will set tagging for all uploaded objects. 
    If you set more than one tagging at a time, you must use double quotes, such as "tagA=A&amp;tagB=B"

--acl option

    This option will set acl on the specified objects. If --recursive option is specified, 
    ossutil will set acl for all uploaded objects.  

    ossutil support following objet acls:
        ` + formatACLString(objectACL, "\n        ") + `

    More information about acl see ACL Control in https://help.aliyun.com/document_detail/31867.html?spm=5176.doc31960.6.147.8dVwsh.

--output-dir option
    
    The option specify the directory to deposit output file generated by ossutil, the default value 
    is: ` + DefaultOutputDir + ` in current directory. If the directory specified not exist, ossutil will 
    create the directory automatically, if it exists but is not a directory, ossutil will return an 
    error.  

    Output file contains: report file which used to record error message generated by cp command, 
    set-acl, set-meta, restore command.


Incremental Upload/Download/Copy:

--update option(-u)

    Use the --update option to copy only when the source file is newer than the destination file 
    when the destination file is missing. If --update option is specified, when the destionation 
    file is existed, ossutil will not prompt and copy when newer, no matter if --force option is 
    specified or not.
    The option can be used when batch copy failed, skip the succeed files in retry.

--snapshot-path option

    This option is used to accelerate the incremental upload of batch files in certain scenarios(
    currently, download and copy do not support this option). The scenarios is: lots of files and 
    no other user updated the corresponding object in oss during the two uploads.
    
    If you use the option when batch copy files, ossutil will generate files to record the snapshot 
    information in the specified directory. When the next time you upload files with the option, 
    ossutil will read the snapshot information under the specified directory for incremental upload. 
    The snapshot-path you specified must be a local file system directory can be written in, if the 
    directory does not exist, ossutil creates the files for recording snapshot information, else 
    ossutil will read snapshot information from the directory for incremental upload(ossutil will 
    only upload the files which has not been successfully upload to oss and the files has been locally 
    modified), and update the snapshot information to the directory. 
    
    Note: 
    (1) The option record the lastModifiedTime of local files which has been successfully upload in 
        local file system, and compare the lastModifiedTime of local files in the next cp to decided 
        whether to skip the upload of the files, so if you use the option to achieve incremental upload, 
        please make sure no other user updated the corresponding object in oss during the two uploads. 
        If you can not guarantee the scenarios, please use --update option to achieve incremental upload. 
    (2) Ossutil does not automatically delete snapshot-path snapshot information, in order to avoid too 
        much snapshot information, when the snapshot information is useless, please clean up your own 
        snapshot-path on your own.
    (3) Due to the extra cost of reading and writing snapshot information, if the file num is not very big, 
        or the network condition is good, or there may be some other users to modify the corresponding 
        object in oss during the two uploads, it's not suggested to use the option. you can use --update 
        option for incremental upload. 

Note: --update option and --snapshot-path can be used together, ossutil priority will be based on snapshot 
    information to determine whether to skip upload, if not satisfied, ossutil will then based on --update 
    to determine whether to skip upload. If any of those two policies is specified, ossutil will ingnore 
    --force option, which means whether or not the destionation file exists, ossutil will not ask user 
    whether to replace the file, and determine whether to upload according to incremental upload policies.

    Incremental download will not consider the value of --range option, and only consider whether file 
    exists and lastModifiedTime. Which means even if the range changs between two download, ossutil will 
    skip the files which satisfy the incremental download condition, so, please avoid to use both!


Other Options:

--force option

    If the file dest_url specified is existed, and --update and --snapshot-path option is not specified, 
    ossutil will ask if replace the file(if the input is invalid, the file will not be replaced). If 
    --force option is specified here, ossutil will not prompt, replace by force. The option is useful 
    only when --update and --snapshot-path option is not specified. 

--range option
    
    If user need to range download a file, we can use --range option, if we use the option, then 
    resume copy of big file and multi-thread copy is ineffective.
    
    The offset of file is start 
    with 0, there are three forms: 0-9 or 3- or -9.
        eg: --range=0-9, means download the first to the tenth character of the file.
        --range=3-, means download the fourth character to the end of the file.
        --range=-9, means download the last nine character of the file.
    If the range exceed the file actual scope, will download the whole file.
    More information about range see: https://help.aliyun.com/document_detail/31980.html?spm=5176.doc31994.6.860.YH7LL1

    If you need to download the whole file, please do not specify the option.
    The option is not supported for upload and copy files. 

    Note: Incremental download(-u option) will not conside --range option. Which means even if the 
    range changs between two download, ossutil will skip the files which satisfy the incremental 
    download condition, so, please avoid to use both!

--encoding-type option
    
    If the --encoding-type option is setted to url, it means the object name and file name are url 
    endcoded.

--enable-symlink-dir option

   Allows transfer of files in the link subdirectory. If there is an infinite loop link file or directory, 
   it will cause an error. 
   It is recommended to use the probe command to detect the existence of an infinite loop link file or 
   directory before use

--disable-all-symlink option

  specifies that uploading of symlink files and symlink directories under the directory is not allowed

--only-current-dir
    
   Used with the -r option, it means that only the files in the current directory will be manipulated, 
   and the subdirectories under the current directory will be ignored.
   If you are downloading or copying the oss directory, add a backslash(/) after the directory.

Resume copy of big file:

    If the size of source file is bigger than what --bigfile-threshold option specified(default: 
    100M), ossutil will consider the file as a big file, and use resume copy policy to these files:
    (1) Upload file to oss: ossutil will split the big file to many parts, use multipart upload. If 
        upload is failed, ossutil will record failure information in .ossutil_checkpoint directory 
        in local file system. When retry, ossutil will read the checkpoint information and resume 
        upload, if the upload is succeed, ossutil will remove the .ossutil_checkpoint directory. 
    (2) Download object from oss: ossutil will split the big file to many parts, range get each part. 
        If download is failed, ossutil wll record failure information in .ossutil_checkpoint directory 
        in local file system. If success, ossutil will remove the directory.
    (3) Copy between oss: ossutil will split the big file to many parts, use Upload Part Copy, and 
        record failure information in .ossutil_checkpoint directory in local file system. If success, 
        ossutil will remove the directory.

    Warning:
    1) Resume copy will not be implemented on small file, if failure happens, ossutil will copy the 
        whole file the next time.
    2) In operation (1) and (3), if failure happens, uploadId that has not been completed may appear in 
        oss. If the operation success after retry, these uploadId will be completed automatically. 
    3) When upload file to oss, if .ossutil_checkpoint directory is included in file_url, .ossutil_checkpoint 
        will not be uploaded to oss. The path of checkpoint directory can be specified by --checkpoint-dir 
        option, please make sure the directory you specified can be removed.
    4) If you remove the uncompleted multipart upload tasks by rm command, may cause resume upload/download/copy 
        fail the next time(Error: NoSuchUpload). If you want to reupload/download/copy the entire file again, 
        please remove the checkpoint file in checkpoint directory.


Performance Tuning:

--jobs option or --parallel option (Concurrency Control)

    --jobs option controls the amount of concurrency tasks between multi-files, --parallel option controls 
    the amount of concurrency tasks when work with a file. In default situation, ossutil will calculate the 
    parallel num according to file size(the option is useless to small file, the file size to use multipart 
    upload can be specified by --bigfile-threshold option). When batch upload/download/copy files, the total 
    concurrency tasks num is jobs num multiply by parallel num. The two option can be specified by user, if 
    the performance of default setting is poor, user can adjust the two options. 

    Note:
    1) If the parallels and jobs number are too big, because of the switching between threads, the performance 
    of upload/download/copy may decline, so please set the options according to your machine condition. If need 
    performance tuning, user can set the two options to two small numbers at first and increase them step by step. 
    2) If the parallels and jobs number are too big, in the case of limited machine resources, error "EOF" may 
    occur due to the network transfer too slow, in this situation, please reduce the --jobs and --parallel num. 

--part-size option

    The option specify the part size of resume upload/download/copy of big file. In default situation, ossutil 
    will calculate the part size and parallel according to file size. When performance tuning or some other needs, 
    user can set the option.     

    If the option is specified, part num is: ceil(file size/part size). Note that if --parallel value is bigger 
    than part num, the extra parallel is feeble, the actual parallel will be part num.

    If the part size is too small, it may influence ossutil file upload/download/copy performance, if the part 
    size is too big, it may influence the actual parallel num, so, please if specify the option, please set it 
    to a reasonable value. 


Batch file migration:

    ossutil support batch file migration by transfer files through local file system, the usual usage is: 
    (1) Batch file upload:
        ossutil cp your_dir oss://your_bucket -r -f -u
    (2) Batch file download:
        ossutil cp oss://your_bucket your_dir -r -f -u
    (3) File copy between buckets in the same region：
        ossutil cp oss://your_src_bucket oss://your_dest_bucket -r -f -u

    The meaning of every option, see help above.
    After each migration, please check your report file.

    When batch file upload, if the file num is big and no other user modified the corresponding object in 
    oss during the two uploads, you can use --snapshot-path to accelerate the incremental upload, see more 
    information in help text of --snapshot-path option above. 
    The command is: 
        ossutil cp your_dir oss://your_bucket -r -f -u --shapshot-path=your-path


Usage:

    There are three usages:

    1) ossutil cp file_url oss://bucket[/prefix] [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--snapshot-path=sdir]
        The usage upload file in local system to oss. file_url can be file or directory. If file_url 
    is file, no matter --recursive option is specified or not will not affect the result. If file_url 
    is directory, even if the directory is empty or only contains one file, we must specify --recursive 
    option. Mind that, ossutil will upload all sub files and directories(include empty directory) inside 
    file_url to oss, but differe from shell cp, the first level directory specified by file_url will not 
    be upload to oss. 
    Object Naming Rules:
        If file_url is file: if prefix is empty or end with "/", object name is: dest_url + file name.
                             else, object name is: dest_url.
        If file_url is directory: if prefix is empty or end with "/", object name is: dest_url + file path relative to file_url.
        
    2) ossutil cp oss://bucket[/prefix] file_url [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] [--range=x-y] 
        The usage download one or many objects to local system. If --recursive option is not specified, 
    ossutil considers src_url exactly specified the single object you want to download, prefix-matching 
    is not supported now, if the object not exists, error occurs. If --recursive option is specified, 
    ossutil will search for prefix-matching objects and batch download those objects, at this time file_url 
    must be directory, if the directory not exists, ossutil will create the directory automatically.
    File Naming Rules:
        If file_url is file, ossutil download file to the path of file_url, and the file name is got from file_url.
        If file_url is directory, ossutil download file to the directory, and the file name is: object name.
    Warning: If the object name is end with / and size is zero, ossutil will create a directory in local 
    system, instead of creating a file.

    3) ossutil cp oss://src_bucket[/src_prefix] oss://dest_bucket[/dest_prefix] [-r] [-f] [-u] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=file] 
        The usage copy objects between oss. The src_bucket can be same with dest_bucket. Pay attention 
    please, if src_url is the same with dest_url, ossutil will do nothing but exit after prompt(expect --meta 
    option is included ). If --recursive option is not specified, ossutil considers src_url exactly 
    specified the single object you want to copy. If --recursive option is specified, ossutil will search 
    for prefix-matching objects and batch copy those objects. 

    Warning: when batch copy, it's not allowed that src_url is the prefix of dest_url, because recursivlly 
    copy will happen under the situation. dest_ur is the prefix of src_url is not allowed too, because of 
    covering source file. But they are allowed in single file copy.

    Object Naming Rules:
        If src_url is one object: if prefix of dest_object is empty or end with "/", object name is: dest_url + object name exclude parenet directory path. 
                                  else, object name is: dest_url.
        If src_url means multiple objects: object name is: dest_url+ source object name exclude src_prefix.
`,

        sampleText: ` 
    1) Upload to oss
    Suppose there are directory local_dir in local system, 
        local_dir contains file a, b directory c, d, 
        c is empty, d contains file dd.
    
    ossutil cp local_dir/a oss://bucket1
    Generate:
        oss://bucket1/a

    ossutil cp local_dir/a oss://bucket1/b
    Generate:
        oss://bucket1/b

    ossutil cp local_dir/a oss://bucket1/b/
    Generate:
        oss://bucket1/b/a

    ossutil cp local_dir oss://bucket1/b/
    Error

    ossutil cp local_dir oss://bucket1/b -r
    Generate:
        oss://bucket1/b/a
        oss://bucket1/b/b
        oss://bucket1/b/c/
        oss://bucket1/b/d/
        oss://bucket1/b/d/dd

    ossutil cp local_dir oss://bucket1/b -r
    If an 5xx error occurs while upload a file, ossutil will generate a report file and record the error 
    information to the file, and store the file in ossutil_output directory in current path, and continue 
    to upload the remaining files.

    ossutil cp local_dir oss://bucket1/b -r --output-dir=your_dir 
    If an 5xx error occurs while upload a file, ossutil will generate a report file and record the error 
    information to the file, and store the file in your_dir, and continue to upload the remaining files.

    ossutil cp local_dir oss://bucket1/b -r -u
    Use --update policy for incremental upload

    ossutil cp local_dir oss://bucket1/b -r --snapshot-path=your_local_path
    Use --snapshot-path policy for incremental upload

    ossutil cp local_dir oss://bucket1/b -r -u --snapshot-path=your_local_path
    Use --snapshot-path and --update policies for incremental upload

    ossutil cp %e4%b8%ad%e6%96%87 oss://bucket1/%e6%b5%8b%e8%af%95 --encoding-type url
    Upload the file "中文" to oss://bucket1/测试

    ossutil cp local_dir oss://bucket1/b -r --enable-symlink-dir
    Support for uploading files in the symlink subdirectory

    ossutil cp local_dir oss://bucket1/b -r --only-current-dir
    Upload only the files in the current directory, ignoring other subdirectories

    ossutil cp local_dir oss://bucket1/b -r --disable-all-symlink
    uploading of symlink files and symlink directories under the local_dir is not allowed 

    ossutil cp local_dir oss://bucket/b --tagging "tagA=A&amp;tagB=B"
    Set two taggings when uploading, the key is tagA and tagB, and the value is A and B

    2) download from oss
    Suppose there are following objects in oss:
        oss://bucket/abcdir1/a
        oss://bucket/abcdir1/b
        oss://bucket/abcdir1/c
        oss://bucket/abcdir2/a/
        oss://bucket/abcdir2/b/e
    And size of oss://bucket/abcdir2/a/ is zero. 

    ossutil cp oss://bucket/abcdir1/a b
    Generate file b

    ossutil cp oss://bucket/abcdir1/a b/
    Generate file a under directory b

    ossutil cp oss://bucket/abcdir1/a b/ --range=30-90
    Generate file a under directory b, the content is the thirty-first character to the ninety-first character of object abcdir1/a.

    ossutil cp oss://bucket/abcdir2/a/ b
    If b exists and is a file, error occurs.
    If b exists and is a directory, generate directory a under directory b.

    ossutil cp oss://bucket/abc b
    Error: object not exist

    ossutil cp oss://bucket/abc b -r
    If b exists and is a file, error occurs.
    Else generate directory dir1, dir2,
        generate file a, b, c in dir1,
        generate directory a, b in dir2, generate file e in directory b.
        
    ossutil cp oss://bucket/ local_dir -r
    If an 5xx error occurs while download a file, ossutil will generate a report file and record the error 
    information to the file, and store the file in ossutil_output directory in current path, and continue 
    to download the remaining files.

    ossutil cp oss://bucket/ local_dir -r --output-dir=your_dir
    If an 5xx error occurs while download a file, ossutil will generate a report file and record the error 
    information to the file, and store the file in your_dir, and download to upload the remaining files.

    ossutil cp oss://bucket/ local_dir -r -u
    Use --update policy for incremental download

    ossutil cp oss://bucket1/%e6%b5%8b%e8%af%95 %e4%b8%ad%e6%96%87 --encoding-type url
    Download oss://bucket1/测试 to local file：中文 

    ossutil cp oss://bucket/object1 local_file --version-id versionId
    Specify object version download

    ossutil cp oss://bucket/dir/ local_dir -r --only-current-dir
    Only download the object in the current directory, ignore other subdirectories

    3) Copy between oss 
    Suppose there are following objects in oss:
        oss://bucket/abcdir1/a
        oss://bucket/abcdir1/b
        oss://bucket/abcdir1/c
        oss://bucket/abcdir2/a/
        oss://bucket/abcdir2/b/e

    ossutil cp oss://bucket/abcdir1/a oss://bucket1
    Generate:
        oss://bucket1/a

    ossutil cp oss://bucket/abcdir1/a oss://bucket1/b
    Generate:
        oss://bucket1/b

    ossutil cp oss://bucket/abcdir1/a oss://bucket/abcdir1/a/ 
    Generate:
        oss://bucket/abcdir1/a/a

    ossutil cp oss://bucket/abcdir1/a/ oss://bucket/abcdir1/b/ 
    Generate:
        oss://bucket/abcdir1/b/a/

    ossutil cp oss://bucket/abcdir1/a oss://bucket/abcdir1/a/ -r 
    Error, recursivlly copy

    ossutil cp oss://bucket/abcdir1/a oss://bucket1/b/
    Generate:
        oss://bucket1/b/a

    ossutil cp oss://bucket/abc oss://bucket1/b/
    Error: object not exist

    ossutil cp oss://bucket/abc oss://bucket1/123 -r
    Generate:
        oss://bucket1/123dir1/a
        oss://bucket1/123dir1/b
        oss://bucket1/123dir1/c
        oss://bucket1/123dir2/a/
        oss://bucket1/123dir2/b/e

    ossutil cp oss://bucket/abc oss://bucket1/123/ -r
    Generate:
        oss://bucket1/123/dir1/a
        oss://bucket1/123/dir1/b
        oss://bucket1/123/dir1/c
        oss://bucket1/123/dir2/a/
        oss://bucket1/123/dir2/b/e

    ossutil cp oss://bucket/ oss://bucket1/ -r
    If an 5xx error occurs while copy a file, ossutil will generate a report file and record the error 
    information to the file, and store the file in ossutil_output directory in current path, and continue 
    to copy the remaining files.

    ossutil cp oss://bucket/ oss://bucket1/ -r --output-dir=your_dir 
    If an 5xx error occurs while copy a file, ossutil will generate a report file and record the error 
    information to the file, and store the file in your_dir, and continue to copy the remaining files.

    ossutil cp oss://bucket/ oss://bucket1/ -r -u
    Use --update policy for incremental copy

    ossutil cp oss://bucket1/%e6%b5%8b%e8%af%95 oss://bucket2/%e4%b8%ad%e6%96%87 --encoding-type url
    Copy oss://bucket1/测试 to oss://bucket2/中文

    ossutil cp oss://bucket/object1 oss://bucket/object2 --version-id versionId
    Specify source object version copy

    ossutil cp oss://bucket/dir/ oss://bucket1/ -r --only-current-dir
    Copy only the object in the current directory, ignoring other subdirectories

    ossutil cp oss://bucket/object1 oss://bucket/object2 --tagging "tagA=A&amp;tagB=B"
    Set two taggings when copying, the key is tagA and tagB, and the value is A and B
`,
}

// CopyCommand is the command upload, download and copy objects
type CopyCommand struct {
        monitor  CPMonitor //Put first for atomic op on some fileds
        command  Command
        cpOption copyOptionType
}

var copyCommand = CopyCommand{
        command: Command{
                name:        "cp",
                nameAlias:   []string{"copy"},
                minArgc:     2,
                maxArgc:     MaxInt,
                specChinese: specChineseCopy,
                specEnglish: specEnglishCopy,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionRecursion,
                        OptionForce,
                        OptionUpdate,
                        OptionContinue,
                        OptionOutputDir,
                        OptionBigFileThreshold,
                        OptionPartSize,
                        OptionCheckpointDir,
                        OptionRange,
                        OptionEncodingType,
                        OptionInclude,
                        OptionExclude,
                        OptionMeta,
                        OptionACL,
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionRoutines,
                        OptionParallel,
                        OptionSnapshotPath,
                        OptionDisableCRC64,
                        OptionRequestPayer,
                        OptionLogLevel,
                        OptionMaxUpSpeed,
                        OptionPartitionDownload,
                        OptionVersionId,
                        OptionLocalHost,
                        OptionEnableSymlinkDir,
                        OptionOnlyCurrentDir,
                        OptionDisableDirObject,
                        OptionDisableAllSymlink,
                        OptionDisableIgnoreError,
                        OptionTagging,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (cc *CopyCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return cc.command.formatHelpForWhole()
}</span>

func (cc *CopyCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return cc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (cc *CopyCommand) Init(args []string, options OptionMapType) error <span class="cov7" title="24">{
        return cc.command.Init(args, options, cc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (cc *CopyCommand) RunCommand() error <span class="cov7" title="24">{
        cc.cpOption.recursive, _ = GetBool(OptionRecursion, cc.command.options)
        cc.cpOption.force, _ = GetBool(OptionForce, cc.command.options)
        cc.cpOption.update, _ = GetBool(OptionUpdate, cc.command.options)
        cc.cpOption.threshold, _ = GetInt(OptionBigFileThreshold, cc.command.options)
        cc.cpOption.cpDir, _ = GetString(OptionCheckpointDir, cc.command.options)
        cc.cpOption.routines, _ = GetInt(OptionRoutines, cc.command.options)
        cc.cpOption.ctnu = false
        if cc.cpOption.recursive </span><span class="cov0" title="0">{
                disableIgnoreError, _ := GetBool(OptionDisableIgnoreError, cc.command.options)
                cc.cpOption.ctnu = !disableIgnoreError
        }</span>
        <span class="cov7" title="24">outputDir, _ := GetString(OptionOutputDir, cc.command.options)
        cc.cpOption.snapshotPath, _ = GetString(OptionSnapshotPath, cc.command.options)
        cc.cpOption.vrange, _ = GetString(OptionRange, cc.command.options)
        cc.cpOption.encodingType, _ = GetString(OptionEncodingType, cc.command.options)
        cc.cpOption.meta, _ = GetString(OptionMeta, cc.command.options)
        cc.cpOption.tagging, _ = GetString(OptionTagging, cc.command.options)
        acl, _ := GetString(OptionACL, cc.command.options)
        payer, _ := GetString(OptionRequestPayer, cc.command.options)
        cc.cpOption.partitionInfo, _ = GetString(OptionPartitionDownload, cc.command.options)
        cc.cpOption.versionId, _ = GetString(OptionVersionId, cc.command.options)
        cc.cpOption.enableSymlinkDir, _ = GetBool(OptionEnableSymlinkDir, cc.command.options)
        cc.cpOption.onlyCurrentDir, _ = GetBool(OptionOnlyCurrentDir, cc.command.options)
        cc.cpOption.disableDirObject, _ = GetBool(OptionDisableDirObject, cc.command.options)
        cc.cpOption.disableAllSymlink, _ = GetBool(OptionDisableAllSymlink, cc.command.options)

        if cc.cpOption.enableSymlinkDir &amp;&amp; cc.cpOption.disableAllSymlink </span><span class="cov0" title="0">{
                return fmt.Errorf("--enable-symlink-dir and --disable-all-symlink can't be both exist")
        }</span>

        <span class="cov7" title="24">var res bool
        res, cc.cpOption.filters = getFilter(os.Args)
        if !res </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude does not support format containing dir info")
        }</span>

        <span class="cov7" title="24">if !cc.cpOption.recursive &amp;&amp; len(cc.cpOption.filters) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude only work with --recursive")
        }</span>

        <span class="cov7" title="24">for k, v := range cc.cpOption.filters </span><span class="cov0" title="0">{
                LogInfo("filter %d,name:%s,pattern:%s\n", k, v.name, v.pattern)
        }</span>

        //get file list
        <span class="cov7" title="24">srcURLList, err := cc.getStorageURLs(cc.command.args[0 : len(cc.command.args)-1])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="24">destURL, err := StorageURLFromString(cc.command.args[len(cc.command.args)-1], cc.cpOption.encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="24">opType := cc.getCommandType(srcURLList, destURL)
        if err := cc.checkCopyArgs(srcURLList, destURL, opType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="24">if err := cc.checkCopyOptions(opType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="24">cc.cpOption.options = []oss.Option{}
        if cc.cpOption.meta != "" </span><span class="cov0" title="0">{
                if opType == operationTypeGet </span><span class="cov0" title="0">{
                        return fmt.Errorf("No need to set meta for download")
                }</span>

                <span class="cov0" title="0">headers, err := cc.command.parseHeaders(cc.cpOption.meta, false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">topts, err := cc.command.getOSSOptions(headerOptionMap, headers)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cc.cpOption.options = append(cc.cpOption.options, topts...)</span>
        }

        <span class="cov7" title="24">if cc.cpOption.tagging != "" </span><span class="cov0" title="0">{
                if opType == operationTypeGet </span><span class="cov0" title="0">{
                        return fmt.Errorf("No need to set tagging for download")
                }</span>
                <span class="cov0" title="0">tags, err := cc.command.getOSSTagging(cc.cpOption.tagging)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tagging := oss.Tagging{Tags: tags}
                cc.cpOption.options = append(cc.cpOption.options, oss.SetTagging(tagging))</span>
        }

        <span class="cov7" title="24">if acl != "" </span><span class="cov0" title="0">{
                if opType == operationTypeGet </span><span class="cov0" title="0">{
                        return fmt.Errorf("No need to set ACL for download")
                }</span>

                <span class="cov0" title="0">var opAcl oss.ACLType
                if opAcl, err = cc.command.checkACL(acl, objectACL); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cc.cpOption.options = append(cc.cpOption.options, oss.ObjectACL(opAcl))</span>
        }

        <span class="cov7" title="24">if cc.cpOption.versionId != "" </span><span class="cov0" title="0">{
                cc.cpOption.options = append(cc.cpOption.options, oss.VersionId(cc.cpOption.versionId))
        }</span>

        <span class="cov7" title="24">if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">cc.cpOption.options = append(cc.cpOption.options, oss.RequestPayer(oss.PayerType(payer)))
                cc.cpOption.payerOptions = append(cc.cpOption.payerOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        // init reporter
        <span class="cov7" title="24">if cc.cpOption.reporter, err = GetReporter(cc.cpOption.recursive, outputDir, commandLine); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // create checkpoint dir
        <span class="cov7" title="24">if err := os.MkdirAll(cc.cpOption.cpDir, 0755); err != nil </span><span class="cov0" title="0">{

                //
                //fmt.Printf("%s", cc.cpOption.cpDir)
                return err
        }</span>

        // load snapshot
        <span class="cov7" title="24">if cc.cpOption.snapshotPath != "" </span><span class="cov0" title="0">{
                if cc.cpOption.snapshotldb, err = leveldb.OpenFile(cc.cpOption.snapshotPath, nil); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("load snapshot error, reason: %s", err.Error())
                }</span>
                <span class="cov0" title="0">defer cc.cpOption.snapshotldb.Close()</span>
        }

        <span class="cov7" title="24">if cc.cpOption.partitionInfo != "" </span><span class="cov0" title="0">{
                if opType == operationTypeGet </span><span class="cov0" title="0">{
                        sliceInfo := strings.Split(cc.cpOption.partitionInfo, ":")
                        if len(sliceInfo) == 2 </span><span class="cov0" title="0">{
                                partitionIndex, err1 := strconv.Atoi(sliceInfo[0])
                                partitionCount, err2 := strconv.Atoi(sliceInfo[1])
                                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("parsar OptionPartitionDownload error,value is:%s", cc.cpOption.partitionInfo)
                                }</span>
                                <span class="cov0" title="0">if partitionIndex &lt; 1 || partitionCount &lt; 1 || partitionIndex &gt; partitionCount </span><span class="cov0" title="0">{
                                        return fmt.Errorf("parsar OptionPartitionDownload error,value is:%s", cc.cpOption.partitionInfo)
                                }</span>
                                <span class="cov0" title="0">cc.cpOption.partitionIndex = partitionIndex
                                cc.cpOption.partitionCount = partitionCount</span>
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("parsar OptionPartitionDownload error,value is:%s", cc.cpOption.partitionInfo)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("PutObject or CopyObject doesn't support option OptionPartitionDownload")
                }</span>
        } else<span class="cov7" title="24"> {
                cc.cpOption.partitionIndex = 0
                cc.cpOption.partitionCount = 0
        }</span>

        <span class="cov7" title="24">cc.monitor.init(opType)

        chProgressSignal = make(chan chProgressSignalType, 10)
        go cc.progressBar()

        startT := time.Now().UnixNano() / 1000 / 1000
        switch opType </span>{
        case operationTypePut:<span class="cov6" title="14">
                LogInfo("begin uploadFiles\n")
                err = cc.uploadFiles(srcURLList, destURL.(CloudURL))</span>
        case operationTypeGet:<span class="cov5" title="10">
                LogInfo("begin downloadFiles\n")
                err = cc.downloadFiles(srcURLList[0].(CloudURL), destURL.(FileURL))</span>
        default:<span class="cov0" title="0">
                LogInfo("begin copyFiles\n")
                err = cc.copyFiles(srcURLList[0].(CloudURL), destURL.(CloudURL))</span>
        }
        <span class="cov7" title="24">endT := time.Now().UnixNano() / 1000 / 1000
        if endT-startT &gt; 0 </span><span class="cov7" title="22">{
                averSpeed := (cc.monitor.transferSize / (endT - startT)) * 1000
                fmt.Printf("\naverage speed %d(byte/s)\n", averSpeed)
                LogInfo("average speed %d(byte/s)\n", averSpeed)
        }</span>

        <span class="cov7" title="24">cc.cpOption.reporter.Clear()
        ckFiles, _ := ioutil.ReadDir(cc.cpOption.cpDir)
        if err == nil &amp;&amp; len(ckFiles) == 0 </span><span class="cov6" title="20">{
                LogInfo("begin Remove checkpointDir %s\n", cc.cpOption.cpDir)
                os.RemoveAll(cc.cpOption.cpDir)
        }</span>
        <span class="cov7" title="24">return err</span>
}

func (cc *CopyCommand) getStorageURLs(urls []string) ([]StorageURLer, error) <span class="cov7" title="24">{
        urlList := []StorageURLer{}
        for _, url := range urls </span><span class="cov7" title="24">{
                storageURL, err := StorageURLFromString(url, cc.cpOption.encodingType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov7" title="24">if storageURL.IsCloudURL() &amp;&amp; storageURL.(CloudURL).bucket == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cloud url: %s, miss bucket", url)
                }</span>
                <span class="cov7" title="24">urlList = append(urlList, storageURL)</span>
        }
        <span class="cov7" title="24">return urlList, nil</span>
}

func (cc *CopyCommand) getCommandType(srcURLList []StorageURLer, destURL StorageURLer) operationType <span class="cov7" title="24">{
        if srcURLList[0].IsCloudURL() </span><span class="cov5" title="10">{
                if destURL.IsFileURL() </span><span class="cov5" title="10">{
                        return operationTypeGet
                }</span>
                <span class="cov0" title="0">return operationTypeCopy</span>
        }
        <span class="cov6" title="14">return operationTypePut</span>
}

func (cc *CopyCommand) checkCopyArgs(srcURLList []StorageURLer, destURL StorageURLer, opType operationType) error <span class="cov7" title="24">{
        for _, url := range srcURLList </span><span class="cov7" title="24">{
                if url.IsCloudURL() &amp;&amp; url.(CloudURL).bucket == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid cloud url: %s, miss bucket", url.ToString())
                }</span>
        }
        <span class="cov7" title="24">if destURL.IsCloudURL() &amp;&amp; destURL.(CloudURL).bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", destURL.ToString())
        }</span>

        <span class="cov7" title="24">switch opType </span>{
        case operationTypePut:<span class="cov6" title="14">
                if destURL.IsFileURL() </span><span class="cov0" title="0">{
                        return fmt.Errorf("copy files between local file system is not allowed in ossutil, if you want to upload to oss, please make sure dest_url starts with \"%s\",dest_url:%s", SchemePrefix, destURL.ToString())
                }</span>
                <span class="cov6" title="14">for _, url := range srcURLList </span><span class="cov6" title="14">{
                        if url.IsCloudURL() </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid url: %s, copy between oss operation appear in upload operation, multi-type operations is not supported in one command", url.ToString())
                        }</span>
                }
                <span class="cov6" title="14">if len(srcURLList) &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid url: %s, multiple source url in upload operation", srcURLList[1].ToString())
                }</span>
        case operationTypeGet:<span class="cov5" title="10">
                if len(srcURLList) &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid url: %s, multiple source url in download operation", srcURLList[1].ToString())
                }</span>
        default:<span class="cov0" title="0">
                if len(srcURLList) &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid url: %s, multiple source url in copy operation", srcURLList[1].ToString())
                }</span>
        }
        <span class="cov7" title="24">return nil</span>
}

func (cc *CopyCommand) checkCopyOptions(opType operationType) error <span class="cov7" title="24">{
        if operationTypeCopy == opType &amp;&amp; cc.cpOption.snapshotPath != "" </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("CopyObject doesn't support option --snapshot-path")
                return CommandError{cc.command.name, msg}
        }</span>
        <span class="cov7" title="24">if operationTypeGet != opType &amp;&amp; cc.cpOption.vrange != "" </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("only download support option --range")
                return CommandError{cc.command.name, msg}
        }</span>
        <span class="cov7" title="24">if cc.cpOption.versionId != "" </span><span class="cov0" title="0">{
                if operationTypePut == opType </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("upload doesn't support option --version-id")
                        return CommandError{cc.command.name, msg}
                }</span>
                <span class="cov0" title="0">if cc.cpOption.recursive </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("option --version-id can't be used with option -r")
                        return CommandError{cc.command.name, msg}
                }</span>
        }
        <span class="cov7" title="24">return nil</span>
}

func (cc *CopyCommand) progressBar() <span class="cov7" title="24">{
        // fetch all reveal
        for signal := range chProgressSignal </span><span class="cov4" title="5">{
                fmt.Printf(cc.monitor.progressBar(signal.finish, signal.exitStat))
        }</span>
}

func (cc *CopyCommand) closeProgress() <span class="cov6" title="20">{
        signalNum = -1
}</span>

//function for upload files
func (cc *CopyCommand) uploadFiles(srcURLList []StorageURLer, destURL CloudURL) error <span class="cov6" title="14">{
        if err := destURL.checkObjectPrefix(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="14">bucket, err := cc.command.ossBucket(destURL.bucket)
        if err != nil </span><span class="cov3" title="4">{
                return err
        }</span>

        //adjust oss prefix name
        <span class="cov5" title="10">destURL, err = cc.adjustDestURLForUpload(srcURLList, destURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // producer list files
        // consumer set acl
        <span class="cov5" title="10">chFiles := make(chan fileInfoType, ChannelBuf)
        chError := make(chan error, cc.cpOption.routines)
        chListError := make(chan error, 1)
        go cc.fileStatistic(srcURLList)
        go cc.fileProducer(srcURLList, chFiles, chListError)

        LogInfo("upload files,routin count:%d,multi part size threshold:%d\n",
                cc.cpOption.routines, cc.cpOption.threshold)
        for i := 0; int64(i) &lt; cc.cpOption.routines; i++ </span><span class="cov7" title="30">{
                go cc.uploadConsumer(bucket, destURL, chFiles, chError)
        }</span>

        <span class="cov5" title="10">completed := 0
        for int64(completed) &lt;= cc.cpOption.routines </span><span class="cov8" title="40">{
                select </span>{
                case err := &lt;-chListError:<span class="cov5" title="10">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov5" title="10">completed++</span>
                case err := &lt;-chError:<span class="cov7" title="30">
                        if err == nil </span><span class="cov7" title="30">{
                                completed++
                        }</span> else<span class="cov0" title="0"> {
                                if !cc.cpOption.ctnu </span><span class="cov0" title="0">{
                                        cc.closeProgress()
                                        fmt.Printf(cc.monitor.progressBar(true, errExit))
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov5" title="10">cc.closeProgress()
        fmt.Printf(cc.monitor.progressBar(true, normalExit))
        return nil</span>
}

func (cc *CopyCommand) adjustDestURLForUpload(srcURLList []StorageURLer, destURL CloudURL) (CloudURL, error) <span class="cov5" title="10">{
        includeDir := false
        for _, srcURL := range srcURLList </span><span class="cov5" title="10">{
                stat, err := os.Stat(srcURL.ToString())
                if err != nil </span><span class="cov0" title="0">{
                        return destURL, err
                }</span>
                <span class="cov5" title="10">if stat.IsDir() </span><span class="cov0" title="0">{
                        includeDir = true
                }</span>
        }

        <span class="cov5" title="10">if includeDir &amp;&amp; !cc.cpOption.recursive </span><span class="cov0" title="0">{
                return destURL, fmt.Errorf("source URL:%v include directories, please use --recursive option", srcURLList)
        }</span>

        // if upload files from multi paths or is directory, the dest object should has suffix with "/"
        <span class="cov5" title="10">if includeDir || len(srcURLList) &gt; 1 </span><span class="cov0" title="0">{
                if destURL.object != "" &amp;&amp; !strings.HasSuffix(destURL.object, "/") </span><span class="cov0" title="0">{
                        destURL.object += "/"
                }</span>
        }

        <span class="cov5" title="10">return destURL, nil</span>
}

func (cc *CopyCommand) fileStatistic(srcURLList []StorageURLer) <span class="cov5" title="10">{
        for _, url := range srcURLList </span><span class="cov5" title="10">{
                name := url.ToString()
                f, err := os.Stat(name)
                if err != nil </span><span class="cov0" title="0">{
                        cc.monitor.setScanError(err)
                        return
                }</span>
                <span class="cov5" title="10">if f.IsDir() </span><span class="cov0" title="0">{
                        if !strings.HasSuffix(name, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                                // for link directory
                                name += string(os.PathSeparator)
                        }</span>

                        <span class="cov0" title="0">err := cc.getFileListStatistic(name)
                        if err != nil </span><span class="cov0" title="0">{
                                cc.monitor.setScanError(err)
                                return
                        }</span>
                } else<span class="cov5" title="10"> {
                        if cc.filterPath(name, cc.cpOption.cpDir) </span><span class="cov5" title="10">{
                                cc.monitor.updateScanSizeNum(f.Size(), 1)
                        }</span>
                }
        }

        <span class="cov5" title="10">cc.monitor.setScanEnd()
        freshProgress()</span>
}

func (cc *CopyCommand) getCurrentDirFilesStatistic(dpath string) error <span class="cov0" title="0">{
        if !strings.HasSuffix(dpath, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                dpath += string(os.PathSeparator)
        }</span>

        <span class="cov0" title="0">fileList, err := ioutil.ReadDir(dpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, fileInfo := range fileList </span><span class="cov0" title="0">{
                if !fileInfo.IsDir() </span><span class="cov0" title="0">{
                        realInfo, errF := os.Stat(dpath + fileInfo.Name())
                        if errF == nil &amp;&amp; realInfo.IsDir() </span><span class="cov0" title="0">{
                                // for symlink
                                continue</span>
                        }

                        <span class="cov0" title="0">if doesSingleFileMatchPatterns(fileInfo.Name(), cc.cpOption.filters) </span><span class="cov0" title="0">{
                                cc.monitor.updateScanSizeNum(fileInfo.Size(), 1)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (cc *CopyCommand) getFileListStatistic(dpath string) error <span class="cov0" title="0">{
        if cc.cpOption.onlyCurrentDir </span><span class="cov0" title="0">{
                return cc.getCurrentDirFilesStatistic(dpath)
        }</span>

        <span class="cov0" title="0">name := dpath
        symlinkDiretorys := []string{dpath}
        walkFunc := func(fpath string, f os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if f == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !cc.filterPath(fpath, cc.cpOption.cpDir) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">realFileSize := f.Size()
                dpath = filepath.Clean(dpath)
                fpath = filepath.Clean(fpath)
                fileName, err := filepath.Rel(dpath, fpath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("list file error: %s, info: %s", fpath, err.Error())
                }</span>

                <span class="cov0" title="0">if f.IsDir() </span><span class="cov0" title="0">{
                        if fpath != dpath </span><span class="cov0" title="0">{
                                cc.monitor.updateScanNum(1)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if cc.cpOption.disableAllSymlink &amp;&amp; (f.Mode()&amp;os.ModeSymlink) != 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // link file or link dir
                <span class="cov0" title="0">if f.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov0" title="0">{
                        // there is difference between os.Stat and os.Lstat in filepath.Walk
                        realInfo, err := os.Stat(fpath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if realInfo.IsDir() </span><span class="cov0" title="0">{
                                realFileSize = 0
                        }</span> else<span class="cov0" title="0"> {
                                realFileSize = realInfo.Size()
                        }</span>

                        <span class="cov0" title="0">if cc.cpOption.enableSymlinkDir &amp;&amp; realInfo.IsDir() </span><span class="cov0" title="0">{
                                // it's symlink dir
                                // if linkDir has suffix os.PathSeparator,os.Lstat determine it is a dir
                                if !strings.HasSuffix(name, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                                        name += string(os.PathSeparator)
                                }</span>
                                <span class="cov0" title="0">linkDir := name + fileName + string(os.PathSeparator)
                                symlinkDiretorys = append(symlinkDiretorys, linkDir)
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">if doesSingleFileMatchPatterns(f.Name(), cc.cpOption.filters) </span><span class="cov0" title="0">{
                        cc.monitor.updateScanSizeNum(realFileSize, 1)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">var err error
        for </span><span class="cov0" title="0">{
                symlinks := symlinkDiretorys
                symlinkDiretorys = []string{}
                for _, v := range symlinks </span><span class="cov0" title="0">{
                        err = filepath.Walk(v, walkFunc)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if len(symlinkDiretorys) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func (cc *CopyCommand) fileProducer(srcURLList []StorageURLer, chFiles chan&lt;- fileInfoType, chListError chan&lt;- error) <span class="cov5" title="10">{
        for _, url := range srcURLList </span><span class="cov5" title="10">{
                name := url.ToString()
                f, err := os.Stat(name)
                if err != nil </span><span class="cov0" title="0">{
                        chListError &lt;- err
                        return
                }</span>
                <span class="cov5" title="10">if f.IsDir() </span><span class="cov0" title="0">{
                        if !strings.HasSuffix(name, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                                // for link directory
                                name += string(os.PathSeparator)
                        }</span>

                        <span class="cov0" title="0">err := cc.getFileList(name, chFiles)
                        if err != nil </span><span class="cov0" title="0">{
                                chListError &lt;- err
                                return
                        }</span>
                } else<span class="cov5" title="10"> {
                        dir, fname := filepath.Split(name)
                        chFiles &lt;- fileInfoType{fname, dir}
                }</span>
        }

        <span class="cov5" title="10">defer close(chFiles)
        chListError &lt;- nil</span>
}

func (cc *CopyCommand) getCurrentDirFileList(dpath string, chFiles chan&lt;- fileInfoType) error <span class="cov0" title="0">{
        if !strings.HasSuffix(dpath, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                dpath += string(os.PathSeparator)
        }</span>

        <span class="cov0" title="0">fileList, err := ioutil.ReadDir(dpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, fileInfo := range fileList </span><span class="cov0" title="0">{
                if !fileInfo.IsDir() </span><span class="cov0" title="0">{
                        realInfo, errF := os.Stat(dpath + fileInfo.Name())
                        if errF == nil &amp;&amp; realInfo.IsDir() </span><span class="cov0" title="0">{
                                // for symlink
                                continue</span>
                        }

                        <span class="cov0" title="0">if doesSingleFileMatchPatterns(fileInfo.Name(), cc.cpOption.filters) </span><span class="cov0" title="0">{
                                chFiles &lt;- fileInfoType{fileInfo.Name(), dpath}
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (cc *CopyCommand) getFileList(dpath string, chFiles chan&lt;- fileInfoType) error <span class="cov0" title="0">{
        if cc.cpOption.onlyCurrentDir </span><span class="cov0" title="0">{
                return cc.getCurrentDirFileList(dpath, chFiles)
        }</span>

        <span class="cov0" title="0">name := dpath
        symlinkDiretorys := []string{dpath}
        walkFunc := func(fpath string, f os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if f == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dpath = filepath.Clean(dpath)
                fpath = filepath.Clean(fpath)

                fileName, err := filepath.Rel(dpath, fpath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("list file error: %s, info: %s", fpath, err.Error())
                }</span>

                <span class="cov0" title="0">if f.IsDir() </span><span class="cov0" title="0">{
                        if fpath != dpath </span><span class="cov0" title="0">{
                                if strings.HasSuffix(fileName, "\\") || strings.HasSuffix(fileName, "/") </span><span class="cov0" title="0">{
                                        chFiles &lt;- fileInfoType{fileName, name}
                                }</span> else<span class="cov0" title="0"> {
                                        chFiles &lt;- fileInfoType{fileName + string(os.PathSeparator), name}
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if cc.cpOption.disableAllSymlink &amp;&amp; (f.Mode()&amp;os.ModeSymlink) != 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if cc.cpOption.enableSymlinkDir &amp;&amp; (f.Mode()&amp;os.ModeSymlink) != 0 </span><span class="cov0" title="0">{
                        // there is difference between os.Stat and os.Lstat in filepath.Walk
                        realInfo, err := os.Stat(fpath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if realInfo.IsDir() </span><span class="cov0" title="0">{
                                // it's symlink dir
                                // if linkDir has suffix os.PathSeparator,os.Lstat determine it is a dir
                                if !strings.HasSuffix(name, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                                        name += string(os.PathSeparator)
                                }</span>
                                <span class="cov0" title="0">linkDir := name + fileName + string(os.PathSeparator)
                                symlinkDiretorys = append(symlinkDiretorys, linkDir)
                                return nil</span>
                        }
                }

                <span class="cov0" title="0">if doesSingleFileMatchPatterns(fileName, cc.cpOption.filters) </span><span class="cov0" title="0">{
                        chFiles &lt;- fileInfoType{fileName, name}
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">var err error
        for </span><span class="cov0" title="0">{
                symlinks := symlinkDiretorys
                symlinkDiretorys = []string{}
                for _, v := range symlinks </span><span class="cov0" title="0">{
                        err = filepath.Walk(v, walkFunc)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if len(symlinkDiretorys) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func (cc *CopyCommand) uploadConsumer(bucket *oss.Bucket, destURL CloudURL, chFiles &lt;-chan fileInfoType, chError chan&lt;- error) <span class="cov7" title="30">{
        for file := range chFiles </span><span class="cov5" title="10">{
                if cc.filterFile(file, cc.cpOption.cpDir) </span><span class="cov5" title="10">{
                        err := cc.uploadFileWithReport(bucket, destURL, file)
                        if err != nil </span><span class="cov0" title="0">{
                                chError &lt;- err
                                if !cc.cpOption.ctnu </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                }
        }

        <span class="cov7" title="30">chError &lt;- nil</span>
}

func (cc *CopyCommand) filterFile(file fileInfoType, cpDir string) bool <span class="cov5" title="10">{
        filePath := file.filePath
        if file.dir != "" </span><span class="cov0" title="0">{
                if strings.HasSuffix(file.dir, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                        filePath = file.dir + file.filePath
                }</span> else<span class="cov0" title="0"> {
                        filePath = file.dir + string(os.PathSeparator) + file.filePath
                }</span>
        }
        <span class="cov5" title="10">return cc.filterPath(filePath, cpDir)</span>
}

func (cc *CopyCommand) filterPath(filePath string, cpDir string) bool <span class="cov6" title="20">{
        if !strings.Contains(filePath, cpDir) </span><span class="cov6" title="20">{
                return true
        }</span>
        <span class="cov0" title="0">absFile, _ := filepath.Abs(filePath)
        absCPDir, _ := filepath.Abs(cpDir)
        return !strings.Contains(absFile, absCPDir)</span>
}

func (cc *CopyCommand) uploadFileWithReport(bucket *oss.Bucket, destURL CloudURL, file fileInfoType) error <span class="cov5" title="10">{
        startT := time.Now()
        skip, err, isDir, size, msg := cc.uploadFile(bucket, destURL, file)
        cost := time.Now().UnixNano()/1000/1000 - startT.UnixNano()/1000/1000

        if err != nil </span><span class="cov0" title="0">{
                LogError("upload file error,file:%s,cost:%d(ms),error info:%s\n", file.filePath, cost, err.Error())
        }</span> else<span class="cov5" title="10"> if skip </span><span class="cov0" title="0">{
                LogInfo("upload file skip:%s\n", file.filePath)
        }</span> else<span class="cov5" title="10"> {
                if file.dir == "" </span><span class="cov5" title="10">{
                        // fix panic
                        file.dir = "."
                }</span>
                <span class="cov5" title="10">absPath := file.dir + string(os.PathSeparator) + file.filePath
                fileInfo, errF := os.Stat(absPath)
                speed := 0.0
                if cost &gt; 0 &amp;&amp; errF == nil </span><span class="cov5" title="10">{
                        speed = (float64(fileInfo.Size()) / 1024) / (float64(cost) / 1000)
                }</span>
                <span class="cov5" title="10">if errF == nil </span><span class="cov5" title="10">{
                        LogInfo("upload file success,file:%s,size:%d,speed:%.2f(KB/s),cost:%d(ms)\n", file.filePath, fileInfo.Size(), speed, cost)
                }</span>
        }

        <span class="cov5" title="10">cc.updateMonitor(skip, err, isDir, size)
        cc.report(msg, err)
        return err</span>
}

func (cc *CopyCommand) uploadFile(bucket *oss.Bucket, destURL CloudURL, file fileInfoType) (skip bool, rerr error, isDir bool, size int64, msg string) <span class="cov5" title="10">{
        //first make object name
        objectName := cc.makeObjectName(destURL, file)

        filePath := file.filePath
        filePath = filepath.Join(file.dir, filePath)

        skip = false
        rerr = nil
        isDir = false
        size = 0 // the size update to monitor
        msg = fmt.Sprintf("%s %s to %s", opUpload, filePath, CloudURLToString(bucket.BucketName, objectName))

        //get file size and last modify time
        f, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                rerr = err
                return
        }</span>

        <span class="cov5" title="10">if !f.IsDir() </span><span class="cov5" title="10">{
                size = f.Size()
        }</span>

        <span class="cov5" title="10">srct := f.ModTime().Unix()
        absPath, _ := filepath.Abs(filePath)
        spath := cc.formatSnapshotKey(absPath, destURL.bucket, objectName)
        if skip, rerr = cc.skipUpload(spath, bucket, objectName, destURL, srct); rerr != nil || skip </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="10">skip = false
        if f.IsDir() </span><span class="cov0" title="0">{
                isDir = true
                if cc.cpOption.disableDirObject </span><span class="cov0" title="0">{
                        skip = true
                        return
                }</span>
                <span class="cov0" title="0">rerr = cc.ossPutObjectRetry(bucket, objectName, "")
                if err := cc.updateSnapshot(rerr, spath, srct); err != nil </span><span class="cov0" title="0">{
                        rerr = err
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov5" title="10">size = 0
        //decide whether to use resume upload
        if f.Size() &lt; cc.cpOption.threshold </span><span class="cov0" title="0">{
                var listener *OssProgressListener = &amp;OssProgressListener{&amp;cc.monitor, 0, 0, false}
                options := cc.cpOption.options
                options = append(options, oss.Progress(listener))
                rerr = cc.ossUploadFileRetry(bucket, objectName, filePath, options...)
                if err := cc.updateSnapshot(rerr, spath, srct); err != nil </span><span class="cov0" title="0">{
                        rerr = err
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov5" title="10">var listener *OssResumeProgressListener = &amp;OssResumeProgressListener{&amp;cc.monitor, 0, 0, false, false}

        //make options for resume multipart upload
        //part size
        partSize, rt := cc.preparePartOption(f.Size())
        LogInfo("multipart upload,file:%s,file size:%d,partSize:%d,routin count:%d\n",
                filePath, f.Size(), partSize, rt)
        cp := oss.CheckpointDir(true, cc.cpOption.cpDir)
        options := cc.cpOption.options
        options = append(options, oss.Routines(rt), cp, oss.Progress(listener))
        rerr = cc.ossResumeUploadRetry(bucket, objectName, filePath, partSize, options...)
        if err := cc.updateSnapshot(rerr, spath, srct); err != nil </span><span class="cov0" title="0">{
                rerr = err
        }</span>
        <span class="cov5" title="10">return</span>
}

func (cc *CopyCommand) makeObjectName(destURL CloudURL, file fileInfoType) string <span class="cov5" title="10">{
        if destURL.object == "" || strings.HasSuffix(destURL.object, "/") </span><span class="cov0" title="0">{
                // replace "\" of file.filePath to "/"
                filePath := file.filePath
                filePath = strings.Replace(file.filePath, string(os.PathSeparator), "/", -1)
                filePath = strings.Replace(file.filePath, "\\", "/", -1)
                return destURL.object + filePath
        }</span>
        <span class="cov5" title="10">return destURL.object</span>
}

func (cc *CopyCommand) skipUpload(spath string, bucket *oss.Bucket, objectName string, destURL CloudURL, srcModifiedTime int64) (bool, error) <span class="cov5" title="10">{
        if cc.cpOption.snapshotPath != "" || cc.cpOption.update </span><span class="cov0" title="0">{
                if cc.cpOption.snapshotPath != "" </span><span class="cov0" title="0">{
                        tstr, err := cc.cpOption.snapshotldb.Get([]byte(spath), nil)
                        if err == nil </span><span class="cov0" title="0">{
                                t, _ := strconv.ParseInt(string(tstr), 10, 64)
                                if t == srcModifiedTime </span><span class="cov0" title="0">{
                                        return true, nil
                                }</span>
                        }
                }
                <span class="cov0" title="0">if cc.cpOption.update </span><span class="cov0" title="0">{
                        if props, err := cc.command.ossGetObjectStatRetry(bucket, objectName, cc.cpOption.payerOptions...); err == nil </span><span class="cov0" title="0">{
                                destt, err := time.Parse(http.TimeFormat, props.Get(oss.HTTPHeaderLastModified))
                                if err == nil &amp;&amp; destt.Unix() &gt;= srcModifiedTime </span><span class="cov0" title="0">{
                                        return true, nil
                                }</span>
                        }
                }
        } else<span class="cov5" title="10"> if !cc.cpOption.force </span><span class="cov5" title="10">{
                if _, err := cc.command.ossGetObjectMetaRetry(bucket, objectName, cc.cpOption.payerOptions...); err == nil </span><span class="cov0" title="0">{
                        if !cc.confirm(CloudURLToString(destURL.bucket, objectName)) </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
        }
        <span class="cov5" title="10">return false, nil</span>
}

func (cc *CopyCommand) formatSnapshotKey(absPath, bucket, object string) string <span class="cov5" title="10">{
        return absPath + SnapshotConnector + CloudURLToString(bucket, object)
}</span>

func (cc *CopyCommand) confirm(str string) bool <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()

        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("cp: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (cc *CopyCommand) ossPutObjectRetry(bucket *oss.Bucket, objectName string, content string) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, cc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                if i &gt; 1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(3) * time.Second)
                        if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                                fmt.Printf("\nretry count:%d:put object:%s.\n", i-1, objectName)
                        }</span>
                }

                <span class="cov0" title="0">err := bucket.PutObject(objectName, strings.NewReader(content), cc.cpOption.options...)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov0" title="0">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, objectName}
                }</span>
        }
}

func (cc *CopyCommand) ossUploadFileRetry(bucket *oss.Bucket, objectName string, filePath string, options ...oss.Option) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, cc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                if i &gt; 1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(3) * time.Second)
                        if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                                fmt.Printf("\nretry count:%d:upload file:%s\n", i-1, filePath)
                        }</span>
                }

                <span class="cov0" title="0">startT := time.Now()
                err := bucket.PutObjectFromFile(objectName, filePath, options...)
                cost := time.Now().UnixNano()/1000/1000 - startT.UnixNano()/1000/1000

                if err == nil </span><span class="cov0" title="0">{
                        LogDebug("try count:%d,upload file sucess %s,cost:%d(ms)\n", i, filePath, cost)
                        return err
                }</span> else<span class="cov0" title="0"> {
                        LogError("try count:%d,upload file error %s,cost:%d(ms),error:%s\n", i, filePath, cost, err.Error())
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov0" title="0">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                        return FileError{err, filePath}
                }</span>
        }
}

func (cc *CopyCommand) preparePartOption(fileSize int64) (int64, int) <span class="cov6" title="20">{
        partSize, _ := GetInt(OptionPartSize, cc.command.options)
        var partNum int64
        if partSize &lt; MinPartSize </span><span class="cov6" title="20">{
                partSize, partNum = cc.calcPartSize(fileSize)
        }</span> else<span class="cov0" title="0"> {
                partNum = (fileSize-1)/partSize + 1
        }</span>

        <span class="cov6" title="20">if parallel, err := GetInt(OptionParallel, cc.command.options); err == nil </span><span class="cov0" title="0">{
                return partSize, int(parallel)
        }</span>

        <span class="cov6" title="20">var rt int
        if partNum &lt; 2 </span><span class="cov6" title="20">{
                rt = 1
        }</span> else<span class="cov0" title="0"> if partNum &lt; 4 </span><span class="cov0" title="0">{
                rt = 2
        }</span> else<span class="cov0" title="0"> if partNum &lt;= 20 </span><span class="cov0" title="0">{
                rt = 4
        }</span> else<span class="cov0" title="0"> if partNum &lt;= 300 </span><span class="cov0" title="0">{
                rt = 8
        }</span> else<span class="cov0" title="0"> if partNum &lt;= 500 </span><span class="cov0" title="0">{
                rt = 10
        }</span> else<span class="cov0" title="0"> {
                rt = 12
        }</span>

        <span class="cov6" title="20">return partSize, rt</span>
}

func (cc *CopyCommand) calcPartSize(fileSize int64) (int64, int64) <span class="cov6" title="20">{
        partSize := int64(math.Ceil(float64(fileSize) / float64(MaxPartNum)))
        if partSize &lt; oss.MinPartSize </span><span class="cov6" title="20">{
                partSize = oss.MinPartSize
        }</span>
        <span class="cov6" title="20">partNum := (fileSize-1)/partSize + 1

        for partNum &gt; MaxIdealPartNum &amp;&amp; partSize &lt; MaxIdealPartSize </span><span class="cov0" title="0">{
                partNum /= 5
                partSize = int64(math.Ceil(float64(fileSize) / float64(partNum)))
        }</span>

        <span class="cov6" title="20">for partSize &lt; MinIdealPartSize &amp;&amp; partNum &gt; MinIdealPartNum </span><span class="cov0" title="0">{
                partSize *= 5
                partNum = (fileSize-1)/partSize + 1
        }</span>

        <span class="cov6" title="20">return partSize, partNum</span>
}

func (cc *CopyCommand) ossResumeUploadRetry(bucket *oss.Bucket, objectName string, filePath string, partSize int64, options ...oss.Option) error <span class="cov5" title="10">{
        retryTimes, _ := GetInt(OptionRetryTimes, cc.command.options)
        for i := 1; ; i++ </span><span class="cov5" title="10">{
                if i &gt; 1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(3) * time.Second)
                        if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                                fmt.Printf("\nretry count:%d,multipart upload file:%s.\n", i-1, filePath)
                        }</span>
                }
                <span class="cov5" title="10">startT := time.Now()
                err := bucket.UploadFile(objectName, filePath, partSize, options...)
                cost := time.Now().UnixNano()/1000/1000 - startT.UnixNano()/1000/1000

                if err == nil </span><span class="cov5" title="10">{
                        LogDebug("try count:%d,multipart upload file sucess %s,cost:%d(ms)\n", i, filePath, cost)
                        return err
                }</span> else<span class="cov0" title="0"> {
                        LogError("try count:%d,multipart upload file error %s,cost:%d(ms),error:%s\n", i, filePath, cost, err.Error())
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return FileError{err, filePath}
                }</span>
        }
}

func (cc *CopyCommand) report(msg string, err error) <span class="cov6" title="20">{
        if cc.filterError(err) </span><span class="cov0" title="0">{
                cc.cpOption.reporter.ReportError(fmt.Sprintf("%s error, info: %s", msg, err.Error()))
                cc.cpOption.reporter.Prompt(err)
        }</span>
}

func (cc *CopyCommand) updateMonitor(skip bool, err error, isDir bool, size int64) <span class="cov6" title="20">{
        if err != nil </span><span class="cov0" title="0">{
                cc.monitor.updateErr(0, 1)
        }</span> else<span class="cov6" title="20"> if skip </span><span class="cov0" title="0">{
                if !isDir </span><span class="cov0" title="0">{
                        cc.monitor.updateSkip(size, 1)
                }</span> else<span class="cov0" title="0"> {
                        cc.monitor.updateSkipDir(1)
                }</span>
        } else<span class="cov6" title="20"> if isDir </span><span class="cov0" title="0">{
                cc.monitor.updateDir(size, 1)
        }</span> else<span class="cov6" title="20"> {
                cc.monitor.updateFile(size, 1)
        }</span>
        <span class="cov6" title="20">freshProgress()</span>
}

func (cc *CopyCommand) filterError(err error) bool <span class="cov6" title="20">{
        if err == nil </span><span class="cov6" title="20">{
                return false
        }</span>

        <span class="cov0" title="0">switch err.(type) </span>{
        case FileError:<span class="cov0" title="0">
                err = err.(FileError).err</span>
        case ObjectError:<span class="cov0" title="0">
                err = err.(ObjectError).err</span>
        case BucketError:<span class="cov0" title="0">
                err = err.(BucketError).err</span>
        }

        <span class="cov0" title="0">switch err.(type) </span>{
        case oss.ServiceError:<span class="cov0" title="0">
                code := err.(oss.ServiceError).Code
                if code == "NoSuchBucket" || code == "InvalidAccessKeyId" || code == "SignatureDoesNotMatch" || code == "AccessDenied" || code == "RequestTimeTooSkewed" || code == "InvalidBucketName" </span><span class="cov0" title="0">{
                        cc.cpOption.ctnu = false
                        return false
                }</span>
        case CopyError:<span class="cov0" title="0">
                cc.cpOption.ctnu = false
                return false</span>
        }
        <span class="cov0" title="0">return true</span>
}

//function for download files
func (cc *CopyCommand) downloadFiles(srcURL CloudURL, destURL FileURL) error <span class="cov5" title="10">{
        bucket, err := cc.command.ossBucket(srcURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="10">filePath, err := cc.adjustDestURLForDownload(destURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="10">LogInfo("downloadFiles,recursive flag:%t\n", cc.cpOption.recursive)
        if !cc.cpOption.recursive </span><span class="cov5" title="10">{
                if srcURL.object == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("copy object invalid url: %v, object empty. If you mean batch copy objects, please use --recursive option", srcURL.ToString())
                }</span>

                // it is a "Dir" object
                <span class="cov5" title="10">if strings.HasSuffix(srcURL.object, "/") </span><span class="cov0" title="0">{
                        return fmt.Errorf("%v is a directory (not support copied) object, please use --recursive option", srcURL.object)
                }</span>

                <span class="cov5" title="10">index := strings.LastIndex(srcURL.object, "/")
                prefix := ""
                relativeKey := srcURL.object
                if index &gt; 0 </span><span class="cov0" title="0">{
                        prefix = srcURL.object[:index+1]
                        relativeKey = srcURL.object[index+1:]
                }</span>

                <span class="cov5" title="10">go cc.objectStatistic(bucket, srcURL)
                err := cc.downloadSingleFileWithReport(bucket, objectInfoType{prefix, relativeKey, -1, time.Now()}, filePath)
                return cc.formatResultPrompt(err)</span>
        }
        <span class="cov0" title="0">return cc.batchDownloadFiles(bucket, srcURL, filePath)</span>
}

func (cc *CopyCommand) formatResultPrompt(err error) error <span class="cov5" title="10">{
        cc.closeProgress()
        fmt.Printf(cc.monitor.progressBar(true, normalExit))
        if err != nil &amp;&amp; cc.cpOption.ctnu </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="10">return err</span>
}

func (cc *CopyCommand) adjustSrcURLForCommand(srcURL *CloudURL, bSyncCommand bool) <span class="cov0" title="0">{
        if !bSyncCommand </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if len(srcURL.object) &gt; 0 &amp;&amp; !strings.HasSuffix(srcURL.object, "/") </span><span class="cov0" title="0">{
                srcURL.object += "/"
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cc *CopyCommand) adjustDestURLForDownload(destURL FileURL) (string, error) <span class="cov5" title="10">{
        filePath := destURL.ToString()

        isDir := false
        if f, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                isDir = f.IsDir()
        }</span>

        <span class="cov5" title="10">if !strings.HasSuffix(filePath, "/") &amp;&amp; !strings.HasSuffix(filePath, "\\") </span><span class="cov5" title="10">{
                if cc.cpOption.recursive || isDir </span><span class="cov0" title="0">{
                        filePath += "/"
                }</span>
        }

        <span class="cov5" title="10">if strings.HasSuffix(filePath, "/") || strings.HasSuffix(filePath, "\\") </span><span class="cov0" title="0">{
                if err := os.MkdirAll(filePath, 0755); err != nil </span><span class="cov0" title="0">{
                        return filePath, err
                }</span>
        }
        <span class="cov5" title="10">return filePath, nil</span>
}

func (cc *CopyCommand) downloadSingleFileWithReport(bucket *oss.Bucket, objectInfo objectInfoType, filePath string) error <span class="cov5" title="10">{
        startT := time.Now()
        skip, err, size, msg := cc.downloadSingleFile(bucket, objectInfo, filePath)
        cost := time.Now().UnixNano()/1000/1000 - startT.UnixNano()/1000/1000
        var realSize int64 = objectInfo.size
        if err != nil </span><span class="cov0" title="0">{
                LogError("download error,file:%s,cost:%d(ms),error info:%s\n", objectInfo.relativeKey, cost, err.Error())
        }</span> else<span class="cov5" title="10"> if skip </span><span class="cov0" title="0">{
                LogInfo("download skip:%s\n", objectInfo.relativeKey)
        }</span> else<span class="cov5" title="10"> {
                if realSize &lt; 0 &amp;&amp; logLevel &gt;= oss.Info </span><span class="cov0" title="0">{
                        fileName := cc.makeFileName(objectInfo.relativeKey, filePath)
                        fileInfo, errF := os.Stat(fileName)
                        if errF == nil &amp;&amp; !fileInfo.IsDir() </span><span class="cov0" title="0">{
                                realSize = fileInfo.Size()
                        }</span>
                }

                <span class="cov5" title="10">speed := 0.0
                if cost &gt; 0 </span><span class="cov5" title="10">{
                        speed = (float64(realSize) / 1024) / (float64(cost) / 1000)
                }</span>
                <span class="cov5" title="10">objectKey := objectInfo.prefix + objectInfo.relativeKey
                LogInfo("download success,object:%s,size:%d,speed:%.2f(KB/s),cost:%d(ms)\n", objectKey, realSize, speed, cost)
                cc.updateSnapshot(nil, CloudURLToString(bucket.BucketName, objectKey), objectInfo.lastModified.Unix())</span>
        }

        <span class="cov5" title="10">cc.updateMonitor(skip, err, false, size)
        cc.report(msg, err)
        return err</span>
}

func (cc *CopyCommand) downloadSingleFile(bucket *oss.Bucket, objectInfo objectInfoType, filePath string) (bool, error, int64, string) <span class="cov5" title="10">{
        //get object size and last modify time
        object := objectInfo.prefix + objectInfo.relativeKey
        size := objectInfo.size
        srct := objectInfo.lastModified
        //make file name
        fileName := cc.makeFileName(objectInfo.relativeKey, filePath)
        msg := fmt.Sprintf("%s %s to %s", opDownload, CloudURLToString(bucket.BucketName, object), fileName)

        if size &lt; 0 </span><span class="cov5" title="10">{
                statOptions := cc.cpOption.payerOptions
                if cc.cpOption.versionId != "" </span><span class="cov0" title="0">{
                        statOptions = append(statOptions, oss.VersionId(cc.cpOption.versionId))
                }</span>
                <span class="cov5" title="10">props, err := cc.command.ossGetObjectStatRetry(bucket, object, statOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err, size, msg
                }</span>
                <span class="cov5" title="10">size, err = strconv.ParseInt(props.Get(oss.HTTPHeaderContentLength), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err, size, msg
                }</span>
                <span class="cov5" title="10">if srct, err = time.Parse(http.TimeFormat, props.Get(oss.HTTPHeaderLastModified)); err != nil </span><span class="cov0" title="0">{
                        return false, err, size, msg
                }</span>
        }

        <span class="cov5" title="10">rsize := cc.getRangeSize(size)
        if cc.skipDownload(fileName, srct, CloudURLToString(bucket.BucketName, object)) </span><span class="cov0" title="0">{
                return true, nil, rsize, msg
        }</span>

        <span class="cov5" title="10">if size == 0 &amp;&amp; strings.HasSuffix(object, "/") </span><span class="cov0" title="0">{
                return false, os.MkdirAll(fileName, 0755), rsize, msg
        }</span>

        //create parent directory
        <span class="cov5" title="10">if err := cc.createParentDirectory(fileName); err != nil </span><span class="cov0" title="0">{
                return false, err, rsize, msg
        }</span>

        <span class="cov5" title="10">downloadOptions := cc.cpOption.options
        if cc.cpOption.vrange != "" </span><span class="cov0" title="0">{
                downloadOptions = append(downloadOptions, oss.NormalizedRange(cc.cpOption.vrange))
        }</span>

        <span class="cov5" title="10">if rsize &lt; cc.cpOption.threshold </span><span class="cov0" title="0">{
                var listener *OssProgressListener = &amp;OssProgressListener{&amp;cc.monitor, 0, 0, false}
                downloadOptions = append(downloadOptions, oss.Progress(listener))
                return false, cc.ossDownloadFileRetry(bucket, object, fileName, downloadOptions...), 0, msg
        }</span>

        <span class="cov5" title="10">var listener *OssResumeProgressListener = &amp;OssResumeProgressListener{&amp;cc.monitor, 0, 0, false, false}
        downloadOptions = append(downloadOptions, oss.Progress(listener))

        partSize, rt := cc.preparePartOption(size)
        cp := oss.CheckpointDir(true, cc.cpOption.cpDir)
        LogInfo("multipart download,object %s,file size:%d,partSize %d,routin count:%d,checkpoint dir:%s\n",
                object, size, partSize, rt, cc.cpOption.cpDir)
        downloadOptions = append(downloadOptions, oss.Routines(rt), cp)
        return false, cc.ossResumeDownloadRetry(bucket, object, fileName, size, partSize, downloadOptions...), 0, msg</span>
}

func (cc *CopyCommand) makeFileName(relativeObject, filePath string) string <span class="cov5" title="10">{
        if strings.HasSuffix(filePath, "/") || strings.HasSuffix(filePath, "\\") </span><span class="cov0" title="0">{
                return filePath + relativeObject
        }</span>
        <span class="cov5" title="10">return filePath</span>
}

func (cc *CopyCommand) skipDownload(fileName string, srcModifiedTime time.Time, object string) bool <span class="cov5" title="10">{
        if cc.cpOption.snapshotPath != "" || cc.cpOption.update </span><span class="cov0" title="0">{
                if cc.cpOption.snapshotPath != "" </span><span class="cov0" title="0">{
                        tstr, err := cc.cpOption.snapshotldb.Get([]byte(object), nil)
                        if err == nil </span><span class="cov0" title="0">{
                                t, _ := strconv.ParseInt(string(tstr), 10, 64)
                                if t == srcModifiedTime.Unix() </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }

                <span class="cov0" title="0">if f, err := os.Stat(fileName); err == nil </span><span class="cov0" title="0">{
                        destt := f.ModTime()
                        if destt.Unix() &gt;= srcModifiedTime.Unix() </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        } else<span class="cov5" title="10"> {
                if !cc.cpOption.force </span><span class="cov5" title="10">{
                        if fileInfo, err := os.Stat(fileName); err == nil </span><span class="cov0" title="0">{
                                if fileInfo.IsDir() || !cc.confirm(fileName) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov5" title="10">return false</span>
}

func (cc *CopyCommand) createParentDirectory(fileName string) error <span class="cov5" title="10">{
        dir, err := filepath.Abs(filepath.Dir(fileName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="10">dir = strings.Replace(dir, "\\", "/", -1)
        return os.MkdirAll(dir, 0755)</span>
}

func (cc *CopyCommand) ossDownloadFileRetry(bucket *oss.Bucket, objectName, fileName string, options ...oss.Option) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, cc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                if i &gt; 1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(3) * time.Second)
                        if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                                fmt.Printf("\nretry count:%d:get object to file:%s.\n", i-1, fileName)
                        }</span>
                }

                <span class="cov0" title="0">startT := time.Now()
                err := bucket.GetObjectToFile(objectName, fileName, options...)
                cost := time.Now().UnixNano()/1000/1000 - startT.UnixNano()/1000/1000

                if err == nil </span><span class="cov0" title="0">{
                        LogDebug("try count:%d,GetObjectToFile sucess %s,cost:%d(ms)\n", i, fileName, cost)
                        return err
                }</span> else<span class="cov0" title="0"> {
                        LogError("try count:%d,GetObjectToFile error %s,cost:%d(ms),error:%s\n", i, fileName, cost, err.Error())
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov0" title="0">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, objectName}
                }</span>
        }
}

func (cc *CopyCommand) ossResumeDownloadRetry(bucket *oss.Bucket, objectName string, filePath string, size, partSize int64, options ...oss.Option) error <span class="cov5" title="10">{
        retryTimes, _ := GetInt(OptionRetryTimes, cc.command.options)
        for i := 1; ; i++ </span><span class="cov5" title="10">{
                if i &gt; 1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(3) * time.Second)
                        if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                                fmt.Printf("\nretry count:%d:mulitpart download file:%s.\n", i-1, objectName)
                        }</span>
                }

                <span class="cov5" title="10">err := bucket.DownloadFile(objectName, filePath, partSize, options...)
                if err == nil </span><span class="cov5" title="10">{
                        return cc.truncateFile(filePath, size)
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, objectName}
                }</span>
        }
}

func (cc *CopyCommand) truncateFile(filePath string, size int64) error <span class="cov5" title="10">{
        f, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="10">if f.Size() &gt; size </span><span class="cov0" title="0">{
                return os.Truncate(filePath, size)
        }</span>
        <span class="cov5" title="10">return nil</span>
}

func (cc *CopyCommand) updateSnapshot(err error, spath string, srct int64) error <span class="cov6" title="20">{
        if cc.cpOption.snapshotPath != "" &amp;&amp; err == nil </span><span class="cov0" title="0">{
                srctstr := fmt.Sprintf("%d", srct)
                err := cc.cpOption.snapshotldb.Put([]byte(spath), []byte(srctstr), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dump snapshot error: %s", err.Error())
                }</span>
        }
        <span class="cov6" title="20">return nil</span>
}

func (cc *CopyCommand) batchDownloadFiles(bucket *oss.Bucket, srcURL CloudURL, filePath string) error <span class="cov0" title="0">{
        cc.adjustSrcURLForCommand(&amp;srcURL, cc.cpOption.bSyncCommand)
        chObjects := make(chan objectInfoType, ChannelBuf)
        chError := make(chan error, cc.cpOption.routines)
        chListError := make(chan error, 1)
        // both objectStatistic &amp; object Producer will list objects, this is duplicate
        go cc.objectStatistic(bucket, srcURL)
        go cc.objectProducer(bucket, srcURL, chObjects, chListError)

        LogInfo("batch download files,routin count:%d,srcurl:%s,filepath:%s\n", cc.cpOption.routines, srcURL.ToString(), filePath)
        for i := 0; int64(i) &lt; cc.cpOption.routines; i++ </span><span class="cov0" title="0">{
                go cc.downloadConsumer(bucket, filePath, chObjects, chError)
        }</span>
        <span class="cov0" title="0">return cc.waitRoutinueComplete(chError, chListError, opDownload)</span>
}

func (cc *CopyCommand) objectStatistic(bucket *oss.Bucket, cloudURL CloudURL) <span class="cov5" title="10">{
        if cc.cpOption.recursive </span><span class="cov0" title="0">{
                pre := oss.Prefix(cloudURL.object)
                marker := oss.Marker("")
                //while the src object is end with "/", use object key as marker, exclude the object itself
                if strings.HasSuffix(cloudURL.object, "/") </span><span class="cov0" title="0">{
                        marker = oss.Marker(cloudURL.object)
                }</span>

                <span class="cov0" title="0">del := oss.Delimiter("")
                if cc.cpOption.onlyCurrentDir </span><span class="cov0" title="0">{
                        del = oss.Delimiter("/")
                }</span>
                <span class="cov0" title="0">listOptions := append(cc.cpOption.payerOptions, pre, marker, del)

                fnvIns := fnv.New64()
                for </span><span class="cov0" title="0">{
                        lor, err := cc.command.ossListObjectsRetry(bucket, listOptions...)
                        if err != nil </span><span class="cov0" title="0">{
                                cc.monitor.setScanError(err)
                                return
                        }</span>

                        <span class="cov0" title="0">for _, object := range lor.Objects </span><span class="cov0" title="0">{
                                if doesSingleObjectMatchPatterns(object.Key, cc.cpOption.filters) </span><span class="cov0" title="0">{
                                        if cc.cpOption.partitionIndex == 0 || (cc.cpOption.partitionIndex &gt; 0 &amp;&amp; matchHash(fnvIns, object.Key, cc.cpOption.partitionIndex-1, cc.cpOption.partitionCount)) </span><span class="cov0" title="0">{
                                                if strings.ToLower(object.Type) == "symlink" </span><span class="cov0" title="0">{
                                                        props, err := cc.command.ossGetObjectStatRetry(bucket, object.Key, cc.cpOption.payerOptions...)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                LogError("ossGetObjectStatRetry error info:%s\n", err.Error())
                                                                cc.monitor.setScanError(err)
                                                                return
                                                        }</span>
                                                        <span class="cov0" title="0">size, err := strconv.ParseInt(props.Get(oss.HTTPHeaderContentLength), 10, 64)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                LogError("strconv.ParseInt error info:%s\n", err.Error())
                                                                cc.monitor.setScanError(err)
                                                                return
                                                        }</span>
                                                        <span class="cov0" title="0">object.Size = size</span>
                                                }
                                                <span class="cov0" title="0">cc.monitor.updateScanSizeNum(cc.getRangeSize(object.Size), 1)</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">pre = oss.Prefix(lor.Prefix)
                        marker = oss.Marker(lor.NextMarker)
                        listOptions = append(cc.cpOption.payerOptions, pre, marker)
                        if !lor.IsTruncated </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        } else<span class="cov5" title="10"> {
                statOptions := cc.cpOption.payerOptions
                if cc.cpOption.versionId != "" </span><span class="cov0" title="0">{
                        statOptions = append(statOptions, oss.VersionId(cc.cpOption.versionId))
                }</span>

                <span class="cov5" title="10">props, err := cc.command.ossGetObjectStatRetry(bucket, cloudURL.object, statOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        cc.monitor.setScanError(err)
                        return
                }</span>

                <span class="cov5" title="10">size, err := strconv.ParseInt(props.Get(oss.HTTPHeaderContentLength), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        cc.monitor.setScanError(err)
                        return
                }</span>
                <span class="cov5" title="10">cc.monitor.updateScanSizeNum(cc.getRangeSize(size), 1)</span>
        }

        <span class="cov5" title="10">cc.monitor.setScanEnd()
        freshProgress()</span>
}

func (cc *CopyCommand) getRangeSize(size int64) int64 <span class="cov6" title="20">{
        if cc.cpOption.vrange == "" </span><span class="cov6" title="20">{
                return size
        }</span>
        <span class="cov0" title="0">sli := strings.Split(cc.cpOption.vrange, ",")
        sizes := []int64{}
        for i := 0; i &lt; len(sli); i++ </span><span class="cov0" title="0">{
                if s, err := cc.parseRange(sli[i], size); err != nil </span><span class="cov0" title="0">{
                        return s
                }</span> else<span class="cov0" title="0"> {
                        sizes = append(sizes, s)
                }</span>
        }
        <span class="cov0" title="0">return sizes[0]</span>
}

func (cc *CopyCommand) parseRange(str string, size int64) (int64, error) <span class="cov0" title="0">{
        if strings.HasPrefix(str, "-") </span><span class="cov0" title="0">{
                len := str[1:]
                l, err := strconv.ParseInt(len, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return size, nil
                }</span>
                <span class="cov0" title="0">return l, nil</span>
        } else<span class="cov0" title="0"> if strings.HasSuffix(str, "-") </span><span class="cov0" title="0">{
                start := str[:len(str)-1]
                s, err := strconv.ParseInt(start, 10, 64)
                if err != nil || s &gt;= size </span><span class="cov0" title="0">{
                        return size, nil
                }</span>
                <span class="cov0" title="0">return size - s, nil</span>
        } else<span class="cov0" title="0"> {
                pos := strings.IndexAny(str, "-")
                if pos == -1 </span><span class="cov0" title="0">{
                        return size, nil
                }</span>
                <span class="cov0" title="0">start := str[:pos]
                end := str[pos+1:]
                s, err1 := strconv.ParseInt(start, 10, 64)
                e, err2 := strconv.ParseInt(end, 10, 64)
                if err1 != nil || err2 != nil || s &gt;= size || e &gt;= size || s &gt; e </span><span class="cov0" title="0">{
                        return size, nil
                }</span>
                <span class="cov0" title="0">if s &gt; e </span><span class="cov0" title="0">{
                        return size, fmt.Errorf("Invalid range")
                }</span>
                <span class="cov0" title="0">return e - s + 1, nil</span>
        }
}

func (cc *CopyCommand) objectProducer(bucket *oss.Bucket, cloudURL CloudURL, chObjects chan&lt;- objectInfoType, chError chan&lt;- error) <span class="cov0" title="0">{
        pre := oss.Prefix(cloudURL.object)
        marker := oss.Marker("")
        //while the src object is end with "/", use object key as marker, exclude the object itself
        if strings.HasSuffix(cloudURL.object, "/") </span><span class="cov0" title="0">{
                marker = oss.Marker(cloudURL.object)
        }</span>
        <span class="cov0" title="0">del := oss.Delimiter("")
        if cc.cpOption.onlyCurrentDir </span><span class="cov0" title="0">{
                del = oss.Delimiter("/")
        }</span>

        <span class="cov0" title="0">listOptions := append(cc.cpOption.payerOptions, pre, marker, del)
        for </span><span class="cov0" title="0">{
                lor, err := cc.command.ossListObjectsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        break</span>
                }

                <span class="cov0" title="0">fnvIns := fnv.New64()
                for _, object := range lor.Objects </span><span class="cov0" title="0">{
                        prefix := ""
                        relativeKey := object.Key
                        index := strings.LastIndex(cloudURL.object, "/")
                        if index &gt; 0 </span><span class="cov0" title="0">{
                                prefix = object.Key[:index+1]
                                relativeKey = object.Key[index+1:]
                        }</span>

                        <span class="cov0" title="0">if doesSingleObjectMatchPatterns(object.Key, cc.cpOption.filters) </span><span class="cov0" title="0">{
                                if cc.cpOption.partitionIndex == 0 || (cc.cpOption.partitionIndex &gt; 0 &amp;&amp; matchHash(fnvIns, object.Key, cc.cpOption.partitionIndex-1, cc.cpOption.partitionCount)) </span><span class="cov0" title="0">{
                                        if strings.ToLower(object.Type) == "symlink" </span><span class="cov0" title="0">{
                                                props, err := cc.command.ossGetObjectStatRetry(bucket, object.Key, cc.cpOption.payerOptions...)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        LogError("ossGetObjectStatRetry error info:%s\n", err.Error())
                                                        chError &lt;- err
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">size, err := strconv.ParseInt(props.Get(oss.HTTPHeaderContentLength), 10, 64)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        LogError("strconv.ParseInt error info:%s\n", err.Error())
                                                        chError &lt;- err
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">object.Size = size</span>
                                        }
                                        <span class="cov0" title="0">chObjects &lt;- objectInfoType{prefix, relativeKey, int64(object.Size), object.LastModified}</span>
                                }
                        }
                }

                <span class="cov0" title="0">pre = oss.Prefix(lor.Prefix)
                marker = oss.Marker(lor.NextMarker)
                listOptions = append(cc.cpOption.payerOptions, pre, marker)
                if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">defer close(chObjects)
        chError &lt;- nil</span>
}

func (cc *CopyCommand) downloadConsumer(bucket *oss.Bucket, filePath string, chObjects &lt;-chan objectInfoType, chError chan&lt;- error) <span class="cov0" title="0">{
        for objectInfo := range chObjects </span><span class="cov0" title="0">{
                err := cc.downloadSingleFileWithReport(bucket, objectInfo, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        if !cc.cpOption.ctnu </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        <span class="cov0" title="0">chError &lt;- nil</span>
}

func (cc *CopyCommand) waitRoutinueComplete(chError, chListError &lt;-chan error, opStr string) error <span class="cov0" title="0">{
        completed := 0
        var ferr error
        for int64(completed) &lt;= cc.cpOption.routines </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-chListError:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">completed++</span>
                case err := &lt;-chError:<span class="cov0" title="0">
                        if err == nil </span><span class="cov0" title="0">{
                                completed++
                        }</span> else<span class="cov0" title="0"> {
                                ferr = err
                                if !cc.cpOption.ctnu </span><span class="cov0" title="0">{
                                        cc.closeProgress()
                                        fmt.Printf(cc.monitor.progressBar(true, errExit))
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return cc.formatResultPrompt(ferr)</span>
}

//function for copy objects
func (cc *CopyCommand) copyFiles(srcURL, destURL CloudURL) error <span class="cov0" title="0">{
        bucket, err := cc.command.ossBucket(srcURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := cc.checkCopyFileArgs(srcURL, destURL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !cc.cpOption.recursive </span><span class="cov0" title="0">{
                if srcURL.object == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("copy object invalid url: %s, object empty. If you mean batch copy objects, please use --recursive option", srcURL.ToString())
                }</span>

                // it is a "Dir" object
                <span class="cov0" title="0">if strings.HasSuffix(srcURL.object, "/") </span><span class="cov0" title="0">{
                        return fmt.Errorf("cp: %v is a directory (not copied), please use --recursive option", srcURL.object)
                }</span>

                <span class="cov0" title="0">index := strings.LastIndex(srcURL.object, "/")
                prefix := ""
                relativeKey := srcURL.object
                if index &gt; 0 </span><span class="cov0" title="0">{
                        prefix = srcURL.object[:index+1]
                        relativeKey = srcURL.object[index+1:]
                }</span>

                <span class="cov0" title="0">go cc.objectStatistic(bucket, srcURL)
                err := cc.copySingleFileWithReport(bucket, objectInfoType{prefix, relativeKey, -1, time.Now()}, srcURL, destURL)
                return cc.formatResultPrompt(err)</span>
        }

        <span class="cov0" title="0">if destURL.object != "" &amp;&amp; !strings.HasSuffix(destURL.object, "/") </span><span class="cov0" title="0">{
                destURL.object = destURL.object + "/"
        }</span>
        <span class="cov0" title="0">return cc.batchCopyFiles(bucket, srcURL, destURL)</span>
}

func (cc *CopyCommand) checkCopyFileArgs(srcURL, destURL CloudURL) error <span class="cov0" title="0">{
        if err := destURL.checkObjectPrefix(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if srcURL.bucket != destURL.bucket </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">srcPrefix := srcURL.object
        destPrefix := destURL.object
        if srcPrefix == destPrefix </span><span class="cov0" title="0">{
                if cc.cpOption.meta == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("\"%s\" and \"%s\" are the same, copy self will do nothing, set meta please use --meta options", srcURL.ToString(), srcURL.ToString())
                }</span>
        } else<span class="cov0" title="0"> if cc.cpOption.recursive </span><span class="cov0" title="0">{
                if strings.HasPrefix(destPrefix, srcPrefix) </span><span class="cov0" title="0">{
                        return fmt.Errorf("\"%s\" include \"%s\", it's not allowed, recursivlly copy should be avoided", destURL.ToString(), srcURL.ToString())
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(srcPrefix, destPrefix) </span><span class="cov0" title="0">{
                        return fmt.Errorf("\"%s\" include \"%s\", it's not allowed, recover source object should be avoided", srcURL.ToString(), destURL.ToString())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (cc *CopyCommand) copySingleFileWithReport(bucket *oss.Bucket, objectInfo objectInfoType, srcURL, destURL CloudURL) error <span class="cov0" title="0">{
        skip, err, size, msg := cc.copySingleFile(bucket, objectInfo, srcURL, destURL)
        cc.updateMonitor(skip, err, false, size)
        cc.report(msg, err)
        return err
}</span>

func (cc *CopyCommand) copySingleFile(bucket *oss.Bucket, objectInfo objectInfoType, srcURL, destURL CloudURL) (bool, error, int64, string) <span class="cov0" title="0">{
        //make object name
        srcObject := objectInfo.prefix + objectInfo.relativeKey
        destObject := cc.makeCopyObjectName(objectInfo.relativeKey, destURL.object)
        size := objectInfo.size
        srct := objectInfo.lastModified

        msg := fmt.Sprintf("%s %s to %s", opCopy, CloudURLToString(srcURL.bucket, srcObject), CloudURLToString(destURL.bucket, destObject))

        //get object size
        if size &lt; 0 </span><span class="cov0" title="0">{
                statOptions := cc.cpOption.payerOptions
                if cc.cpOption.versionId != "" </span><span class="cov0" title="0">{
                        statOptions = append(statOptions, oss.VersionId(cc.cpOption.versionId))
                }</span>

                <span class="cov0" title="0">props, err := cc.command.ossGetObjectStatRetry(bucket, srcObject, statOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err, size, msg
                }</span>
                <span class="cov0" title="0">size, err = strconv.ParseInt(props.Get(oss.HTTPHeaderContentLength), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err, size, msg
                }</span>
                <span class="cov0" title="0">if srct, err = time.Parse(http.TimeFormat, props.Get(oss.HTTPHeaderLastModified)); err != nil </span><span class="cov0" title="0">{
                        return false, err, size, msg
                }</span>
        }

        <span class="cov0" title="0">if skip, err := cc.skipCopy(destURL, destObject, srct); err != nil || skip </span><span class="cov0" title="0">{
                return skip, err, size, msg
        }</span>

        <span class="cov0" title="0">if size &lt; cc.cpOption.threshold </span><span class="cov0" title="0">{
                return false, cc.ossCopyObjectRetry(bucket, srcObject, destURL.bucket, destObject), size, msg
        }</span>

        <span class="cov0" title="0">var listener *OssResumeProgressListener = &amp;OssResumeProgressListener{&amp;cc.monitor, 0, 0, false, false}
        partSize, rt := cc.preparePartOption(size)
        cp := oss.CheckpointDir(true, cc.cpOption.cpDir)
        options := cc.cpOption.options
        options = append(options, oss.Routines(rt), cp, oss.Progress(listener), oss.MetadataDirective(oss.MetaReplace))
        return false, cc.ossResumeCopyRetry(srcURL.bucket, srcObject, destURL.bucket, destObject, partSize, options...), 0, msg</span>
}

func (cc *CopyCommand) makeCopyObjectName(srcRelativeObject, destObject string) string <span class="cov0" title="0">{
        if destObject == "" || strings.HasSuffix(destObject, "/") </span><span class="cov0" title="0">{
                return destObject + srcRelativeObject
        }</span>
        <span class="cov0" title="0">return destObject</span>
}

func (cc *CopyCommand) skipCopy(destURL CloudURL, destObject string, srct time.Time) (bool, error) <span class="cov0" title="0">{
        destBucket, err := cc.command.ossBucket(destURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if cc.cpOption.update </span><span class="cov0" title="0">{
                if props, err := cc.command.ossGetObjectStatRetry(destBucket, destObject, cc.cpOption.payerOptions...); err == nil </span><span class="cov0" title="0">{
                        destt, err := time.Parse(http.TimeFormat, props.Get(oss.HTTPHeaderLastModified))
                        if err == nil &amp;&amp; destt.Unix() &gt;= srct.Unix() </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                if !cc.cpOption.force </span><span class="cov0" title="0">{
                        if _, err := cc.command.ossGetObjectMetaRetry(destBucket, destObject, cc.cpOption.payerOptions...); err == nil </span><span class="cov0" title="0">{
                                if !cc.confirm(CloudURLToString(destURL.bucket, destObject)) </span><span class="cov0" title="0">{
                                        return true, nil
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (cc *CopyCommand) ossCopyObjectRetry(bucket *oss.Bucket, objectName, destBucketName, destObjectName string) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, cc.command.options)
        options := cc.cpOption.options
        options = append(options, oss.MetadataDirective(oss.MetaReplace))
        options = append(options, oss.TaggingDirective(oss.TaggingReplace))
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                if i &gt; 1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(3) * time.Second)
                        if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                                fmt.Printf("\nretry count:%d,copy object:%s.\n", i-1, objectName)
                        }</span>
                }
                <span class="cov0" title="0">_, err := bucket.CopyObjectTo(destBucketName, destObjectName, objectName, options...)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov0" title="0">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, objectName}
                }</span>
        }
}

func (cc *CopyCommand) ossResumeCopyRetry(bucketName, objectName, destBucketName, destObjectName string, partSize int64, options ...oss.Option) error <span class="cov0" title="0">{
        bucket, err := cc.command.ossBucket(destBucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">retryTimes, _ := GetInt(OptionRetryTimes, cc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                if i &gt; 1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(3) * time.Second)
                        if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                                fmt.Printf("\nretry count:%d, resume copy object:%s.\n", i-1, objectName)
                        }</span>
                }

                <span class="cov0" title="0">err := bucket.CopyFile(bucketName, objectName, destObjectName, partSize, options...)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, objectName}
                }</span>
        }
}

func (cc *CopyCommand) batchCopyFiles(bucket *oss.Bucket, srcURL, destURL CloudURL) error <span class="cov0" title="0">{
        cc.adjustSrcURLForCommand(&amp;srcURL, cc.cpOption.bSyncCommand)
        chObjects := make(chan objectInfoType, ChannelBuf)
        chError := make(chan error, cc.cpOption.routines)
        chListError := make(chan error, 1)
        go cc.objectStatistic(bucket, srcURL)
        go cc.objectProducer(bucket, srcURL, chObjects, chListError)

        for i := 0; int64(i) &lt; cc.cpOption.routines; i++ </span><span class="cov0" title="0">{
                go cc.copyConsumer(bucket, srcURL, destURL, chObjects, chError)
        }</span>

        <span class="cov0" title="0">return cc.waitRoutinueComplete(chError, chListError, opDownload)</span>
}

func (cc *CopyCommand) copyConsumer(bucket *oss.Bucket, srcURL, destURL CloudURL, chObjects &lt;-chan objectInfoType, chError chan&lt;- error) <span class="cov0" title="0">{
        for objectInfo := range chObjects </span><span class="cov0" title="0">{
                err := cc.copySingleFileWithReport(bucket, objectInfo, srcURL, destURL)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        if !cc.cpOption.ctnu </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        <span class="cov0" title="0">chError &lt;- nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package lib

import (
        "fmt"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseCreateSymlink = SpecText{

        synopsisText: "创建符号链接",

        paramText: "cloud_url target_url [options]",

        syntaxText: ` 
    ossutil create-symlink cloud_url target_object [--encoding-type url] [--payer requester] [-c file] 
`,

        detailHelpText: ` 
    该命令在oss上创建符号链接文件，链接的目标文件必须为相同bucket下的文件，且文件类型非符
    号链接。即，cloud_url必须为形如oss://bucket/object的cloud_url，target_object为object名。

    创建符号链接时：
        不检查目标文件是否存在，
        不检查目标文件类型是否合法，
        不检查目标文件是否有权限访问， 
        以上检查，都推迟到GetObject等需要访问目标文件的API。
    如果试图添加的文件已经存在，并且有访问权限。新添加的文件将覆盖原来的文件。

    通过stat命令可以查看符号链接的目标文件。

    更多信息见官网文档：https://help.aliyun.com/document_detail/45126.html?spm=5176.doc31979.6.870.x3Tqsh

用法：

    ossutil create-symlink oss://bucket/symlink-object target-object
`,

        sampleText: ` 
    ossutil create-symlink oss://bucket1/object1 object2 
      创建从指向object2的符号链接object1。
    
    ossutil create-symlink oss://bucket1/object1 object2 --payer requester
      以访问者付费模式,创建从指向object2的符号链接object1
`,
}

var specEnglishCreateSymlink = SpecText{

        synopsisText: "Create symlink of object",

        paramText: "cloud_url target_url [options]",

        syntaxText: ` 
    ossutil create-symlink cloud_url target_object [--encoding-type url] [--payer requester] [-c file] 
`,

        detailHelpText: ` 
    The command create symlink of object in oss, the target object must be object in the 
    same bucket of symlink object, and the file type of target object must not be symlink. 
    So, cloud_url must be in format: oss://bucket/object, and target_object is the object 
    name of target object.  

    When create symlink:
        Will not check whether target object exists;
        Will not check whether target object type is valid;
        Will not check whether if have access permission of target object.
    The check will be done when visiting GetObject, etc.

    If the symlink object exist, and has access permission, the object newly created will 
    cover the old object.

    We can use stat command to query the target object of symlink object.

    More information about symlink see: https://help.aliyun.com/document_detail/45126.html?spm=5176.doc31979.6.870.x3Tqsh

Usage:

    ossutil create-symlink oss://bucket/symlink-object target-object
`,

        sampleText: ` 
    ossutil create-symlink oss://bucket1/object1 object2 
      Create symlink object named object1, which point to object2.
    
    ossutil create-symlink oss://bucket1/object1 object2 --payer requester
      Create symlink object named object1, which point to object2 with requester payment mode
`,
}

// CreateSymlinkCommand is the command list buckets or objects
type CreateSymlinkCommand struct {
        command       Command
        commonOptions []oss.Option
}

var createSymlinkCommand = CreateSymlinkCommand{
        command: Command{
                name:        "create-symlink",
                nameAlias:   []string{},
                minArgc:     2,
                maxArgc:     2,
                specChinese: specChineseCreateSymlink,
                specEnglish: specEnglishCreateSymlink,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionEncodingType,
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionLogLevel,
                        OptionRequestPayer,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (cc *CreateSymlinkCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return cc.command.formatHelpForWhole()
}</span>

func (cc *CreateSymlinkCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return cc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (cc *CreateSymlinkCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return cc.command.Init(args, options, cc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (cc *CreateSymlinkCommand) RunCommand() error <span class="cov0" title="0">{
        encodingType, _ := GetString(OptionEncodingType, cc.command.options)
        cloudURL, err := CloudURLFromString(cc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">targetURL, err := StorageURLFromString(cc.command.args[1], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := cc.checkArgs(cloudURL, targetURL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">targetObject := targetURL.ToString()
        if targetURL.IsCloudURL() </span><span class="cov0" title="0">{
                targetObject = targetURL.(CloudURL).object
        }</span>

        <span class="cov0" title="0">bucket, err := cc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">payer, _ := GetString(OptionRequestPayer, cc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">cc.commonOptions = append(cc.commonOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        <span class="cov0" title="0">return cc.ossCreateSymlinkRetry(bucket, cloudURL.object, targetObject)</span>
}

func (cc *CreateSymlinkCommand) checkArgs(symlinkURL CloudURL, targetURL StorageURLer) error <span class="cov0" title="0">{
        if symlinkURL.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", cc.command.args[0])
        }</span>
        <span class="cov0" title="0">if symlinkURL.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss object, symlink object can't be empty", cc.command.args[0])
        }</span>
        <span class="cov0" title="0">if targetURL.IsCloudURL() </span><span class="cov0" title="0">{
                if targetURL.(CloudURL).bucket == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid cloud url: %s, miss bucket", cc.command.args[1])
                }</span>
                <span class="cov0" title="0">if targetURL.(CloudURL).bucket != symlinkURL.bucket </span><span class="cov0" title="0">{
                        return fmt.Errorf("the bucket of target object: %s must be the same with the bucket of symlink object: %s", targetURL.(CloudURL).bucket, symlinkURL.bucket)
                }</span>
                <span class="cov0" title="0">if targetURL.(CloudURL).object == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid cloud url: %s, miss object, target object can't be empty", cc.command.args[1])
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (cc *CreateSymlinkCommand) ossCreateSymlinkRetry(bucket *oss.Bucket, symlinkObject, targetObject string) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, cc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                err := bucket.PutSymlink(symlinkObject, targetObject, cc.commonOptions...)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, symlinkObject}
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package lib

import (
        "fmt"
        "runtime"
        "strconv"
        "strings"
        "sync"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseDu = SpecText{
        synopsisText: "获取bucket或者指定前缀(目录)所占的存储空间大小",

        paramText: "bucket_url [options]",

        syntaxText: ` 
        ossutil du oss://bucket[/prefix] [options]
`,

        detailHelpText: ` 
        该命令会获取bucket或者指定前缀(目录)所占的存储空间大小,包括未完成上传object的块大小
  
用法：

    该命令只有一种用法：

    1) ossutil du oss://bucket[/prefix] [options]
      查询bucket或者指定前缀(目录)所占存储空间大小
`,

        sampleText: ` 
        1) 查询bucket占用存储空间大小
       ossutil du oss://bucket
    
    2) 查询指定前缀(目录)占用存储空间大小
       ossutil du oss://bucket/prefix
    
    3) 查询指定前缀(目录)占用存储空间大小, 包括多版本object
       ossutil du oss://bucket/prefix --all-versions
    
    4) 统计结果以KB为单位显示, 支持MB, GB, TB
       ossutil du oss://bucket/prefix --block-size KB
`,
}

var specEnglishDu = SpecText{
        synopsisText: "Get the bucket or the specified prefix(directory) storage size",

        paramText: "bucket_url [options]",

        syntaxText: ` 
        ossutil du oss://bucket[/prefix] [options]
`,

        detailHelpText: ` 
        This command gets the bucket or the specified prefix(directory) storage size,including uncompleted part size

Usages：

    There is only one usage for this command:

    1) ossutil du oss://bucket[/prefix] [options]
       Gets the bucket or the specified prefix(directory) storage size
`,

        sampleText: ` 
        1) get the bucket storage size
       ossutil du oss://bucket
    
    2) get the prefix(directory) stroage size
       ossutil du oss://bucket/prefix
    
    3) get the prefix(directory) stroage size, including all versioning objects
       ossutil du oss://bucket/prefix --all-versions

    4) The du results are displayed in KB block size, Support MB, GB, TB
       ossutil du oss://bucket/prefix --block-size KB
`,
}

type MultiPartObject struct {
        objectName string
        uploadId   string
}

type duSizeOptionType struct {
        bucketName       string
        object           string
        payer            string
        countTypeMap     map[string]int64
        sizeTypeMap      map[string]int64
        totalObjectCount int64
        sumObjectSize    int64
        totalPartCount   int64
        sumPartSize      int64
        mutex            sync.Mutex
        displayUnit      string
        blockSize        int64
}

type DuCommand struct {
        command  Command
        duOption duSizeOptionType
}

var duSizeCommand = DuCommand{
        command: Command{
                name:        "du",
                nameAlias:   []string{"du"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseDu,
                specEnglish: specEnglishDu,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionRequestPayer,
                        OptionAllversions,
                        OptionPassword,
                        OptionBlockSize,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (duc *DuCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return duc.command.formatHelpForWhole()
}</span>

func (duc *DuCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return duc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (duc *DuCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return duc.command.Init(args, options, duc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (duc *DuCommand) RunCommand() error <span class="cov0" title="0">{
        // clear for go tests
        duc.duOption.countTypeMap = make(map[string]int64)
        duc.duOption.sizeTypeMap = make(map[string]int64)
        duc.duOption.totalObjectCount = 0
        duc.duOption.sumObjectSize = 0
        duc.duOption.totalPartCount = 0
        duc.duOption.sumPartSize = 0

        blockSizeMap := make(map[string]int64)
        blockSizeMap["byte"] = 1
        blockSizeMap["KB"] = 1024
        blockSizeMap["MB"] = 1024 * 1024
        blockSizeMap["GB"] = 1024 * 1024 * 1024
        blockSizeMap["TB"] = 1024 * 1024 * 1024 * 1024

        encodingType, _ := GetString(OptionEncodingType, duc.command.options)
        srcBucketUrL, err := GetCloudUrl(duc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">payer, _ := GetString(OptionRequestPayer, duc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if strings.ToLower(payer) != strings.ToLower(string(oss.Requester)) &amp;&amp;
                        strings.ToLower(payer) != strings.ToLower(string(oss.BucketOwner)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("option payer value must be %s or %s",
                                strings.ToLower(string(oss.Requester)), strings.ToLower(string(oss.BucketOwner)))
                }</span>
        }
        <span class="cov0" title="0">allVersions, _ := GetBool(OptionAllversions, duc.command.options)

        strBlockSize, _ := GetString(OptionBlockSize, duc.command.options)
        strBlockSize = strings.ToUpper(strBlockSize)
        if strBlockSize == "" </span><span class="cov0" title="0">{
                strBlockSize = "byte"
        }</span>

        <span class="cov0" title="0">if strBlockSize != "byte" &amp;&amp; strBlockSize != "KB" &amp;&amp; strBlockSize != "MB" &amp;&amp; strBlockSize != "GB" &amp;&amp; strBlockSize != "TB" </span><span class="cov0" title="0">{
                return fmt.Errorf("-B value must be KB, MB, GB or TB")
        }</span>
        <span class="cov0" title="0">duc.duOption.displayUnit = strBlockSize
        duc.duOption.blockSize = blockSizeMap[strBlockSize]

        duc.duOption.bucketName = srcBucketUrL.bucket
        duc.duOption.object = srcBucketUrL.object
        duc.duOption.payer = payer
        bucket, err := duc.command.ossBucket(duc.duOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // first:get all object size
        <span class="cov0" title="0">if allVersions </span><span class="cov0" title="0">{
                err = duc.getAllObjectVersionsSize(bucket)
        }</span> else<span class="cov0" title="0"> {
                err = duc.getAllObjectSize(bucket)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">printHeader := false
        for k, v := range duc.duOption.countTypeMap </span><span class="cov0" title="0">{
                if !printHeader </span><span class="cov0" title="0">{
                        fmt.Printf("\r                                                                      ")
                        fmt.Printf("\r%-14s\t%-20s\t%-30s\n", "storage class", "object count", "sum size(byte)")
                        fmt.Printf("----------------------------------------------------------\n")
                        printHeader = true
                }</span>
                <span class="cov0" title="0">fmt.Printf("%-14s\t%-20d\t%-30d\n", k, v, duc.duOption.sizeTypeMap[k])</span>
        }
        <span class="cov0" title="0">if !printHeader </span><span class="cov0" title="0">{
                fmt.Printf("\r")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("----------------------------------------------------------\n")
        }</span>
        <span class="cov0" title="0">fmt.Printf("%-20s%-20d\t%-23s%d\n", "total object count:", duc.duOption.totalObjectCount, "total object sum size:", duc.duOption.sumObjectSize)

        //second:get all part size
        err = duc.GetAllPartSize(bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("\r                                                                      ")
        fmt.Printf("\r%-20s%-20d\t%-23s%d\n\n", "total part count:", duc.duOption.totalPartCount, "total part sum size:", duc.duOption.sumPartSize)

        if duc.duOption.blockSize == int64(1) </span><span class="cov0" title="0">{
                displaySize := (duc.duOption.sumObjectSize + duc.duOption.sumPartSize) / duc.duOption.blockSize
                fmt.Printf("total du size(%s):%d\n", duc.duOption.displayUnit, displaySize)
        }</span> else<span class="cov0" title="0"> {
                displaySize := float64(duc.duOption.sumObjectSize+duc.duOption.sumPartSize) / float64(duc.duOption.blockSize)
                fmt.Printf("total du size(%s):%.4f\n", duc.duOption.displayUnit, displaySize)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (duc *DuCommand) getAllObjectSize(bucket *oss.Bucket) error <span class="cov0" title="0">{
        pre := oss.Prefix(duc.duOption.object)
        marker := oss.Marker("")
        listOptions := []oss.Option{pre, marker, oss.MaxKeys(1000)}
        if duc.duOption.payer != "" </span><span class="cov0" title="0">{
                listOptions = append(listOptions, oss.RequestPayer(oss.PayerType(duc.duOption.payer)))
        }</span>

        <span class="cov0" title="0">for i := 1; ; i++ </span><span class="cov0" title="0">{
                lor, err := duc.command.ossListObjectsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">duc.duOption.totalObjectCount += int64(len(lor.Objects))
                for _, object := range lor.Objects </span><span class="cov0" title="0">{
                        duc.duOption.sumObjectSize += object.Size
                        if _, ok := duc.duOption.countTypeMap[object.StorageClass]; ok </span><span class="cov0" title="0">{
                                duc.duOption.countTypeMap[object.StorageClass]++
                                duc.duOption.sizeTypeMap[object.StorageClass] += object.Size
                        }</span> else<span class="cov0" title="0"> {
                                duc.duOption.countTypeMap[object.StorageClass] = 1
                                duc.duOption.sizeTypeMap[object.StorageClass] = object.Size
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("\robject count:%d\tobject sum size:%d", duc.duOption.totalObjectCount, duc.duOption.sumObjectSize)

                pre = oss.Prefix(lor.Prefix)
                marker = oss.Marker(lor.NextMarker)
                listOptions = []oss.Option{pre, marker, oss.MaxKeys(1000)}
                if duc.duOption.payer != "" </span><span class="cov0" title="0">{
                        listOptions = append(listOptions, oss.RequestPayer(oss.PayerType(duc.duOption.payer)))
                }</span>

                <span class="cov0" title="0">if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (duc *DuCommand) getAllObjectVersionsSize(bucket *oss.Bucket) error <span class="cov0" title="0">{
        // Delete Object Versions and DeleteMarks
        pre := oss.Prefix(duc.duOption.object)
        keyMarker := oss.KeyMarker("")
        versionIdMarker := oss.VersionIdMarker("")
        listOptions := []oss.Option{pre, keyMarker, versionIdMarker, oss.MaxKeys(1000)}
        if duc.duOption.payer != "" </span><span class="cov0" title="0">{
                listOptions = append(listOptions, oss.RequestPayer(oss.PayerType(duc.duOption.payer)))
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                lor, err := bucket.ListObjectVersions(listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">duc.duOption.totalObjectCount += int64(len(lor.ObjectVersions))
                for _, object := range lor.ObjectVersions </span><span class="cov0" title="0">{
                        duc.duOption.sumObjectSize += object.Size
                        if _, ok := duc.duOption.countTypeMap[object.StorageClass]; ok </span><span class="cov0" title="0">{
                                duc.duOption.countTypeMap[object.StorageClass]++
                                duc.duOption.sizeTypeMap[object.StorageClass] += object.Size
                        }</span> else<span class="cov0" title="0"> {
                                duc.duOption.countTypeMap[object.StorageClass] = 1
                                duc.duOption.sizeTypeMap[object.StorageClass] = object.Size
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("\robject count:%d\tobject sum size:%d", duc.duOption.totalObjectCount, duc.duOption.sumObjectSize)
                keyMarker = oss.KeyMarker(lor.NextKeyMarker)
                versionIdMarker := oss.VersionIdMarker(lor.NextVersionIdMarker)
                listOptions = []oss.Option{pre, keyMarker, versionIdMarker, oss.MaxKeys(1000)}
                if duc.duOption.payer != "" </span><span class="cov0" title="0">{
                        listOptions = append(listOptions, oss.RequestPayer(oss.PayerType(duc.duOption.payer)))
                }</span>
                <span class="cov0" title="0">if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (duc *DuCommand) GetAllPartSize(bucket *oss.Bucket) error <span class="cov0" title="0">{
        routineCount := runtime.NumCPU()
        chObjects := make(chan MultiPartObject, ChannelBuf)
        chError := make(chan error, routineCount)
        chListError := make(chan error, 1)

        go duc.uploadIdProducer(bucket, chObjects, chListError)
        for i := 0; i &lt; routineCount; i++ </span><span class="cov0" title="0">{
                go duc.uploadIdConsumer(bucket, chObjects, chError)
        }</span>
        <span class="cov0" title="0">return duc.waitRoutinueComplete(chError, chListError, routineCount)</span>
}

func (duc *DuCommand) uploadIdConsumer(bucket *oss.Bucket, chObjects chan MultiPartObject, chError chan error) error <span class="cov0" title="0">{
        for object := range chObjects </span><span class="cov0" title="0">{
                err := duc.statPartSize(bucket, object)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        return err
                }</span>
        }
        <span class="cov0" title="0">chError &lt;- nil
        return nil</span>
}

func (duc *DuCommand) statPartSize(bucket *oss.Bucket, object MultiPartObject) error <span class="cov0" title="0">{
        var imur oss.InitiateMultipartUploadResult
        imur.Bucket = duc.duOption.bucketName
        imur.Key = object.objectName
        imur.UploadID = object.uploadId
        partNumberMarker := 0
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                lpOptions := []oss.Option{}
                lpOptions = append(lpOptions, oss.MaxParts(1000))
                lpOptions = append(lpOptions, oss.PartNumberMarker(partNumberMarker))
                if duc.duOption.payer != "" </span><span class="cov0" title="0">{
                        lpOptions = append(lpOptions, oss.RequestPayer(oss.PayerType(duc.duOption.payer)))
                }</span>

                <span class="cov0" title="0">lpRes, err := bucket.ListUploadedParts(imur, lpOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        serviceError, ok := err.(oss.ServiceError)
                        if ok &amp;&amp; serviceError.StatusCode == 404 </span><span class="cov0" title="0">{
                                // ignore 404 error; the uploadid maybe abort or completed
                                return nil
                        }</span> else<span class="cov0" title="0"> {
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        duc.duOption.mutex.Lock()
                        duc.duOption.totalPartCount += int64(len(lpRes.UploadedParts))
                        for _, v := range lpRes.UploadedParts </span><span class="cov0" title="0">{
                                duc.duOption.sumPartSize += int64(v.Size)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("\rpart count:%d\tpart sum size:%d", duc.duOption.totalPartCount, duc.duOption.sumPartSize)
                        duc.duOption.mutex.Unlock()</span>
                }

                <span class="cov0" title="0">if lpRes.IsTruncated </span><span class="cov0" title="0">{
                        partNumberMarker, _ = strconv.Atoi(lpRes.NextPartNumberMarker)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (duc *DuCommand) uploadIdProducer(bucket *oss.Bucket, chObjects chan MultiPartObject, chListError chan error) error <span class="cov0" title="0">{
        prefix := duc.duOption.object
        keyMarker := ""
        uploadIdMarker := ""
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                lpOptions := []oss.Option{}
                lpOptions = append(lpOptions, oss.MaxParts(1000))
                lpOptions = append(lpOptions, oss.Prefix(prefix))
                lpOptions = append(lpOptions, oss.KeyMarker(keyMarker))
                lpOptions = append(lpOptions, oss.UploadIDMarker(uploadIdMarker))
                if duc.duOption.payer != "" </span><span class="cov0" title="0">{
                        lpOptions = append(lpOptions, oss.RequestPayer(oss.PayerType(duc.duOption.payer)))
                }</span>

                <span class="cov0" title="0">lpRes, err := bucket.ListMultipartUploads(lpOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        chListError &lt;- err
                        return err
                }</span>

                <span class="cov0" title="0">for _, v := range lpRes.Uploads </span><span class="cov0" title="0">{
                        var object MultiPartObject
                        object.objectName = v.Key
                        object.uploadId = v.UploadID
                        chObjects &lt;- object

                }</span>

                <span class="cov0" title="0">if lpRes.IsTruncated </span><span class="cov0" title="0">{
                        keyMarker = lpRes.NextKeyMarker
                        uploadIdMarker = lpRes.NextUploadIDMarker
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">defer close(chObjects)
        chListError &lt;- nil
        return nil</span>
}

func (duc *DuCommand) waitRoutinueComplete(chError, chListError &lt;-chan error, routineCount int) error <span class="cov0" title="0">{
        completed := 0
        for completed &lt;= routineCount </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-chListError:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">completed++</span>
                case err := &lt;-chError:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">completed++</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package lib

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"
        "sync"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

const (
        AdvanceSeconds int64 = 60
)

type STSAkJson struct {
        AccessKeyId     string `json:"AccessKeyId,omitempty"`
        AccessKeySecret string `json:"AccessKeySecret,omitempty"`
        SecurityToken   string `json:"SecurityToken,omitempty"`
        Expiration      string `json:"Expiration,omitempty"`
        LastUpDated     string `json:"LastUpDated,omitempty"`
        Code            string `json:"Code,omitempty"`
}

func (stsJson *STSAkJson) String() string <span class="cov5" title="6">{
        return fmt.Sprintf("AccessKeyId:%s,AccessKeySecret:%s,SecurityToken:%s,Expiration:%s,LastUpDated:%s",
                stsJson.AccessKeyId, stsJson.AccessKeySecret, stsJson.SecurityToken, stsJson.Expiration, stsJson.LastUpDated)
}</span>

type EcsRoleAK struct {
        AccessKeyId     string
        AccessKeySecret string
        SecurityToken   string
}

func (ecsRole *EcsRoleAK) GetAccessKeyID() string <span class="cov8" title="24">{
        return ecsRole.AccessKeyId
}</span>

func (ecsRole *EcsRoleAK) GetAccessKeySecret() string <span class="cov8" title="24">{
        return ecsRole.AccessKeySecret
}</span>

func (ecsRole *EcsRoleAK) GetSecurityToken() string <span class="cov10" title="48">{
        return ecsRole.SecurityToken
}</span>

// for ecs bind ram and get ak by ossutil automaticly
type EcsRoleAKBuild struct {
        lock            sync.Mutex
        HasGet          bool
        url             string //url for get ak,such as http://100.100.100.200/latest/meta-data/Ram/security-credentials/RamRoleName
        AccessKeyId     string
        AccessKeySecret string
        SecurityToken   string
        Expiration      string
        LastUpDated     string
}

func (roleBuild *EcsRoleAKBuild) GetCredentials() oss.Credentials <span class="cov10" title="48">{
        roleBuild.lock.Lock()
        defer roleBuild.lock.Unlock()

        akJson := STSAkJson{}
        var err error = nil
        bTimeOut := false

        if !roleBuild.HasGet </span><span class="cov5" title="6">{
                bTimeOut = true
        }</span> else<span class="cov9" title="42"> {
                bTimeOut = roleBuild.IsTimeOut()
        }</span>

        <span class="cov10" title="48">if bTimeOut </span><span class="cov5" title="6">{
                tStart := time.Now().UnixNano() / 1000 / 1000
                akJson, err = roleBuild.HttpReqAk()
                tEnd := time.Now().UnixNano() / 1000 / 1000

                if err == nil </span><span class="cov5" title="6">{
                        roleBuild.AccessKeyId = akJson.AccessKeyId
                        roleBuild.AccessKeySecret = akJson.AccessKeySecret
                        roleBuild.SecurityToken = akJson.SecurityToken
                        roleBuild.Expiration = akJson.Expiration
                        LogInfo("get sts ak success,%s,cost:%d(ms)\n", akJson.String(), tEnd-tStart)
                }</span>
        }

        <span class="cov10" title="48">if err != nil </span><span class="cov0" title="0">{
                return &amp;EcsRoleAK{}
        }</span>

        <span class="cov10" title="48">return &amp;EcsRoleAK{
                AccessKeyId:     roleBuild.AccessKeyId,
                AccessKeySecret: roleBuild.AccessKeySecret,
                SecurityToken:   roleBuild.SecurityToken,
        }</span>
}

func (roleBuild *EcsRoleAKBuild) IsTimeOut() bool <span class="cov9" title="42">{
        if roleBuild.Expiration == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // attention: can't use time.ParseInLocation(),ecsRole.Expiration is UTC time
        <span class="cov9" title="42">utcExpirationTime, _ := time.Parse("2006-01-02T15:04:05Z", roleBuild.Expiration)

        // Now() returns the current local time
        nowLocalTime := time.Now()

        // Unix() returns the number of seconds elapsedsince January 1, 1970 UTC.
        if utcExpirationTime.Unix()-nowLocalTime.Unix()-AdvanceSeconds &lt;= 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov9" title="42">return false</span>
}

func (roleBuild *EcsRoleAKBuild) HttpReqAk() (STSAkJson, error) <span class="cov5" title="6">{
        akJson := STSAkJson{}

        //http time out
        c := &amp;http.Client{
                Timeout: 15 * time.Second,
        }

        resp, err := c.Get(roleBuild.url)
        if err != nil </span><span class="cov0" title="0">{
                LogError("insight getAK,http client get error,url is %s,%s\n", roleBuild.url, err.Error())
                return akJson, err
        }</span>
        <span class="cov5" title="6">defer resp.Body.Close()
        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return akJson, err
        }</span>

        <span class="cov5" title="6">err = json.Unmarshal(body, &amp;akJson)
        if err != nil </span><span class="cov0" title="0">{
                LogError("insight getAK,json.Unmarshal error,body is %s,%s\n", string(body), err.Error())
                return akJson, err
        }</span>

        // parsar json,such as
        //{
        //    "AccessKeyId" : "XXXXXXXXX",
        //    "AccessKeySecret" : "XXXXXXXXX",
        //    "Expiration" : "2017-11-01T05:20:01Z",
        //    "SecurityToken" : "XXXXXXXXX",
        //    "LastUpdated" : "2017-10-31T23:20:01Z",
        //    "Code" : "Success"
        // }

        <span class="cov5" title="6">if akJson.Code != "" &amp;&amp; strings.ToUpper(akJson.Code) != "SUCCESS" </span><span class="cov0" title="0">{
                LogError("insight getAK,get sts ak error,code:%s\n", akJson.Code)
                return akJson, fmt.Errorf("insight getAK,get sts ak error,code:%s", akJson.Code)
        }</span>

        <span class="cov5" title="6">if akJson.AccessKeyId == "" || akJson.AccessKeySecret == "" </span><span class="cov0" title="0">{
                LogError("insight getAK,parsar http json body error:\n%s\n", string(body))
                return akJson, fmt.Errorf("insight getAK,parsar http json body error:\n%s\n", string(body))
        }</span>

        <span class="cov5" title="6">if akJson.Expiration != "" </span><span class="cov5" title="6">{
                _, err := time.Parse("2006-01-02T15:04:05Z", akJson.Expiration)
                if err != nil </span><span class="cov0" title="0">{
                        LogError("time.Parse error,Expiration is %s,%s\n", akJson.Expiration, err.Error())
                        return akJson, err
                }</span>
        }

        <span class="cov5" title="6">roleBuild.HasGet = true
        return akJson, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package lib

import (
        "fmt"
)

// CommandError happens when use command in invalid way
type CommandError struct {
        command string
        reason  string
}

func (e CommandError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid usage of \"%s\" command, reason: %s, please try \"help %s\" for more information", e.command, e.reason, e.command)
}</span>

// BucketError happens when access bucket error
type BucketError struct {
        err    error
        bucket string
}

func (e BucketError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s, Bucket=%s", e.err.Error(), e.bucket)
}</span>

// ObjectError happens when access object error
type ObjectError struct {
        err    error
        bucket string
        object string
}

func (e ObjectError) Error() string <span class="cov10" title="4">{
        return fmt.Sprintf("%s, Bucket=%s, Object=%s", e.err.Error(), e.bucket, e.object)
}</span>

// FileError happens when access file error
type FileError struct {
        err  error
        file string
}

func (e FileError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s, File=%s", e.err.Error(), e.file)
}</span>

type CopyError struct {
        err error
}

func (e CopyError) Error() string <span class="cov0" title="0">{
        return e.err.Error()
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package lib

import (
        "crypto/md5"
        "encoding/base64"
        "fmt"
        "hash"
        "hash/crc64"
        "io"
        "os"
        "strings"
)

var specChineseHash = SpecText{

        synopsisText: "计算本地文件的crc64或md5",

        paramText: "file_url [options]",

        syntaxText: ` 
    ossutil hash file_url [--type=hashtype]
`,

        detailHelpText: ` 
    该命令计算本地文件的crc64值或md5/content-md5值, 可以通过--type选项来控制计算的类型，
    可选类型值为crc64或md5, 默认为` + DefaultHashType + `。

    注意：oss文件的crc64和content-md5值一般可通过stat命令查看到，参考` + StatCRC64 + `
    字段和` + StatContentMD5 + `字段。若文件在oss支持crc64功能之前上传，则stat命令不支持查看crc64值；
    对于append和multipart类型的文件，stat命令不支持查看content-md5值。

    crc64的计算标准参考ECMA-182标准(http://www.ecma-international.org/publications/standards/Ecma-182.htm)。

    计算类型为md5时，会同时输出文件的md5以及content-md5值。content-md5值其实是先计算md5
    值获得128比特位数字，然后对该数字进行base64编码得到的值。关于content-md5的更多信息，
    请参考https://tools.ietf.org/html/rfc1864。

用法:

    ossutil hash file_url [--type=hashtype] 
`,

        sampleText: ` 
    1) 计算本地文件的crc64: 
        ossutil hash test.txt 或 
        ossutil hash test.txt --type=crc64
   
        输出:
        CRC64-ECMA                  : 295992936743767023        
       
    2) 计算本地文件的md5: 
        ossutil hash test.txt --type=md5

        输出:
        MD5                         : 01C3C45C03B2AF225EFAD9F911A33D73
        Content-MD5                 : AcPEXAOyryJe+tn5EaM9cw==
`,
}

var specEnglishHash = SpecText{

        synopsisText: "Get crc64 or md5 of local file",

        paramText: "file_url [options]",

        syntaxText: ` 
    ossutil hash file_url [--type=hashtype]
`,

        detailHelpText: ` 
    The command calculate crc64 or md5/content-md5 value of the specified local file, 
    specify the hashtype by --type, default hashtype is ` + DefaultHashType + `. 

    Warning: user can use stat command to check the crc64 or md5/content-md5 value of 
    normal oss object, see the ` + StatCRC64 + ` and ` + StatContentMD5 + ` field. If the object 
    was uploaded to oss before oss support crc64 feature, stat result will not show 
    ` + StatCRC64 + `, if the object is append file type or multipart, stat result 
    will not show ` + StatContentMD5 + `. 

    Crc64 is calcuated according to ECMA-182(http://www.ecma-international.org/publications/standards/Ecma-182.htm).

    When hashtype is md5, it will output both md5 and content-md5 of local file. 
    Content-md5 is base64 encoded string of md5. For more detial about content-md5, 
    please refer to https://tools.ietf.org/html/rfc1864.

Usage:

    ossutil hash file_url [--type=hashtype] 
`,

        sampleText: ` 
    1) Get crc64 of local file: 
        ossutil hash test.txt or
        ossutil hash test.txt --type=crc64
        
        output: 
        CRC64-ECMA                  : 295992936743767023        

    2) Get md5  of local file: 
        ossutil hash test.txt --type=md5
         
        output:
        MD5                         : 01C3C45C03B2AF225EFAD9F911A33D73
        Content-MD5                 : AcPEXAOyryJe+tn5EaM9cw==
`,
}

// HashCommand is the command to get crc64/md5 of local file
type HashCommand struct {
        command Command
}

var hashCommand = HashCommand{
        command: Command{
                name:        "hash",
                nameAlias:   []string{""},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseHash,
                specEnglish: specEnglishHash,
                group:       GroupTypeAdditionalCommand,
                validOptionNames: []string{
                        OptionHashType,
                        OptionLogLevel,
                },
        },
}

// function for RewriteLoadConfiger interface
func (hc *HashCommand) rewriteLoadConfig(configFile string) error <span class="cov0" title="0">{
        // read config file, if error exist, do not print error
        var err error
        if hc.command.configOptions, err = LoadConfig(configFile); err != nil </span><span class="cov0" title="0">{
                hc.command.configOptions = OptionMapType{}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// function for FormatHelper interface
func (hc *HashCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return hc.command.formatHelpForWhole()
}</span>

func (hc *HashCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return hc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (hc *HashCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return hc.command.Init(args, options, hc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (hc *HashCommand) RunCommand() error <span class="cov0" title="0">{
        hashType, _ := GetString(OptionHashType, hc.command.options)
        path := hc.command.args[0]

        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        f.Seek(0, os.SEEK_SET)

        switch strings.ToLower(hashType) </span>{
        case MD5HashType:<span class="cov0" title="0">
                return hashMD5(f)</span>
        default:<span class="cov0" title="0">
                return hashCRC64(f)</span>
        }
}

func hashMD5(f io.Reader) error <span class="cov0" title="0">{
        md5Ins := md5.New()
        w, _ := md5Ins.(hash.Hash)
        if _, err := io.Copy(w, f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result := md5Ins.Sum(nil)
        fmt.Printf("%-28s: %X\n", HashMD5, result)

        encoded := base64.StdEncoding.EncodeToString(result)
        fmt.Printf("%-28s: %s\n", HashContentMD5, encoded)
        return nil</span>
}

func hashCRC64(f io.Reader) error <span class="cov0" title="0">{
        crc64Ins := crc64.New(crc64.MakeTable(crc64.ECMA))
        w, _ := crc64Ins.(hash.Hash)
        if _, err := io.Copy(w, f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">result := crc64Ins.Sum64()
        fmt.Printf("%-28s: %d\n", HashCRC64, result)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package lib

import (
        "fmt"
        "reflect"
        "strings"
)

// global public variable for formating help text
const (
        FormatTAB         = "    "
        MaxCommandNameLen = 18
        UsageTextChinese  = "用法: ossutil [command] [args...] [options...]\n请使用ossutil help command来显示command命令的帮助"
        UsageTextEnglish  = "Usage: ossutil [command] [args...] [options...]\nPlease use 'ossutil help command' to show help of command"
)

var specChineseHelp = SpecText{

        synopsisText: "获取命令的帮助文档",

        paramText: "[command]",

        syntaxText: ` 
    ossutil help [command]
`,

        detailHelpText: ` 
    该命令提供ossutil所有命令的帮助文档，或者针对用户输入的某具体命令提供它的帮助文档。

用法：

    该命令有两种用法：

    1) ossutil help
        该用法提供ossutil支持的所有命令的简介，对每个命令显示该命令的摘要和语法简介。

    2) ossutil help command
        该用法提供指定命令(command)的帮助文档，包括该命令的详细介绍、示例、可选参数。
`,

        sampleText: ` 
    ossutil help
    ossutil help help
    ossutil help ls
`,
}

var specEnglishHelp = SpecText{

        synopsisText: "Get help about commands",

        paramText: "[command]",

        syntaxText: ` 
    ossutil help [command]
`,

        detailHelpText: ` 
    The command provide the usage of all commands on which help is available, 
    or the usage of the specified command.

Usage:

    There are two usages:

    1) ossutil help
        The usage provides a summary of all commands, each command shows the
    synopsis and a simplified expression of the syntax.

    2) ossutil help command
        The usage provides help about the specified command, which contains
    a detailed description of the command, include samples and optional options.
`,

        sampleText: ` 
    ossutil help
    ossutil help help
    ossutil help ls
`,
}

// HelpCommand is the command format help text
type HelpCommand struct {
        command Command
}

var helpCommand = HelpCommand{
        command: Command{
                name:        "help",
                nameAlias:   []string{},
                minArgc:     0,
                maxArgc:     1,
                specChinese: specChineseHelp,
                specEnglish: specEnglishHelp,
                group:       GroupTypeAdditionalCommand,
                validOptionNames: []string{
                        OptionLanguage,
                        OptionLogLevel,
                },
        },
}

// function for RewriteLoadConfiger interface
func (hc *HelpCommand) rewriteLoadConfig(configFile string) error <span class="cov0" title="0">{
        // read config file, if error exist, do not print error
        var err error
        if hc.command.configOptions, err = LoadConfig(configFile); err != nil </span><span class="cov0" title="0">{
                hc.command.configOptions = OptionMapType{}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// function for FormatHelper interface
func (hc *HelpCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return hc.command.formatHelpForWhole()
}</span>

func (hc *HelpCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return hc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (hc *HelpCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return hc.command.Init(args, options, hc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (hc *HelpCommand) RunCommand() error <span class="cov0" title="0">{
        groupCommandMap, subCommandMap := hc.getCommandMap()
        if len(hc.command.args) == 0 </span><span class="cov0" title="0">{
                // ossutil help
                text := hc.formatWholeHelp(groupCommandMap)
                Output(text)
        }</span> else<span class="cov0" title="0"> {
                //ossutil help command
                if text, err := hc.formatCommandHelp(subCommandMap); err == nil </span><span class="cov0" title="0">{
                        Output(text)
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (hc *HelpCommand) getCommandMap() (map[string][]interface{}, map[string]interface{}) <span class="cov0" title="0">{
        commandList := GetAllCommands()
        groupCommandMap := map[string][]interface{}{}
        subCommandMap := map[string]interface{}{}
        for _, cmd := range commandList </span><span class="cov0" title="0">{
                group := reflect.ValueOf(cmd).Elem().FieldByName("command").FieldByName("group").String()
                groupCommandMap[group] = append(groupCommandMap[group], cmd)
                name := reflect.ValueOf(cmd).Elem().FieldByName("command").FieldByName("name").String()
                subCommandMap[name] = cmd
        }</span>
        <span class="cov0" title="0">return groupCommandMap, subCommandMap</span>
}

func (hc *HelpCommand) formatWholeHelp(groupCommandMap map[string][]interface{}) string <span class="cov0" title="0">{
        if len(groupCommandMap) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">commandsText := ""
        for _, group := range CommandGroups </span><span class="cov0" title="0">{
                commandList := groupCommandMap[group]
                if len(commandList) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">commandsText += group
                for _, cmd := range commandList </span><span class="cov0" title="0">{
                        commandsText += cmd.(FormatHelper).formatHelpForWhole()
                }</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s\n%s", hc.getUsageText(), commandsText)</span>
}

func (hc *HelpCommand) getUsageText() string <span class="cov0" title="0">{
        val, _ := GetString(OptionLanguage, helpCommand.command.options)
        switch strings.ToLower(val) </span>{
        case LEnglishLanguage:<span class="cov0" title="0">
                return UsageTextEnglish</span>
        default:<span class="cov0" title="0">
                return UsageTextChinese</span>
        }

}

func (hc *HelpCommand) formatCommandHelp(subCommandMap map[string]interface{}) (string, error) <span class="cov0" title="0">{
        subCommandName := hc.command.args[0]
        if cmd, ok := subCommandMap[subCommandName]; ok </span><span class="cov0" title="0">{
                return cmd.(FormatHelper).formatIndependHelp(), nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("no such command: \"%s\", please try \"help\" for more information", subCommandName)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// This is for Condition Compling, which means it will be built on all non-windows platform.

// +build !windows

package lib

import (
        "os"
        "strings"
)

func getOsLang() string <span class="cov8" title="1">{
        lang := os.Getenv("LANG")
        langstr := strings.Split(lang, ".")

        if langstr[0] == "zh_CN" </span><span class="cov0" title="0">{
                return ChineseLanguage
        }</span>
        <span class="cov8" title="1">return EnglishLanguage</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package lib

import (
        "fmt"
        "strconv"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseListPart = SpecText{
        synopsisText: "列出没有完成分块上传的object的分块信息",

        paramText: "oss_object uploadid [options]",

        syntaxText: ` 
        ossutil listpart oss://bucket/object uploadid [options]
`,

        detailHelpText: ` 
        可以通过ls命令查看bucket的object和uploadid信息，在用本命令查看详细信息
  

用法：

    该命令只有一种用法：

    1) ossutil listpart oss://bucket/object uploadid [options]
      根据object和uploadid查询块信息
`,

        sampleText: ` 
        1) 根据object和uploadid查询块信息
       ossutil listpart oss://bucket/object 8A1912289A705A5F0503FCA71DABFD5A
`,
}

var specEnglishListPart = SpecText{
        synopsisText: "List parts information of uncompleted multipart object",

        paramText: "oss_object uploadid [options]",

        syntaxText: ` 
        ossutil listpart oss://bucket/object uploadid [options]
`,

        detailHelpText: ` 
        You can use the ls command to view the object and uploadid information of a bucket.
    Then Use this command to view detailed part information.

Usages：

    There is only one usage for this command:

    1) ossutil listpart oss://bucket/object uploadid [options]

      Query parts information according to object and uploadid
`,

        sampleText: ` 
        1) Query parts information according to object and uploadid

      ossutil listpart oss://bucket/object 8A1912289A705A5F0503FCA71DABFD5A
`,
}

type listPartOptionType struct {
        cloudUrl     CloudURL
        uploadId     string
        encodingType string
}

type ListPartCommand struct {
        command  Command
        lpOption listPartOptionType
}

var listPartCommand = ListPartCommand{
        command: Command{
                name:        "listpart",
                nameAlias:   []string{"listpart"},
                minArgc:     2,
                maxArgc:     2,
                specChinese: specChineseListPart,
                specEnglish: specEnglishListPart,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionEncodingType,
                        OptionLogLevel,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (lpc *ListPartCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return lpc.command.formatHelpForWhole()
}</span>

func (lpc *ListPartCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return lpc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (lpc *ListPartCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return lpc.command.Init(args, options, lpc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (lpc *ListPartCommand) RunCommand() error <span class="cov0" title="0">{
        lpc.lpOption.encodingType, _ = GetString(OptionEncodingType, lpc.command.options)
        srcBucketUrL, err := GetCloudUrl(lpc.command.args[0], lpc.lpOption.encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if srcBucketUrL.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("object name is empty")
        }</span>

        <span class="cov0" title="0">lpc.lpOption.cloudUrl = *srcBucketUrL
        lpc.lpOption.uploadId = lpc.command.args[1]

        return lpc.ListPart()</span>
}

func (lpc *ListPartCommand) ListPart() error <span class="cov0" title="0">{
        client, err := lpc.command.ossClient(lpc.lpOption.cloudUrl.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := client.Bucket(lpc.lpOption.cloudUrl.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var imur oss.InitiateMultipartUploadResult
        imur.Bucket = lpc.lpOption.cloudUrl.bucket
        imur.Key = lpc.lpOption.cloudUrl.object
        imur.UploadID = lpc.lpOption.uploadId

        partNumberMarker := 0
        totalPartCount := 0
        var totalPartSize int64 = 0
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                lpOptions := []oss.Option{}
                lpOptions = append(lpOptions, oss.MaxParts(1000))
                lpOptions = append(lpOptions, oss.PartNumberMarker(partNumberMarker))

                lpRes, err := bucket.ListUploadedParts(imur, lpOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov0" title="0"> {
                        totalPartCount += len(lpRes.UploadedParts)
                        if i == 0 &amp;&amp; len(lpRes.UploadedParts) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("%-10s\t%-32s\t%-10s\t%s\n", "PartNumber", "Etag", "Size(Byte)", "LastModifyTime")
                        }</span>
                }

                <span class="cov0" title="0">for _, v := range lpRes.UploadedParts </span><span class="cov0" title="0">{
                        //PartNumber,ETag,Size,LastModified
                        fmt.Printf("%-10d\t%-32s\t%-10d\t%s\n", v.PartNumber, v.ETag, v.Size, v.LastModified.Format("2006-01-02 15:04:05"))
                        totalPartSize += int64(v.Size)
                }</span>

                <span class="cov0" title="0">if lpRes.IsTruncated </span><span class="cov0" title="0">{
                        partNumberMarker, err = strconv.Atoi(lpRes.NextPartNumberMarker)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if totalPartCount &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\ntotal part count:%d\ttotal part size(MB):%.2f\n\n", totalPartCount, float64(totalPartSize/1024)/1024)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package lib

import (
        "fmt"
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseList = SpecText{

        synopsisText: "列举Buckets或者Objects",

        paramText: "[cloud_url] [options]",

        syntaxText: ` 
    ossutil ls [oss://bucket[/prefix]] [-s] [-d] [-m] [--limited-num num] [--marker marker] [--upload-id-marker umarker] [--payer requester] [--include include-pattern] [--exclude exclude-pattern]  [--version-id-marker id_marker] [--all-versions]  [-c file] 
`,

        detailHelpText: ` 
    该命令列举指定身份凭证下的buckets，或该身份凭证下对应endpoint的objects。默认显示长格式，
    ossutil在列举buckets或者objects的同时展示它们的一些附加信息。如果指定了--short-format选
    项，则显示精简格式。

--encoding-type选项

    如果指定了encoding-type为url，则表示输入的object（或prefix）为经过url编码的，此时如果指定了
    --marker选项或--upload-id-marker选项，ossutil默认指定的marker或upload-id-marker也同样是经过
    url编码的。注意：形如oss://bucket/object的cloud_url，输入形式为：oss://bucket/url_encode(object)，
    其中oss://bucket/字符串不需要编码。

--include和--exclude选项

    可以指定该选项以指定规则筛选要操作的文件/object

    规则支持以下格式：
    *：匹配索引
    ?：匹配单个字符
    [sequence]：匹配sequence的任意字符
    [!sequence]：匹配不在sequence的任意字符
    注意：规则不支持带目录的格式，e.g.，--include "/usr/*/test/*.jpg"。

    --include和--exclude可以出现多次。当多个规则出现时，这些规则按从左往右的顺序应用

用法：

    该命令有两种用法：

    1) ossutil ls [oss://] [-s] [--limited-num num] [--marker marker]
        如果用户列举时缺失cloud_url参数，则ossutil获取用户的身份凭证信息（从配置文件中读取），
    并列举该身份凭证下的所有buckets，并显示每个bucket的最新更新时间，位置，存储方式等信息。
    如果指定了--short-format选项则只输出bucket名称。该用法不支持--directory选项。

    2) ossutil ls oss://bucket[/prefix] [-s] [-d] [-m] [-a] [--limited-num num] [--marker marker] [--upload-id-marker umarker]  [--version-id-marker id_marker] [--all-versions]
        如果未指定--multipart和--all-type选项，则ossutil列举指定bucket下的objects（如果指定
    了前缀，则列举拥有该前缀的objects）。并同时展示object大小，最新更新时间和etag，但是如果
    指定了--short-format选项则只输出object名称。如果指定了--directory选项，则返回指定bucket
    下以指定前缀开头的第一层目录下的文件和子目录，但是不递归显示所有子目录，此时默认为精简
    格式。所有的目录均以/结尾。
        如果指定了--multipart选项，则显示指定URL(oss://bucket[/prefix])下未完成的上传任务，
    即，列举未complete的Multipart Upload事件的uploadId，这些Multipart Upload事件的object名
    称以指定的prefix为前缀。ossutil同时显示uploadId的init时间。该选项同样支持--short-format
    和--directory选项。（Multipart同样用于cp命令中大文件的断点续传，关于Multipart的更多信息
    见：https://help.aliyun.com/document_detail/31991.html?spm=5176.doc31992.6.880.VOSDk5）。
        如果指定了--all-type选项，则显示指定URL(oss://bucket[/prefix])下的object和未完成的
        上传任务（即，同时列举以prefix为前缀的object，和object名称以prefix为前缀的所有未complete
    的uploadId）。该选项同样支持--short-format和--directory选项。
        如果指定了--limited-num选项，ossutil总共会输出的对象个数不超过limited-num个，当同时
    输出object和Multipart Upload时，两者的总数不超过limited-num个。
        在列举objects时，--upload-id-marker选项不起作用。在列举Multipart Uploads事件时，--marker
    和--upload-id-marker选项同时限定了列举的起始位置，更多信息请见oss的官网：
    https://help.aliyun.com/document_detail/31997.html?spm=5176.doc31965.6.887.MK6GVw.
`,

        sampleText: ` 
    1) ossutil ls -s
        oss://bucket1
        oss://bucket2
        oss://bucket3
        Bucket Number is: 3

    2) ossutil ls oss:// -s
        oss://bucket1
        oss://bucket2
        oss://bucket3
        Bucket Number is: 3

    3) ossutil ls oss://bucket1 -s
        oss://bucket1/dir1/obj11
        oss://bucket1/obj1
        oss://bucket1/sample.txt
        Object Number is: 3

    4) ossutil ls oss://bucket1
        LastModifiedTime              Size(B)  StorageClass   ETAG                              ObjectName
        2015-06-05 14:06:29 +0000 CST  201933      Standard   7E2F4A7F1AC9D2F0996E8332D5EA5B41  oss://bucket1/dir1/obj11
        2015-06-05 14:36:21 +0000 CST  201933      Standard   6185CA2E8EB8510A61B3A845EAFE4174  oss://bucket1/obj1
        2016-04-08 14:50:47 +0000 CST 6476984      Standard   4F16FDAE7AC404CEC8B727FCC67779D6  oss://bucket1/sample.txt
        Object Number is: 3

    5) ossutil ls oss://bucket1 -d
        oss://bucket1/obj1
        oss://bucket1/dir1
        oss://bucket1/sample.txt
        Object and Directory Number is: 3

    6) ossutil ls oss://bucket1 -m 
        InitiatedTime                  UploadID                          ObjectName
        2017-01-13 03:45:26 +0000 CST  15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2017-01-13 03:45:25 +0000 CST  3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        2017-01-20 11:16:21 +0800 CST  A20157A7B2FEC4670626DAE0F4C0073C  oss://bucket1/tobj
        UploadID Number is: 3
    
    7) ossutil ls oss://bucket1/obj -m 
        InitiatedTime                  UploadID                          ObjectName
        2017-01-13 03:45:26 +0000 CST  15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2017-01-13 03:45:25 +0000 CST  3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        UploadID Number is: 2
 
    8) ossutil ls oss://bucket1 -a 
        LastModifiedTime              Size(B)  StorageClass   ETAG                              ObjectName
        2015-06-05 14:06:29 +0000 CST  201933      Standard   7E2F4A7F1AC9D2F0996E8332D5EA5B41  oss://bucket1/dir1/obj11
        2015-06-05 14:36:21 +0000 CST  201933      Standard   6185CA2E8EB8510A61B3A845EAFE4174  oss://bucket1/obj1
        2016-04-08 14:50:47 +0000 CST 6476984      Standard   4F16FDAE7AC404CEC8B727FCC67779D6  oss://bucket1/sample.txt
        Object Number is: 3
        InitiatedTime                  UploadID                          ObjectName
        2017-01-13 03:45:26 +0000 CST  15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2017-01-13 03:43:13 +0000 CST  2A1F9B4A95E341BD9285CC42BB950EE0  oss://bucket1/obj1
        2017-01-13 03:45:25 +0000 CST  3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        2017-01-20 11:16:21 +0800 CST  A20157A7B2FEC4670626DAE0F4C0073C  oss://bucket1/tobj
        UploadID Number is: 4
         
    9) ossutil ls oss://bucket1/obj -a 
        LastModifiedTime              Size(B)  StorageClass   ETAG                              ObjectName
        2015-06-05 14:36:21 +0000 CST  201933      Standard   6185CA2E8EB8510A61B3A845EAFE4174  oss://bucket1/obj1
        Object Number is: 1
        InitiatedTime                  UploadID                          ObjectName
        2017-01-13 03:45:26 +0000 CST  15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2017-01-13 03:43:13 +0000 CST  2A1F9B4A95E341BD9285CC42BB950EE0  oss://bucket1/obj1
        2017-01-13 03:45:25 +0000 CST  3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        UploadID Number is: 3

    10) ossutil ls oss://bucket1/obj -a -s 
        oss://bucket1/obj1
        Object Number is: 1
        UploadID                          ObjectName
        15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2A1F9B4A95E341BD9285CC42BB950EE0  oss://bucket1/obj1
        3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        UploadID Number is: 3

    11) ossutil ls oss://bucket1/obj -a -s --marker=obj1 
        Object Number is: 0
        UploadID                          ObjectName
        3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        UploadID Number is: 1

    12) ossutil ls oss://bucket1/obj -a -s --limited-num=2 
        oss://bucket1/obj1
        Object Number is: 1
        UploadID                          ObjectName
        15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        UploadID Number is: 1

    13) ossutil ls oss://bucket1/%e4%b8%ad%e6%96%87 --encoding-type url
        LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
        2017-03-17 17:34:40 +0800 CST      8345742      Standard   BBCC8C0954B869B4A6B34D9404C5BCFD      oss://bucket1/中文
        Object Number is: 1
        0.066567(s) elapsed
    
    14) ossutil ls oss://bucket --include "*.avi" --include "*.mp4" --exclude "*.png" --exclude "*.jpg"
        LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
        2019-05-30 14:23:51 +0800 CST         1030      Standard   4A902D176BE0EE4224BC196BBB8CCC69      oss://bucket/test.avi
        2019-05-30 14:24:05 +0800 CST         1030      Standard   4A902D176BE0EE4224BC196BBB8CCC69      oss://bucket/test.mp4
        Object Number is: 2

    15) ossutil ls oss://bucket --all-versions
`,
}

var specEnglishList = SpecText{

        synopsisText: "List Buckets or Objects",

        paramText: "[cloud_url] [options]",

        syntaxText: ` 
    ossutil ls [oss://bucket[/prefix]] [-s] [-d] [-m] [--limited-num num] [--marker marker] [--upload-id-marker umarker] [--payer requester] [--include include-pattern] [--exclude exclude-pattern]  [--version-id-marker id_marker] [--all-versions]  [-c file] 
`,

        detailHelpText: ` 
    The command list buckets of the specified credentials. or objects of the specified 
    endpoint and credentials, with simple additional information, about each matching 
    provider, bucket, subdirectory, or object. If --short-format option is specified, 
    ossutil will show by short format. 

--encoding-type option

    If the --encoding-type option is setted to url, the object/prefix inputted is url 
    encoded, if the --marker option or --upload-id-marker option is specified, ossutil 
    will consider the marker or upload-id-marker inputted is also url encoded.

    Note: If the option is specified, the cloud_url like: oss://bucket/object should be 
    inputted as: oss://bucket/url_encode(object), the string: oss://bucket/ should not 
    be url encoded. 

--include and --exclude option:

    These parameters perform pattern matching to either exclude or include a particular file or object

    The following pattern symbols are supported.
    *: Matches everything
    ?: Matches any single character
    [sequence]: Matches any character in sequence
    [!sequence]: Matches any character not in sequence
    Note: does not support patterns containing directory info. e.g., --include "/usr/*/test/*.jpg" 

    Any number of these parameters can be passed to a command. You can do this by providing an --exclude
    or --include argument multiple times, e.g.,
      --include "*.txt" --include "*.png". 
    When there are multi filters, the rule is the filters that appear later in the command take precedence
    over filters that appear earlier in the command

Usage:

    There are two usages:

    1) ossutil ls [oss://] [-s] [--limited-num num] [--marker marker]
        If you list without a cloud_url, ossutil lists all the buckets using the credentials
    in config file with last modified time and location in addition. --show_format option 
    will ignore last modified time and location. The usage do not support --directory 
    option.

    2) ossutil ls oss://bucket[/prefix] [-s] [-d] [-m] [-a] [--limited-num num] [--marker marker] [--upload-id-marker umarker] [--version-id-marker id_marker] [--all-versions]
        If you list without --multipart and --all-type option, ossutil will list objects 
    in the specified bucket(with the prefix if you specified), with object size, last 
    modified time and etag in addition, --short-format option ignores all the additional 
    information. --directory option returns top-level subdirectory names instead of contents 
    of the subdirectory, which in default show by short format. the directory is end with /. 
        --multipart option will show multipart upload tasks under the cloud_url(oss://bucket[/prefix]), 
    which means, ossutil will show the uploadId of those uncompleted multipart, whose object 
    name starts with the specified prefix. ossutil will show the init time of uploadId meanwhile. 
    The usage also supports --short-format and --directory option. (Multipart upload is also used 
    in resume cp. More information about multipart see: https://help.aliyun.com/document_detail/31991.html?spm=5176.doc31992.6.880.VOSDk5). 
        --all-type option will show objects and multipart upload tasks under the cloud_url(oss://bucket[/prefix]),  
    which means, ossutil will both show the objects with the specified prefix and the uploadId of 
    those uncompleted multipart, whose object name starts with the specified prefix. The usage also 
    support --short-format and --directory option.
        If user specified --limited-num option, the total num will not exceed the num. If user list 
    objects and Multipart Uploads meanwhile, the total num of objects and Multipart Uploads will not 
    exceed the num. 
        --upload-id-marker option is not effective when list objects. When list Multipart Uploads, 
    --marker option and --upload-id-marker option decide the initial position of listing meanwhile,
    for more initial, see: https://help.aliyun.com/document_detail/31997.html?spm=5176.doc31965.6.887.MK6GVw.
`,

        sampleText: ` 
    1) ossutil ls -s
        oss://bucket1
        oss://bucket2
        oss://bucket3
        Bucket Number is: 3

    2) ossutil ls oss:// -s
        oss://bucket1
        oss://bucket2
        oss://bucket3
        Bucket Number is: 3

    3) ossutil ls oss://bucket1 -s
        oss://bucket1/dir1/obj11
        oss://bucket1/obj1
        oss://bucket1/sample.txt
        Object Number is: 3

    4) ossutil ls oss://bucket1
        LastModifiedTime              Size(B)  StorageClass   ETAG                              ObjectName
        2015-06-05 14:06:29 +0000 CST  201933      Standard   7E2F4A7F1AC9D2F0996E8332D5EA5B41  oss://bucket1/dir1/obj11
        2015-06-05 14:36:21 +0000 CST  201933      Standard   6185CA2E8EB8510A61B3A845EAFE4174  oss://bucket1/obj1
        2016-04-08 14:50:47 +0000 CST 6476984      Standard   4F16FDAE7AC404CEC8B727FCC67779D6  oss://bucket1/sample.txt
        Object Number is: 3

    5) ossutil ls oss://bucket1 -d
        oss://bucket1/obj1
        oss://bucket1/dir1
        oss://bucket1/sample.txt
        Object and Directory Number is: 3

    6) ossutil ls oss://bucket1 -m 
        InitiatedTime                  UploadID                          ObjectName
        2017-01-13 03:45:26 +0000 CST  15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2017-01-13 03:45:25 +0000 CST  3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        2017-01-20 11:16:21 +0800 CST  A20157A7B2FEC4670626DAE0F4C0073C  oss://bucket1/tobj
        UploadID Number is: 3
    
    7) ossutil ls oss://bucket1/obj -m 
        InitiatedTime                  UploadID                          ObjectName
        2017-01-13 03:45:26 +0000 CST  15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2017-01-13 03:45:25 +0000 CST  3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        UploadID Number is: 2
 
    8) ossutil ls oss://bucket1 -a 
        LastModifiedTime              Size(B)  StorageClass   ETAG                              ObjectName
        2015-06-05 14:06:29 +0000 CST  201933      Standard   7E2F4A7F1AC9D2F0996E8332D5EA5B41  oss://bucket1/dir1/obj11
        2015-06-05 14:36:21 +0000 CST  201933      Standard   6185CA2E8EB8510A61B3A845EAFE4174  oss://bucket1/obj1
        2016-04-08 14:50:47 +0000 CST 6476984      Standard   4F16FDAE7AC404CEC8B727FCC67779D6  oss://bucket1/sample.txt
        Object Number is: 3
        InitiatedTime                  UploadID                          ObjectName
        2017-01-13 03:45:26 +0000 CST  15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2017-01-13 03:43:13 +0000 CST  2A1F9B4A95E341BD9285CC42BB950EE0  oss://bucket1/obj1
        2017-01-13 03:45:25 +0000 CST  3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        2017-01-20 11:16:21 +0800 CST  A20157A7B2FEC4670626DAE0F4C0073C  oss://bucket1/tobj
        UploadID Number is: 4
         
    9) ossutil ls oss://bucket1/obj -a 
        LastModifiedTime              Size(B)  StorageClass   ETAG                              ObjectName
        2015-06-05 14:36:21 +0000 CST  201933      Standard   6185CA2E8EB8510A61B3A845EAFE4174  oss://bucket1/obj1
        Object Number is: 1
        InitiatedTime                  UploadID                          ObjectName
        2017-01-13 03:45:26 +0000 CST  15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2017-01-13 03:43:13 +0000 CST  2A1F9B4A95E341BD9285CC42BB950EE0  oss://bucket1/obj1
        2017-01-13 03:45:25 +0000 CST  3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        UploadID Number is: 3

    10) ossutil ls oss://bucket1/obj -a -s 
        oss://bucket1/obj1
        Object Number is: 1
        UploadID                          ObjectName
        15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        2A1F9B4A95E341BD9285CC42BB950EE0  oss://bucket1/obj1
        3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        UploadID Number is: 3

    11) ossutil ls oss://bucket1/obj -a -s --marker=obj1 
        Object Number is: 0
        UploadID                          ObjectName
        3998971ACAF94AD9AC48EAC1988BE863  oss://bucket1/obj2
        UploadID Number is: 1

    12) ossutil ls oss://bucket1/obj -a -s --limited-num=2 
        oss://bucket1/obj1
        Object Number is: 1
        UploadID                          ObjectName
        15754AF7980C4DFB8193F190837520BB  oss://bucket1/obj1
        UploadID Number is: 1

    13) ossutil ls oss://bucket1/%e4%b8%ad%e6%96%87 --encoding-type url
        LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
        2017-03-17 17:34:40 +0800 CST      8345742      Standard   BBCC8C0954B869B4A6B34D9404C5BCFD      oss://bucket1/中文
        Object Number is: 1
        0.066567(s) elapsed
    
    14) ossutil ls oss://bucket --include "*.avi" --include "*.mp4" --exclude "*.png" --exclude "*.jpg"
        LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
        2019-05-30 14:23:51 +0800 CST         1030      Standard   4A902D176BE0EE4224BC196BBB8CCC69      oss://bucket/test.avi
        2019-05-30 14:24:05 +0800 CST         1030      Standard   4A902D176BE0EE4224BC196BBB8CCC69      oss://bucket/test.mp4
        Object Number is: 2
    15) ossutil ls oss://bucket[/prefix] --all-versions
`,
}

// ListCommand is the command list buckets or objects
type ListCommand struct {
        command     Command
        payerOption oss.Option
        filters     []filterOptionType
}

var listCommand = ListCommand{
        command: Command{
                name:        "ls",
                nameAlias:   []string{"list"},
                minArgc:     0,
                maxArgc:     1,
                specChinese: specChineseList,
                specEnglish: specEnglishList,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionLogLevel,
                        OptionRequestPayer,
                        OptionShortFormat,
                        OptionDirectory,
                        OptionMultipart,
                        OptionAllType,
                        OptionLimitedNum,
                        OptionMarker,
                        OptionUploadIDMarker,
                        OptionEncodingType,
                        OptionInclude,
                        OptionExclude,
                        OptionAllversions,
                        OptionVersionIdMarker,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (lc *ListCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return lc.command.formatHelpForWhole()
}</span>

func (lc *ListCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return lc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (lc *ListCommand) Init(args []string, options OptionMapType) error <span class="cov4" title="2">{
        return lc.command.Init(args, options, lc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (lc *ListCommand) RunCommand() error <span class="cov4" title="2">{
        if len(lc.command.args) == 0 </span><span class="cov4" title="2">{
                return lc.listBuckets("")
        }</span>

        <span class="cov0" title="0">encodingType, _ := GetString(OptionEncodingType, lc.command.options)
        cloudURL, err := CloudURLFromString(lc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">payer, _ := GetString(OptionRequestPayer, lc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span> else<span class="cov0" title="0"> {
                        lc.payerOption = oss.RequestPayer(oss.PayerType(payer))
                }</span>
        }

        <span class="cov0" title="0">if cloudURL.bucket == "" </span><span class="cov0" title="0">{
                return lc.listBuckets("")
        }</span>

        <span class="cov0" title="0">var res bool
        res, lc.filters = getFilter(os.Args)
        if !res </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude does not support format containing dir info")
        }</span>

        <span class="cov0" title="0">return lc.listFiles(cloudURL)</span>
}

func (lc *ListCommand) listBuckets(prefix string) error <span class="cov4" title="2">{
        var err error
        if err = lc.lbCheckArgOptions(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">shortFormat, _ := GetBool(OptionShortFormat, lc.command.options)
        limitedNum, _ := GetInt(OptionLimitedNum, lc.command.options)
        vmarker, _ := GetString(OptionMarker, lc.command.options)
        if vmarker, err = lc.command.getRawMarker(vmarker); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid marker: %s, marker is not url encoded, %s", vmarker, err.Error())
        }</span>

        <span class="cov4" title="2">var num int64
        num = 0

        client, err := lc.command.ossClient("")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // list all buckets
        <span class="cov4" title="2">pre := oss.Prefix(prefix)
        marker := oss.Marker(vmarker)
        payer := lc.payerOption
        for limitedNum &lt; 0 || num &lt; limitedNum </span><span class="cov4" title="2">{
                lbr, err := lc.ossListBucketsRetry(client, pre, marker, payer)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="2">pre = oss.Prefix(lbr.Prefix)
                marker = oss.Marker(lbr.NextMarker)
                if num == 0 &amp;&amp; !shortFormat &amp;&amp; len(lbr.Buckets) &gt; 0 </span><span class="cov4" title="2">{
                        fmt.Printf("%-30s %20s%s%12s%s%s\n", "CreationTime", "Region", FormatTAB, "StorageClass", FormatTAB, "BucketName")
                }</span>
                <span class="cov4" title="2">for _, bucket := range lbr.Buckets </span><span class="cov10" title="6">{
                        if limitedNum &gt;= 0 &amp;&amp; num &gt;= limitedNum </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov10" title="6">if !shortFormat </span><span class="cov10" title="6">{
                                fmt.Printf("%-30s %20s%s%12s%s%s\n", utcToLocalTime(bucket.CreationDate), bucket.Location, FormatTAB, bucket.StorageClass, FormatTAB, CloudURLToString(bucket.Name, ""))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println(CloudURLToString(bucket.Name, ""))
                        }</span>
                        <span class="cov10" title="6">num++</span>
                }
                <span class="cov4" title="2">if !lbr.IsTruncated </span><span class="cov4" title="2">{
                        break</span>
                }
        }
        <span class="cov4" title="2">fmt.Printf("Bucket Number is: %d\n", num)
        return nil</span>
}

func (lc *ListCommand) lbCheckArgOptions() error <span class="cov4" title="2">{
        if ok, _ := GetBool(OptionDirectory, lc.command.options); ok </span><span class="cov0" title="0">{
                return fmt.Errorf("ListBucket does not support option: \"%s\"", OptionDirectory)
        }</span>
        <span class="cov4" title="2">return nil</span>
}

func (lc *ListCommand) ossListBucketsRetry(client *oss.Client, options ...oss.Option) (oss.ListBucketsResult, error) <span class="cov4" title="2">{
        retryTimes, _ := GetInt(OptionRetryTimes, lc.command.options)
        for i := 1; ; i++ </span><span class="cov4" title="2">{
                lbr, err := client.ListBuckets(options...)
                if err == nil || int64(i) &gt;= retryTimes </span><span class="cov4" title="2">{
                        return lbr, err
                }</span>
        }
}

func (lc *ListCommand) listFiles(cloudURL CloudURL) error <span class="cov0" title="0">{
        bucket, err := lc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">shortFormat, _ := GetBool(OptionShortFormat, lc.command.options)
        directory, _ := GetBool(OptionDirectory, lc.command.options)
        limitedNum, _ := GetInt(OptionLimitedNum, lc.command.options)
        allVersions, _ := GetBool(OptionAllversions, lc.command.options)
        typeSet := lc.getSubjectType()
        if typeSet&amp;objectType != 0 </span><span class="cov0" title="0">{
                if !allVersions </span><span class="cov0" title="0">{
                        _, err = lc.listObjects(bucket, cloudURL, shortFormat, directory, &amp;limitedNum)
                }</span> else<span class="cov0" title="0"> {
                        _, err = lc.listObjectVersions(bucket, cloudURL, shortFormat, directory, &amp;limitedNum)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if typeSet&amp;multipartType != 0 </span><span class="cov0" title="0">{
                if _, err := lc.listMultipartUploads(bucket, cloudURL, shortFormat, directory, &amp;limitedNum); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (lc *ListCommand) getSubjectType() int64 <span class="cov0" title="0">{
        var typeSet int64
        typeSet = 0
        if isMultipart, _ := GetBool(OptionMultipart, lc.command.options); isMultipart </span><span class="cov0" title="0">{
                typeSet |= multipartType
        }</span>
        <span class="cov0" title="0">if isAllType, _ := GetBool(OptionAllType, lc.command.options); isAllType </span><span class="cov0" title="0">{
                typeSet |= allType
        }</span>
        <span class="cov0" title="0">if typeSet&amp;allType == 0 </span><span class="cov0" title="0">{
                typeSet = objectType
        }</span>
        <span class="cov0" title="0">return typeSet</span>
}

func (lc *ListCommand) listObjects(bucket *oss.Bucket, cloudURL CloudURL, shortFormat bool, directory bool, limitedNum *int64) (int64, error) <span class="cov0" title="0">{
        //list all objects or directories
        var err error
        var num int64
        num = 0
        pre := oss.Prefix(cloudURL.object)
        vmarker, _ := GetString(OptionMarker, lc.command.options)
        if vmarker, err = lc.command.getRawMarker(vmarker); err != nil </span><span class="cov0" title="0">{
                return num, fmt.Errorf("invalid marker: %s, marker is not url encoded, %s", vmarker, err.Error())
        }</span>
        <span class="cov0" title="0">marker := oss.Marker(vmarker)
        del := oss.Delimiter("")
        if directory </span><span class="cov0" title="0">{
                del = oss.Delimiter("/")
        }</span>
        <span class="cov0" title="0">payer := lc.payerOption

        var i int64
        for i = 0; ; i++ </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">lor, err := lc.command.ossListObjectsRetry(bucket, marker, pre, del, payer, oss.MaxKeys(1000))
                if err != nil </span><span class="cov0" title="0">{
                        return num, err
                }</span>
                <span class="cov0" title="0">pre = oss.Prefix(lor.Prefix)
                marker = oss.Marker(lor.NextMarker)
                num += lc.displayObjectsResult(lor, cloudURL.bucket, shortFormat, directory, i, limitedNum)
                if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if !directory </span><span class="cov0" title="0">{
                fmt.Printf("Object Number is: %d\n", num)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Object and Directory Number is: %d\n", num)
        }</span>

        <span class="cov0" title="0">return num, nil</span>
}

func (lc *ListCommand) listObjectVersions(bucket *oss.Bucket, cloudURL CloudURL, shortFormat bool, directory bool, limitedNum *int64) (int64, error) <span class="cov0" title="0">{
        //list all object versions or directories
        var err error
        var num int64
        num = 0
        pre := oss.Prefix(cloudURL.object)
        vmarker, _ := GetString(OptionMarker, lc.command.options)
        if vmarker, err = lc.command.getRawMarker(vmarker); err != nil </span><span class="cov0" title="0">{
                return num, fmt.Errorf("invalid marker: %s, marker is not url encoded, %s", vmarker, err.Error())
        }</span>
        <span class="cov0" title="0">marker := oss.KeyMarker(vmarker)

        strVersionIdMarker, _ := GetString(OptionVersionIdMarker, lc.command.options)
        if strVersionIdMarker, err = lc.command.getRawMarker(strVersionIdMarker); err != nil </span><span class="cov0" title="0">{
                return num, fmt.Errorf("invalid versionIdMarker: %s, versionIdMarker is not url encoded, %s", strVersionIdMarker, err.Error())
        }</span>
        <span class="cov0" title="0">versionIdMarker := oss.VersionIdMarker(strVersionIdMarker)

        del := oss.Delimiter("")
        if directory </span><span class="cov0" title="0">{
                del = oss.Delimiter("/")
        }</span>
        <span class="cov0" title="0">payer := lc.payerOption

        var i int64
        for i = 0; ; i++ </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">lor, err := bucket.ListObjectVersions(marker, pre, del, payer, versionIdMarker)
                if err != nil </span><span class="cov0" title="0">{
                        return num, err
                }</span>
                <span class="cov0" title="0">pre = oss.Prefix(lor.Prefix)
                marker = oss.KeyMarker(lor.NextKeyMarker)
                versionIdMarker = oss.VersionIdMarker(lor.NextVersionIdMarker)
                num += lc.displayObjectVersionsResult(lor, cloudURL.bucket, shortFormat, directory, i, limitedNum)
                if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if !directory </span><span class="cov0" title="0">{
                fmt.Printf("Object Number is: %d\n", num)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Object and Directory Number is: %d\n", num)
        }</span>
        <span class="cov0" title="0">return num, nil</span>
}

func (lc *ListCommand) displayObjectsResult(lor oss.ListObjectsResult, bucket string, shortFormat bool, directory bool, i int64, limitedNum *int64) int64 <span class="cov0" title="0">{
        if i == 0 &amp;&amp; !shortFormat &amp;&amp; !directory &amp;&amp; len(lor.Objects) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("%-30s%12s%s%12s%s%-36s%s%s\n", "LastModifiedTime", "Size(B)", "  ", "StorageClass", "   ", "ETAG", "  ", "ObjectName")
        }</span>

        <span class="cov0" title="0">var num int64
        if !directory </span><span class="cov0" title="0">{
                num = lc.showObjects(lor, bucket, shortFormat, limitedNum)
        }</span> else<span class="cov0" title="0"> {
                num = lc.showObjects(lor, bucket, true, limitedNum)
                num1 := lc.showDirectories(lor, bucket, limitedNum)
                num += num1
        }</span>
        <span class="cov0" title="0">return num</span>
}

func (lc *ListCommand) displayObjectVersionsResult(lor oss.ListObjectVersionsResult, bucket string, shortFormat bool, directory bool, i int64, limitedNum *int64) int64 <span class="cov0" title="0">{
        if i == 0 &amp;&amp; (len(lor.ObjectDeleteMarkers) &gt; 0 || len(lor.ObjectVersions) &gt; 0) </span><span class="cov0" title="0">{
                if directory </span><span class="cov0" title="0">{
                        fmt.Printf("%-6s%s%-30s%12s%s%12s%s%-36s%s%-66s%s%-10s%s%-13s%s%s\n", "COMMON-PREFIX", "  ", "LastModifiedTime", "Size(B)", "  ", "StorageClass", "  ", "ETAG", "  ", "VERSIONID", "  ", "IS-LATEST", "  ", "DELETE-MARKER", "  ", "ObjectName")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%-30s%12s%s%12s%s%-36s%s%-66s%s%-10s%s%-13s%s%s\n", "LastModifiedTime", "Size(B)", "  ", "StorageClass", "  ", "ETAG", "  ", "VERSIONID", "  ", "IS-LATEST", "  ", "DELETE-MARKER", "  ", "ObjectName")
                }</span>
        }

        <span class="cov0" title="0">var num int64
        num = lc.showObjectVersions(lor, bucket, limitedNum, directory)
        if directory </span><span class="cov0" title="0">{
                num1 := lc.showDirectoriesVersion(lor, bucket, limitedNum)
                num += num1
        }</span>
        <span class="cov0" title="0">return num</span>
}

func (lc *ListCommand) showObjects(lor oss.ListObjectsResult, bucket string, shortFormat bool, limitedNum *int64) int64 <span class="cov0" title="0">{
        var num int64
        num = 0
        for _, object := range lor.Objects </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if !doesSingleObjectMatchPatterns(object.Key, lc.filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if !shortFormat </span><span class="cov0" title="0">{
                        fmt.Printf("%-30s%12d%s%12s%s%-36s%s%s\n", utcToLocalTime(object.LastModified), object.Size, "  ", object.StorageClass, "   ", strings.Trim(object.ETag, "\""), "  ", CloudURLToString(bucket, object.Key))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%s\n", CloudURLToString(bucket, object.Key))
                }</span>
                <span class="cov0" title="0">*limitedNum--
                num++</span>
        }
        <span class="cov0" title="0">return num</span>
}

func (lc *ListCommand) showObjectVersions(lor oss.ListObjectVersionsResult, bucket string, limitedNum *int64, directory bool) int64 <span class="cov0" title="0">{
        var num int64
        num = 0
        for _, object := range lor.ObjectDeleteMarkers </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if !doesSingleObjectMatchPatterns(object.Key, lc.filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                //COMMON-PREFIX LastModifiedTime  Size(B)  StorageClass  ETAG VERSIONID  IS-LATEST  DELETE-MARKER  ObjectName
                <span class="cov0" title="0">if directory </span><span class="cov0" title="0">{
                        fmt.Printf("%-13t%s%-30s%12d%s%12s%s%-36s%s%-66s%s%-10t%s%-13t%s%s\n",
                                false, "  ",
                                utcToLocalTime(object.LastModified),
                                0, "  ",
                                "", "  ",
                                "", "  ",
                                object.VersionId, "  ",
                                object.IsLatest, "  ",
                                true, "  ",
                                CloudURLToString(bucket, object.Key))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%-30s%12d%s%12s%s%-36s%s%-66s%s%-10t%s%-13t%s%s\n",
                                utcToLocalTime(object.LastModified),
                                0, "  ",
                                "", "  ",
                                "", "  ",
                                object.VersionId, "  ",
                                object.IsLatest, "  ",
                                true, "  ",
                                CloudURLToString(bucket, object.Key))
                }</span>

                <span class="cov0" title="0">*limitedNum--
                num++</span>
        }

        <span class="cov0" title="0">for _, object := range lor.ObjectVersions </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if !doesSingleObjectMatchPatterns(object.Key, lc.filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                //COMMON-PREFIX LastModifiedTime  Size(B)  StorageClass  ETAG VERSIONID  IS-LATEST  DELETE-MARKER  ObjectName
                <span class="cov0" title="0">if directory </span><span class="cov0" title="0">{
                        fmt.Printf("%-13t%s%-30s%12d%s%12s%s%-36s%s%-66s%s%-10t%s%-13t%s%s\n",
                                false, "  ",
                                utcToLocalTime(object.LastModified),
                                object.Size, "  ",
                                object.StorageClass, "  ",
                                strings.Trim(object.ETag, "\""), "  ",
                                object.VersionId, "  ",
                                object.IsLatest, "  ",
                                false, "  ",
                                CloudURLToString(bucket, object.Key))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%-30s%12d%s%12s%s%-36s%s%-66s%s%-10t%s%-13t%s%s\n",
                                utcToLocalTime(object.LastModified),
                                object.Size, "  ",
                                object.StorageClass, "  ",
                                strings.Trim(object.ETag, "\""), "  ",
                                object.VersionId, "  ",
                                object.IsLatest, "  ",
                                false, "  ",
                                CloudURLToString(bucket, object.Key))
                }</span>

                <span class="cov0" title="0">*limitedNum--
                num++</span>
        }

        <span class="cov0" title="0">return num</span>
}

func (lc *ListCommand) showDirectories(lor oss.ListObjectsResult, bucket string, limitedNum *int64) int64 <span class="cov0" title="0">{
        var num int64
        num = 0
        for _, prefix := range lor.CommonPrefixes </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if !doesSingleObjectMatchPatterns(strings.TrimSuffix(prefix, "/"), lc.filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("%s\n", CloudURLToString(bucket, prefix))
                *limitedNum--
                num++</span>
        }
        <span class="cov0" title="0">return num</span>
}

func (lc *ListCommand) showDirectoriesVersion(lor oss.ListObjectVersionsResult, bucket string, limitedNum *int64) int64 <span class="cov0" title="0">{
        var num int64
        num = 0
        for _, prefix := range lor.CommonPrefixes </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if !doesSingleObjectMatchPatterns(strings.TrimSuffix(prefix, "/"), lc.filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("%-13t%s%-30s%12s%s%12s%s%-36s%s%-66s%s%-10s%s%-13s%s%s\n",
                        true, "  ",
                        "", "", "  ",
                        "", "  ",
                        "", "  ",
                        "", "  ",
                        "", "  ",
                        "", "  ",
                        CloudURLToString(bucket, prefix))

                *limitedNum--
                num++</span>
        }
        <span class="cov0" title="0">return num</span>
}

func (lc *ListCommand) listMultipartUploads(bucket *oss.Bucket, cloudURL CloudURL, shortFormat bool, directory bool, limitedNum *int64) (int64, error) <span class="cov0" title="0">{
        var err error
        var multipartNum int64
        multipartNum = 0
        pre := oss.Prefix(cloudURL.object)

        vmarker, _ := GetString(OptionMarker, lc.command.options)
        if vmarker, err = lc.command.getRawMarker(vmarker); err != nil </span><span class="cov0" title="0">{
                return multipartNum, fmt.Errorf("invalid marker: %s, marker is not url encoded, %s", vmarker, err.Error())
        }</span>
        <span class="cov0" title="0">keyMarker := oss.KeyMarker(vmarker)

        vuploadIdMarker, _ := GetString(OptionUploadIDMarker, lc.command.options)
        if vuploadIdMarker, err = lc.command.getRawMarker(vuploadIdMarker); err != nil </span><span class="cov0" title="0">{
                return multipartNum, fmt.Errorf("invalid uploadIDMarker: %s, uploadIDMarker is not url encoded, %s", vuploadIdMarker, err.Error())
        }</span>
        <span class="cov0" title="0">uploadIdMarker := oss.UploadIDMarker(vuploadIdMarker)

        del := oss.Delimiter("")
        if directory </span><span class="cov0" title="0">{
                del = oss.Delimiter("/")
        }</span>
        <span class="cov0" title="0">payer := lc.payerOption

        var i int64
        for i = 0; ; i++ </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">lmr, err := lc.command.ossListMultipartUploadsRetry(bucket, keyMarker, uploadIdMarker, pre, del, payer)
                if err != nil </span><span class="cov0" title="0">{
                        return multipartNum, err
                }</span>
                <span class="cov0" title="0">pre = oss.Prefix(lmr.Prefix)
                keyMarker = oss.Marker(lmr.NextKeyMarker)
                uploadIdMarker = oss.UploadIDMarker(lmr.NextUploadIDMarker)
                multipartNum += lc.displayMultipartUploadsResult(lmr, cloudURL.bucket, shortFormat, directory, i, limitedNum)
                if !lmr.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">fmt.Printf("UploadID Number is: %d\n", multipartNum)
        return multipartNum, nil</span>
}

func (lc *ListCommand) displayMultipartUploadsResult(lmr oss.ListMultipartUploadResult, bucket string, shortFormat bool, directory bool, i int64, limitedNum *int64) int64 <span class="cov0" title="0">{
        if directory </span><span class="cov0" title="0">{
                shortFormat = true
        }</span>

        <span class="cov0" title="0">if i == 0 &amp;&amp; len(lmr.Uploads) &gt; 0 </span><span class="cov0" title="0">{
                if shortFormat </span><span class="cov0" title="0">{
                        fmt.Printf("%-32s%s%s\n", "UploadID", FormatTAB, "ObjectName")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%-30s%s%-32s%s%s\n", "InitiatedTime", FormatTAB, "UploadID", FormatTAB, "ObjectName")
                }</span>
        }

        <span class="cov0" title="0">num := lc.showMultipartUploads(lmr, bucket, shortFormat, limitedNum)
        return num</span>
}

func (lc *ListCommand) showMultipartUploads(lmr oss.ListMultipartUploadResult, bucket string, shortFormat bool, limitedNum *int64) int64 <span class="cov0" title="0">{
        var num int64
        num = 0
        for _, upload := range lmr.Uploads </span><span class="cov0" title="0">{
                if *limitedNum == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if !doesSingleObjectMatchPatterns(upload.Key, lc.filters) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if shortFormat </span><span class="cov0" title="0">{
                        fmt.Printf("%-32s%s%s\n", upload.UploadID, FormatTAB, CloudURLToString(bucket, upload.Key))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%-30s%s%-32s%s%s\n", utcToLocalTime(upload.Initiated), FormatTAB, upload.UploadID, FormatTAB, CloudURLToString(bucket, upload.Key))
                }</span>
                <span class="cov0" title="0">*limitedNum--
                num++</span>
        }
        <span class="cov0" title="0">return num</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package lib

import (
        "fmt"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var storageClassList = []string{
        StorageStandard,
        StorageIA,
        StorageArchive,
        StorageColdArchive,
}

func formatStorageClassString(sep string) string <span class="cov3" title="2">{
        return strings.Join(storageClassList, sep)
}</span>

var specChineseMakeBucket = SpecText{

        synopsisText: "创建Bucket",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil mb oss://bucket [--acl acl] [--storage-class class] [-c file] 
`,

        detailHelpText: ` 
    该命令在指定的身份凭证下创建bucket，可以在创建的同时通过--acl选项指定bucket的acl，但是
    不支持指定region的功能，所创建的bucket属于哪个region由配置中的endpoint决定。如果该账户
    下已经存在该bucket，不会报错，但如果bucket属于他人，会报错bucket已存在。
    
    关于config中的endpoint，请参考help config。
    
    关于region的更多信息，请参考https://help.aliyun.com/document_detail/31827.html?spm=5176.doc31826.6.138.rhUAjo中的Region部分。

ACL：

    bucket的acl有三种：
        ` + formatACLString(bucketACL, "\n        ") + `


    关于acl的更多信息请参考help set-acl。

StorageClass:
    
    bucket的StorageClass有四种：
        ` + formatStorageClassString("\n        ") + `

    关于StorageClass的更多信息请参考：https://help.aliyun.com/document_detail/31959.html?spm=5176.doc31957.6.839.E1ifnh

RedundancyType:

    bucket的RedundancyType有两种: LRS和ZRS; LRS是缺省值,表示本地容灾; ZRS表示更高可用的同城容灾, 数据将会同时保存在同一地域(Region)的3个可用区

用法：

    ossutil mb oss://bucket [--acl=acl] [--storage-class class] [--redundancy-type type] [-c file]
        当未指定--acl选项时，ossutil会在指定的身份凭证下创建指定bucket，所创建的bucket的acl
    为默认private。如果需要更改acl信息，可以使用set-acl命令。
        当未指定--storage-class选项时，ossutil创建的bucket的存储方式为默认存储方式：` + DefaultStorageClass + `。
        如果指定了--acl选项，ossutil会检查指定acl的合法性，如果acl非法，会进入交互模式，提
    示合法的acl输入，并询问acl信息。
        如果指定了--storage-class选项，ossutil会检查指定storage class的合法性。
`,

        sampleText: ` 
    1)ossutil mb oss://bucket1
    2)ossutil mb oss://bucket1 --acl=public-read-write
    3)ossutil mb oss://bucket1 --storage-class IA 
    4)ossutil mb oss://bucket1 --acl=public-read-write --storage-class IA
    5)ossutil mb oss://bucket1 --redundancy-type ZRS
`,
}

var specEnglishMakeBucket = SpecText{

        synopsisText: "Make Bucket",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil mb oss://bucket [--acl acl] [--storage-class class] [--redundancy-type type] [-c file] 
`,

        detailHelpText: ` 
    The command create bucket under the specified credentials. You can specify bucket acl 
    information through --acl option meanwhile. But you can not specify the region for the 
    bucket, the region is decided by endpoint in config file. If the bucket existed under 
    the credentials, no error occurs, but if the bucket belongs to others, error occurs.

    More information about endpoint in config, see help config.

    More information about region, see Region section in https://help.aliyun.com/document_detail/31827.html?spm=5176.doc31826.6.138.rhUAjo.

ACL:

    ossutil supports following bucket acls, shorthand versions in brackets:
        ` + formatACLString(bucketACL, "\n        ") + `

    More information about acl, see help set-acl.

StorageClass:

    There are four kinds of StorageClass:
        ` + formatStorageClassString("\n        ") + `

    More information about StorageClass see: https://help.aliyun.com/document_detail/31959.html?spm=5176.doc31957.6.839.E1ifnh

RedundancyType:

    There are two types of bucket redundancyType: LRS and ZRS; LRS is the default value, specifies locally redundant storage; ZRS specifies higher availability of redundancy storage, The data will be stored in the 3 availabe zones of the same region

Usage:

    ossutil mb oss://bucket [--acl=acl] [--storage-class class] [-c file]
        If you create bucket without --acl option, ossutil will create bucket under the 
    specified credentials and the bucket acl is private, if you want to change acl, please 
    use set-acl command. 
        If you create bucket without --storage-class option, the storage class of bucket will
     be the default one: ` + DefaultStorageClass + `. 
        If you create bucket with --acl option, ossutil will check the validity of acl, if 
    invalid, ossutil will enter interactive mode, prompt the valid acls and ask you for it. 
        If you create bucket with --storage-class option, ossutil will check the validity of 
    storage class. 
`,

        sampleText: ` 
    1)ossutil mb oss://bucket1
    2)ossutil mb oss://bucket1 --acl=public-read-write
    3)ossutil mb oss://bucket1 --storage-class IA 
    4)ossutil mb oss://bucket1 --acl=public-read-write --storage-class IA 
    5)ossutil mb oss://bucket1 --redundancy-type ZRS
`,
}

// MakeBucketCommand is the command create bucket
type MakeBucketCommand struct {
        command Command
}

var makeBucketCommand = MakeBucketCommand{
        command: Command{
                name:        "mb",
                nameAlias:   []string{"cb", "pb"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseMakeBucket,
                specEnglish: specEnglishMakeBucket,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionLanguage,
                        OptionACL,
                        OptionStorageClass,
                        OptionLogLevel,
                        OptionRedundancyType,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (mc *MakeBucketCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return mc.command.formatHelpForWhole()
}</span>

func (mc *MakeBucketCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return mc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (mc *MakeBucketCommand) Init(args []string, options OptionMapType) error <span class="cov10" title="12">{
        return mc.command.Init(args, options, mc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (mc *MakeBucketCommand) RunCommand() error <span class="cov10" title="12">{
        cloudURL, err := CloudURLFromString(mc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="12">if cloudURL.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", mc.command.args[0])
        }</span>

        <span class="cov10" title="12">if cloudURL.object != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, object not empty, upload object please use \"cp\" command", mc.command.args[0])
        }</span>

        <span class="cov10" title="12">client, err := mc.command.ossClient(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="12">aclStr, _ := GetString(OptionACL, mc.command.options)
        language, _ := GetString(OptionLanguage, mc.command.options)
        language = strings.ToLower(language)
        strRedundancy, _ := GetString(OptionRedundancyType, mc.command.options)
        var op []oss.Option
        if aclStr != "" </span><span class="cov0" title="0">{
                acl, err := mc.getACL(aclStr, language)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">op = append(op, oss.ACL(acl))</span>
        }

        <span class="cov10" title="12">if strRedundancy != "" </span><span class="cov0" title="0">{
                if strings.ToUpper(strRedundancy) != string(oss.RedundancyLRS) &amp;&amp; strings.ToUpper(strRedundancy) != string(oss.RedundancyZRS) </span><span class="cov0" title="0">{
                        return fmt.Errorf("--redundancy-type muse be %s or %s", string(oss.RedundancyLRS), string(oss.RedundancyZRS))
                }</span>
                <span class="cov0" title="0">redundancyType := oss.DataRedundancyType(strings.ToUpper(strRedundancy))
                op = append(op, oss.RedundancyType(redundancyType))</span>
        }

        <span class="cov10" title="12">return mc.ossCreateBucketRetry(client, cloudURL.bucket, op...)</span>
}

func (mc *MakeBucketCommand) getACL(aclStr, language string) (oss.ACLType, error) <span class="cov0" title="0">{
        acl, err := mc.command.checkACL(aclStr, bucketACL)
        if err != nil </span><span class="cov0" title="0">{
                if language == LEnglishLanguage </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid acl: %s\n", aclStr)
                        fmt.Printf("Acceptable acls:\n\t%s\nPlease enter the acl you want to set on the bucket:", formatACLString(bucketACL, "\n\t"))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("acl: %s非法\n", aclStr)
                        fmt.Printf("合法的acl有:\n\t%s\n请输入你想设置的acl：", formatACLString(bucketACL, "\n\t"))
                }</span>
                <span class="cov0" title="0">if _, err := fmt.Scanln(&amp;aclStr); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid acl: %s, please check", aclStr)
                }</span>
                <span class="cov0" title="0">acl, err = mc.command.checkACL(aclStr, bucketACL)</span>
        }
        <span class="cov0" title="0">return acl, err</span>
}

func (mc *MakeBucketCommand) ossCreateBucketRetry(client *oss.Client, bucket string, options ...oss.Option) error <span class="cov10" title="12">{
        storageClass := mc.getStorageClass()
        if storageClass != oss.StorageStandard </span><span class="cov0" title="0">{
                options = append(options, oss.StorageClass(storageClass))
        }</span>
        <span class="cov10" title="12">retryTimes, _ := GetInt(OptionRetryTimes, mc.command.options)
        for i := 1; ; i++ </span><span class="cov10" title="12">{
                err := client.CreateBucket(bucket, options...)
                if err == nil </span><span class="cov10" title="12">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return BucketError{err, bucket}
                }</span>
        }
}

func (mc *MakeBucketCommand) getStorageClass() oss.StorageClassType <span class="cov10" title="12">{
        storageClass, _ := GetString(OptionStorageClass, mc.command.options)
        if strings.EqualFold(storageClass, StorageIA) </span><span class="cov0" title="0">{
                return oss.StorageIA
        }</span>
        <span class="cov10" title="12">if strings.EqualFold(storageClass, StorageArchive) </span><span class="cov0" title="0">{
                return oss.StorageArchive
        }</span>
        <span class="cov10" title="12">if strings.EqualFold(storageClass, StorageColdArchive) </span><span class="cov0" title="0">{
                return oss.StorageColdArchive
        }</span>
        <span class="cov10" title="12">return oss.StorageStandard</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package lib

import (
        "fmt"
        "strings"
)

var specChineseMkdir = SpecText{
        synopsisText: "创建一个目录,在oss中目录名字有后缀字符'/'",

        paramText: "dir_name [options]",

        syntaxText: ` 
        ossutil mkdir oss://bucket/dir_name
`,

        detailHelpText: ` 
    1) 如果输入的参数没有以后缀字符'/'结尾，工具会自动添加
    2) 如果目录已经存在,会提示报错
    3) 如果输入的参数包含多级目录,只会创建最后的那一个目录
`,

        sampleText: ` 
        1) 创建一个目录
      ossutil mkdir oss://bucket/dir
        
    2) 创建一个多级目录
      ossutil mkdir oss://bucket/dir1/dir2
`,
}

var specEnglishMkdir = SpecText{
        synopsisText: "Create a oss directory whose object name has the suffix character '/'",

        paramText: "dir_name [options]",

        syntaxText: ` 
        ossutil mkdir oss://bucket/dir_name
`,
        detailHelpText: ` 
    1) If the input parameter does not end with the suffix character '/', the tool will automatically add
    2) If the directory already exists, you will be prompted with an error.
    3) If the input parameter contains multiple levels of directories, only the last directory will be created.
`,
        sampleText: ` 
    1) create a diretory
       ossutil mkdir oss://bucket/dir

    2) create a multi-level directory
       ossutil mkdir oss://bucket/dir1/dir2
`,
}

type mkOptionType struct {
        encodingType string
}

type MkdirCommand struct {
        command  Command
        mkOption mkOptionType
}

var mkdirCommand = MkdirCommand{
        command: Command{
                name:        "mkdir",
                nameAlias:   []string{"mkdir"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseMkdir,
                specEnglish: specEnglishMkdir,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionEncodingType,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (mkc *MkdirCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return mkc.command.formatHelpForWhole()
}</span>

func (mkc *MkdirCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return mkc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (mkc *MkdirCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return mkc.command.Init(args, options, mkc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (mkc *MkdirCommand) RunCommand() error <span class="cov0" title="0">{
        mkc.mkOption.encodingType, _ = GetString(OptionEncodingType, mkc.command.options)

        dirUrL, err := StorageURLFromString(mkc.command.args[0], mkc.mkOption.encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("StorageURLFromString error")
        }</span>

        <span class="cov0" title="0">if !dirUrL.IsCloudURL() </span><span class="cov0" title="0">{
                return fmt.Errorf("parameter is not a cloud url,url is %s", dirUrL.ToString())
        }</span>

        <span class="cov0" title="0">cloudUrl := dirUrL.(CloudURL)

        if cloudUrl.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("bucket name is empty,url is %s", cloudUrl.ToString())
        }</span>

        <span class="cov0" title="0">if cloudUrl.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("object name is empty,url is %s", cloudUrl.ToString())
        }</span>

        <span class="cov0" title="0">if !strings.HasSuffix(cloudUrl.object, "/") </span><span class="cov0" title="0">{
                cloudUrl.object += "/"
        }</span>

        <span class="cov0" title="0">return mkc.MkBucketDir(cloudUrl)</span>
}

func (mkc *MkdirCommand) MkBucketDir(dirUrl CloudURL) error <span class="cov0" title="0">{
        bucket, err := mkc.command.ossBucket(dirUrl.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bExist, err := bucket.IsObjectExist(dirUrl.object)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if bExist </span><span class="cov0" title="0">{
                return fmt.Errorf("%s already exists", dirUrl.object)
        }</span>

        <span class="cov0" title="0">return bucket.PutObject(dirUrl.object, strings.NewReader(""))</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package lib

import (
        "fmt"
        "strings"
        "sync/atomic"
        "time"
)

const (
        normalExit = iota
        errExit
)

var processTickInterval int64 = 5

var clearStrLen int = 0
var clearStr string = strings.Repeat(" ", clearStrLen)

func getClearStr(str string) string <span class="cov10" title="100">{
        if clearStrLen &lt;= len(str) </span><span class="cov6" title="16">{
                clearStrLen = len(str)
                return fmt.Sprintf("\r%s", str)
        }</span>
        <span class="cov9" title="84">clearStr = strings.Repeat(" ", clearStrLen)
        return fmt.Sprintf("\r%s\r%s", clearStr, str)</span>
}

type Monitorer interface {
        setScanError(err error)
        updateScanNum(num int64)
        setScanEnd()
}

// for normal object operation
type MonitorSnap struct {
        okNum   int64
        errNum  int64
        dealNum int64
}

/*
 * Put same type variables together to make them 64bits alignment to avoid
 * atomic.AddInt64() panic
 * Please guarantee the alignment if you add new filed
 */
type Monitor struct {
        opStr          string
        totalNum       int64
        okNum          int64
        errNum         int64
        seekAheadError error
        seekAheadEnd   bool
        finish         bool
        _              uint32 //Add padding to make sure the next data 64bits alignment
}

func (m *Monitor) init(opStr string) <span class="cov0" title="0">{
        m.opStr = opStr
        m.totalNum = 0
        m.seekAheadEnd = false
        m.seekAheadError = nil
        m.okNum = 0
        m.errNum = 0
        m.finish = false
}</span>

func (m *Monitor) setScanError(err error) <span class="cov0" title="0">{
        m.seekAheadError = err
        m.seekAheadEnd = true
}</span>

func (m *Monitor) updateScanNum(num int64) <span class="cov0" title="0">{
        m.totalNum = m.totalNum + num
}</span>

func (m *Monitor) setScanEnd() <span class="cov0" title="0">{
        m.seekAheadEnd = true
}</span>

func (m *Monitor) updateOKNum(num int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;m.okNum, num)
}</span>

func (m *Monitor) updateErrNum(num int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;m.errNum, num)
}</span>

func (m *Monitor) getSnapshot() *MonitorSnap <span class="cov0" title="0">{
        var snap MonitorSnap
        snap.okNum = m.okNum
        snap.errNum = m.errNum
        snap.dealNum = snap.okNum + snap.errNum
        return &amp;snap
}</span>

func (m *Monitor) progressBar(finish bool, exitStat int) string <span class="cov0" title="0">{
        if m.finish </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">m.finish = m.finish || finish
        if !finish </span><span class="cov0" title="0">{
                return m.getProgressBar()
        }</span>
        <span class="cov0" title="0">return m.getFinishBar(exitStat)</span>
}

func (m *Monitor) getProgressBar() string <span class="cov0" title="0">{
        snap := m.getSnapshot()
        if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov0" title="0">{
                if snap.errNum == 0 </span><span class="cov0" title="0">{
                        return getClearStr(fmt.Sprintf("Total %d objects. %s %d objects, Progress: %d%s", m.totalNum, m.opStr, snap.okNum, m.getPrecent(snap), "%%"))
                }</span>
                <span class="cov0" title="0">return getClearStr(fmt.Sprintf("Total %d objects. %s %d objects, Error %d objects, Progress: %d%s", m.totalNum, m.opStr, snap.okNum, snap.errNum, m.getPrecent(snap), "%%"))</span>
        }
        <span class="cov0" title="0">scanNum := max(m.totalNum, snap.dealNum)
        if snap.errNum == 0 </span><span class="cov0" title="0">{
                return getClearStr(fmt.Sprintf("Scanned %d objects. %s %d objects.", scanNum, m.opStr, snap.okNum))
        }</span>
        <span class="cov0" title="0">return getClearStr(fmt.Sprintf("Scanned %d objects. %s %d objects, Error %d objects.", scanNum, m.opStr, snap.okNum, snap.errNum))</span>
}

func (m *Monitor) getPrecent(snap *MonitorSnap) int <span class="cov0" title="0">{
        if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov0" title="0">{
                if m.totalNum != 0 </span><span class="cov0" title="0">{
                        return int(float64((snap.dealNum)*100.0) / float64(m.totalNum))
                }</span>
                <span class="cov0" title="0">return 100</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (m *Monitor) getFinishBar(exitStat int) string <span class="cov0" title="0">{
        if exitStat == normalExit </span><span class="cov0" title="0">{
                return m.getWholeFinishBar()
        }</span>
        <span class="cov0" title="0">return m.getDefeatBar()</span>
}

func (m *Monitor) getWholeFinishBar() string <span class="cov0" title="0">{
        snap := m.getSnapshot()
        if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov0" title="0">{
                if snap.errNum == 0 </span><span class="cov0" title="0">{
                        return getClearStr(fmt.Sprintf("Succeed: Total %d objects. %s %d objects.\n", m.totalNum, m.opStr, snap.okNum))
                }</span>
                <span class="cov0" title="0">return getClearStr(fmt.Sprintf("FinishWithError: Total %d objects. %s %d objects, Error %d objects.\n", m.totalNum, m.opStr, snap.okNum, snap.errNum))</span>
        }
        <span class="cov0" title="0">scanNum := max(m.totalNum, snap.dealNum)
        if snap.errNum == 0 </span><span class="cov0" title="0">{
                return getClearStr(fmt.Sprintf("Succeed: Total %d objects. %s %d objects.\n", scanNum, m.opStr, snap.okNum))
        }</span>
        <span class="cov0" title="0">return getClearStr(fmt.Sprintf("FinishWithError: Scanned %d objects. %s %d objects, Error %d objects.\n", scanNum, m.opStr, snap.okNum, snap.errNum))</span>
}

func (m *Monitor) getDefeatBar() string <span class="cov0" title="0">{
        snap := m.getSnapshot()
        if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov0" title="0">{
                return getClearStr(fmt.Sprintf("Total %d objects. %s %d objects, when error happens.\n", m.totalNum, m.opStr, snap.okNum))
        }</span>
        <span class="cov0" title="0">scanNum := max(m.totalNum, snap.dealNum)
        return getClearStr(fmt.Sprintf("Scanned %d objects. %s %d objects, when error happens.\n", scanNum, m.opStr, snap.okNum))</span>
}

// For rm
type RMMonitorSnap struct {
        objectNum      int64
        uploadIdNum    int64
        errObjectNum   int64
        errUploadIdNum int64
        dealNum        int64
        errNum         int64
        removedBucket  string
}

/*
 * Put same type variables together to make them 64bits alignment to avoid
 * atomic.AddInt64() panic
 * Please guarantee the alignment if you add new filed
 */
type RMMonitor struct {
        op               int64
        totalObjectNum   int64
        totalUploadIdNum int64
        objectNum        int64
        uploadIdNum      int64
        errObjectNum     int64
        errUploadIdNum   int64
        removedBucket    string
        seekAheadError   error
        seekAheadEnd     bool
        finish           bool
        _                uint32 //Add padding to make sure the next data 64bits alignment
}

func (m *RMMonitor) init() <span class="cov7" title="28">{
        m.op = 0
        m.totalObjectNum = 0
        m.totalUploadIdNum = 0
        m.seekAheadEnd = false
        m.seekAheadError = nil
        m.objectNum = 0
        m.uploadIdNum = 0
        m.errObjectNum = 0
        m.errUploadIdNum = 0
        m.finish = false
        m.removedBucket = ""
}</span>

func (m *RMMonitor) updateOP(op int64) <span class="cov8" title="40">{
        m.op = m.op | op
}</span>

func (m *RMMonitor) setOP(op int64) <span class="cov0" title="0">{
        m.op = op
}</span>

func (m *RMMonitor) setScanError(err error) <span class="cov3" title="4">{
        m.seekAheadError = err
        m.seekAheadEnd = true
}</span>

func (m *RMMonitor) updateScanNum(num int64) <span class="cov7" title="24">{
        m.totalObjectNum = m.totalObjectNum + num
}</span>

func (m *RMMonitor) updateScanUploadIdNum(num int64) <span class="cov5" title="12">{
        m.totalUploadIdNum = m.totalUploadIdNum + num
}</span>

func (m *RMMonitor) setScanEnd() <span class="cov7" title="27">{
        m.seekAheadEnd = true
}</span>

func (m *RMMonitor) updateObjectNum(num int64) <span class="cov7" title="24">{
        atomic.AddInt64(&amp;m.objectNum, num)
}</span>

func (m *RMMonitor) updateUploadIdNum(num int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;m.uploadIdNum, num)
}</span>

func (m *RMMonitor) updateErrObjectNum(num int64) <span class="cov7" title="24">{
        atomic.AddInt64(&amp;m.errObjectNum, num)
}</span>

func (m *RMMonitor) updateErrUploadIdNum(num int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;m.errUploadIdNum, num)
}</span>

func (m *RMMonitor) updateRemovedBucket(bucket string) <span class="cov5" title="12">{
        m.removedBucket = bucket
}</span>

func (m *RMMonitor) getSnapshot() *RMMonitorSnap <span class="cov8" title="52">{
        var snap RMMonitorSnap
        snap.objectNum = m.objectNum
        snap.uploadIdNum = m.uploadIdNum
        snap.errObjectNum = m.errObjectNum
        snap.errUploadIdNum = m.errUploadIdNum
        snap.dealNum = snap.objectNum + snap.uploadIdNum + snap.errObjectNum + snap.errUploadIdNum
        snap.errNum = snap.errObjectNum + snap.errUploadIdNum
        snap.removedBucket = m.removedBucket
        return &amp;snap
}</span>

func (m *RMMonitor) progressBar(finish bool, exitStat int) string <span class="cov8" title="52">{
        if m.finish </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="52">m.finish = m.finish || finish
        if !finish </span><span class="cov7" title="24">{
                return m.getProgressBar()
        }</span>
        <span class="cov7" title="28">return m.getFinishBar(exitStat)</span>
}

func (m *RMMonitor) getProgressBar() string <span class="cov7" title="24">{
        if m.op&amp;allType != 0 </span><span class="cov7" title="24">{
                snap := m.getSnapshot()
                if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov5" title="9">{
                        return getClearStr(fmt.Sprintf("Total %s. %s%s Progress: %d%s", m.getTotalInfo(), m.getOKInfo(snap), m.getErrInfo(snap), m.getPrecent(snap), "%%"))
                }</span>
                <span class="cov6" title="15">m.totalObjectNum = max(m.totalObjectNum, snap.objectNum+snap.errObjectNum)
                m.totalUploadIdNum = max(m.totalUploadIdNum, snap.uploadIdNum+snap.errUploadIdNum)
                return getClearStr(fmt.Sprintf("Scanned %s. %s%s", m.getTotalInfo(), m.getOKInfo(snap), m.getErrInfo(snap)))</span>
        }
        <span class="cov0" title="0">return getClearStr("")</span>
}

func (m *RMMonitor) getTotalInfo() string <span class="cov8" title="52">{
        strList := []string{}
        if m.op&amp;objectType != 0 </span><span class="cov8" title="52">{
                strList = append(strList, fmt.Sprintf("%d objects", m.totalObjectNum))
        }</span>
        <span class="cov8" title="52">if m.op&amp;multipartType != 0 </span><span class="cov7" title="26">{
                strList = append(strList, fmt.Sprintf("%d uploadIds", m.totalUploadIdNum))
        }</span>
        <span class="cov8" title="52">return strings.Join(strList, ", ")</span>
}

func (m *RMMonitor) getOKInfo(snap *RMMonitorSnap) string <span class="cov8" title="52">{
        strList := []string{}
        if m.op&amp;allType == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="52">if m.op&amp;objectType != 0 </span><span class="cov8" title="52">{
                strList = append(strList, fmt.Sprintf("%d objects", snap.objectNum))
        }</span>
        <span class="cov8" title="52">if m.op&amp;multipartType != 0 </span><span class="cov7" title="26">{
                strList = append(strList, fmt.Sprintf("%d uploadIds", snap.uploadIdNum))
        }</span>
        <span class="cov8" title="52">return fmt.Sprintf("Removed %s.", strings.Join(strList, ", "))</span>
}

func (m *RMMonitor) getErrInfo(snap *RMMonitorSnap) string <span class="cov7" title="24">{
        if snap.errNum != 0 </span><span class="cov0" title="0">{
                strList := []string{}
                if snap.errObjectNum != 0 </span><span class="cov0" title="0">{
                        strList = append(strList, fmt.Sprintf("%d objects", snap.errObjectNum))
                }</span>
                <span class="cov0" title="0">if snap.errUploadIdNum != 0 </span><span class="cov0" title="0">{
                        strList = append(strList, fmt.Sprintf("%d uploadIds", snap.errUploadIdNum))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf(" Error %s.", strings.Join(strList, ", "))</span>
        }
        <span class="cov7" title="24">return ""</span>
}

func (m *RMMonitor) getPrecent(snap *RMMonitorSnap) int <span class="cov5" title="9">{
        if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov5" title="9">{
                if m.totalObjectNum+m.totalUploadIdNum != 0 </span><span class="cov4" title="6">{
                        return int(float64((snap.dealNum)*100.0) / float64(m.totalObjectNum+m.totalUploadIdNum))
                }</span>
                <span class="cov3" title="3">return 100</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func (m *RMMonitor) getFinishBar(exitStat int) string <span class="cov7" title="28">{
        snap := m.getSnapshot()
        return m.getObjectFinishBar(snap, exitStat) + m.getBucketFinishBar(snap)
}</span>

func (m *RMMonitor) getObjectFinishBar(snap *RMMonitorSnap, exitStat int) string <span class="cov7" title="28">{
        if m.op&amp;allType != 0 </span><span class="cov7" title="28">{
                if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov7" title="24">{
                        if m.getExitStat(snap, exitStat) == errExit </span><span class="cov0" title="0">{
                                return getClearStr(fmt.Sprintf("Total %s. %s when error happens.\n", m.getTotalInfo(), m.getOKInfo(snap)))
                        }</span>
                        <span class="cov7" title="24">return getClearStr(fmt.Sprintf("Succeed: Total %s. %s\n", m.getTotalInfo(), m.getOKInfo(snap)))</span>
                }
                <span class="cov3" title="4">m.totalObjectNum = max(m.totalObjectNum, snap.objectNum+snap.errObjectNum)
                m.totalUploadIdNum = max(m.totalUploadIdNum, snap.uploadIdNum+snap.errUploadIdNum)
                if m.getExitStat(snap, exitStat) == errExit </span><span class="cov3" title="4">{
                        return getClearStr(fmt.Sprintf("Scanned %s. %s when error happens.\n", m.getTotalInfo(), m.getOKInfo(snap)))
                }</span>
                <span class="cov0" title="0">return getClearStr(fmt.Sprintf("Succeed: Total %s. %s\n", m.getTotalInfo(), m.getOKInfo(snap)))</span>
        }
        <span class="cov0" title="0">return getClearStr("")</span>
}

func (m *RMMonitor) getExitStat(snap *RMMonitorSnap, exitStat int) int <span class="cov7" title="28">{
        if exitStat != normalExit || snap.errNum != 0 || (m.op&amp;bucketType != 0 &amp;&amp; snap.removedBucket == "") </span><span class="cov3" title="4">{
                return errExit
        }</span>
        <span class="cov7" title="24">return normalExit</span>
}

func (m *RMMonitor) getBucketFinishBar(snap *RMMonitorSnap) string <span class="cov7" title="28">{
        if m.op&amp;bucketType != 0 &amp;&amp; snap.removedBucket != "" </span><span class="cov5" title="12">{
                return getClearStr(fmt.Sprintf("Removed Bucket: %s\n", snap.removedBucket))
        }</span>
        <span class="cov6" title="16">return getClearStr("")</span>
}

// for cp
type CPMonitorSnap struct {
        transferSize  int64
        skipSize      int64
        dealSize      int64
        fileNum       int64
        dirNum        int64
        skipNum       int64
        skipNumDir    int64
        errNum        int64
        okNum         int64
        dealNum       int64
        duration      int64
        incrementSize int64
}

/*
 * Put same type variables together to make them 64bits alignment to avoid
 * atomic.AddInt64() panic
 * Please guarantee the alignment if you add new filed
 */
type CPMonitor struct {
        totalSize      int64
        totalNum       int64
        transferSize   int64
        skipSize       int64
        dealSize       int64
        fileNum        int64
        dirNum         int64
        skipNum        int64
        skipNumDir     int64
        errNum         int64
        lastSnapSize   int64
        tickDuration   int64
        seekAheadError error
        op             operationType
        seekAheadEnd   bool
        finish         bool
        _              uint32 //Add padding to make sure the next data 64bits alignment
        lastSnapTime   time.Time
}

func (m *CPMonitor) init(op operationType) <span class="cov7" title="24">{
        m.op = op
        m.totalSize = 0
        m.totalNum = 0
        m.seekAheadEnd = false
        m.seekAheadError = nil
        m.transferSize = 0
        m.skipSize = 0
        m.dealSize = 0
        m.fileNum = 0
        m.dirNum = 0
        m.skipNum = 0
        m.errNum = 0
        m.finish = false
        m.lastSnapSize = 0
        m.lastSnapTime = time.Now()
        m.tickDuration = processTickInterval * int64(time.Second)
}</span>

func (m *CPMonitor) setScanError(err error) <span class="cov0" title="0">{
        m.seekAheadError = err
        m.seekAheadEnd = true
}</span>

func (m *CPMonitor) updateScanNum(num int64) <span class="cov0" title="0">{
        m.totalNum = m.totalNum + num
}</span>

func (m *CPMonitor) updateScanSizeNum(size, num int64) <span class="cov6" title="20">{
        m.totalSize = m.totalSize + size
        m.totalNum = m.totalNum + num
}</span>

func (m *CPMonitor) setScanEnd() <span class="cov6" title="20">{
        m.seekAheadEnd = true
}</span>

func (m *CPMonitor) updateTransferSize(size int64) <span class="cov6" title="20">{
        atomic.AddInt64(&amp;m.transferSize, size)
}</span>

func (m *CPMonitor) updateDealSize(size int64) <span class="cov8" title="40">{
        atomic.AddInt64(&amp;m.dealSize, size)
}</span>

func (m *CPMonitor) updateFile(size, num int64) <span class="cov6" title="20">{
        atomic.AddInt64(&amp;m.fileNum, num)
        atomic.AddInt64(&amp;m.transferSize, size)
        atomic.AddInt64(&amp;m.dealSize, size)
}</span>

func (m *CPMonitor) updateDir(size, num int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;m.dirNum, num)
        atomic.AddInt64(&amp;m.transferSize, size)
        atomic.AddInt64(&amp;m.dealSize, size)
}</span>

func (m *CPMonitor) updateSkip(size, num int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;m.skipNum, num)
        atomic.AddInt64(&amp;m.skipSize, size)
}</span>

func (m *CPMonitor) updateSkipDir(num int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;m.skipNumDir, num)
}</span>

func (m *CPMonitor) updateErr(size, num int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;m.errNum, num)
        atomic.AddInt64(&amp;m.transferSize, size)
}</span>

func (m *CPMonitor) getSnapshot() *CPMonitorSnap <span class="cov7" title="25">{
        var snap CPMonitorSnap
        snap.transferSize = m.transferSize
        snap.skipSize = m.skipSize
        snap.dealSize = m.dealSize + snap.skipSize
        snap.fileNum = m.fileNum
        snap.dirNum = m.dirNum
        snap.skipNum = m.skipNum
        snap.errNum = m.errNum
        snap.okNum = snap.fileNum + snap.dirNum + snap.skipNum
        snap.dealNum = snap.okNum + snap.errNum
        snap.skipNumDir = m.skipNumDir
        now := time.Now()
        snap.duration = now.Sub(m.lastSnapTime).Nanoseconds()

        return &amp;snap
}</span>

func (m *CPMonitor) progressBar(finish bool, exitStat int) string <span class="cov7" title="25">{
        if m.finish </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov7" title="25">m.finish = m.finish || finish
        if !finish </span><span class="cov4" title="5">{
                return m.getProgressBar()
        }</span>
        <span class="cov6" title="20">return m.getFinishBar(exitStat)</span>
}

func (m *CPMonitor) getProgressBar() string <span class="cov4" title="5">{
        mu.RLock()
        defer mu.RUnlock()

        snap := m.getSnapshot()
        if snap.duration &lt; m.tickDuration </span><span class="cov4" title="5">{
                return ""
        }</span> else<span class="cov0" title="0"> {
                m.lastSnapTime = time.Now()
                snap.incrementSize = m.transferSize - m.lastSnapSize
                m.lastSnapSize = snap.transferSize
        }</span>

        <span class="cov0" title="0">if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov0" title="0">{
                return getClearStr(fmt.Sprintf("Total num: %d, size: %s. Dealed num: %d%s%s, Progress: %.3f%s, Speed: %.2fKB/s", m.totalNum, getSizeString(m.totalSize), snap.dealNum, m.getDealNumDetail(snap), m.getDealSizeDetail(snap), m.getPrecent(snap), "%%", m.getSpeed(snap)))
        }</span>
        <span class="cov0" title="0">scanNum := max(m.totalNum, snap.dealNum)
        scanSize := max(m.totalSize, snap.dealSize)
        return getClearStr(fmt.Sprintf("Scanned num: %d, size: %s. Dealed num: %d%s%s, Speed: %.2fKB/s.", scanNum, getSizeString(scanSize), snap.dealNum, m.getDealNumDetail(snap), m.getDealSizeDetail(snap), m.getSpeed(snap)))</span>
}

func (m *CPMonitor) getFinishBar(exitStat int) string <span class="cov6" title="20">{
        if exitStat == normalExit </span><span class="cov6" title="20">{
                return m.getWholeFinishBar()
        }</span>
        <span class="cov0" title="0">return m.getDefeatBar()</span>
}

func (m *CPMonitor) getWholeFinishBar() string <span class="cov6" title="20">{
        snap := m.getSnapshot()
        if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov6" title="20">{
                if snap.errNum == 0 </span><span class="cov6" title="20">{
                        return getClearStr(fmt.Sprintf("Succeed: Total num: %d, size: %s. OK num: %d%s%s.\n", m.totalNum, getSizeString(m.totalSize), snap.okNum, m.getDealNumDetail(snap), m.getSkipSize(snap)))
                }</span>
                <span class="cov0" title="0">return getClearStr(fmt.Sprintf("FinishWithError: Total num: %d, size: %s. Error num: %d. OK num: %d%s%s.\n", m.totalNum, getSizeString(m.totalSize), snap.errNum, snap.okNum, m.getOKNumDetail(snap), m.getSizeDetail(snap)))</span>
        }
        <span class="cov0" title="0">scanNum := max(m.totalNum, snap.dealNum)
        if snap.errNum == 0 </span><span class="cov0" title="0">{
                return getClearStr(fmt.Sprintf("Succeed: Total num: %d, size: %s. OK num: %d%s%s.\n", scanNum, getSizeString(snap.dealSize), snap.okNum, m.getDealNumDetail(snap), m.getSkipSize(snap)))
        }</span>
        <span class="cov0" title="0">return getClearStr(fmt.Sprintf("FinishWithError: Scanned %d %s. Error num: %d. OK num: %d%s%s.\n", scanNum, m.getSubject(), snap.errNum, snap.okNum, m.getOKNumDetail(snap), m.getSizeDetail(snap)))</span>
}

func (m *CPMonitor) getDefeatBar() string <span class="cov0" title="0">{
        snap := m.getSnapshot()
        if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov0" title="0">{
                return getClearStr(fmt.Sprintf("Total num: %d, size: %s. Dealed num: %d%s%s. When error happens.\n", m.totalNum, getSizeString(m.totalSize), snap.okNum, m.getOKNumDetail(snap), m.getSizeDetail(snap)))
        }</span>
        <span class="cov0" title="0">scanNum := max(m.totalNum, snap.dealNum)
        return getClearStr(fmt.Sprintf("Scanned %d %s. Dealed num: %d%s%s. When error happens.\n", scanNum, m.getSubject(), snap.okNum, m.getOKNumDetail(snap), m.getSizeDetail(snap)))</span>
}

func (m *CPMonitor) getSubject() string <span class="cov6" title="20">{
        switch m.op </span>{
        case operationTypePut:<span class="cov5" title="10">
                return "files"</span>
        default:<span class="cov5" title="10">
                return "objects"</span>
        }
}

func (m *CPMonitor) getDealNumDetail(snap *CPMonitorSnap) string <span class="cov6" title="20">{
        return m.getNumDetail(snap, true)
}</span>

func (m *CPMonitor) getOKNumDetail(snap *CPMonitorSnap) string <span class="cov0" title="0">{
        return m.getNumDetail(snap, false)
}</span>

func (m *CPMonitor) getNumDetail(snap *CPMonitorSnap, hasErr bool) string <span class="cov6" title="20">{
        if !hasErr &amp;&amp; snap.okNum == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov6" title="20">strList := []string{}
        if hasErr &amp;&amp; snap.errNum != 0 </span><span class="cov0" title="0">{
                strList = append(strList, fmt.Sprintf("Error %d %s", snap.errNum, m.getSubject()))
        }</span>
        <span class="cov6" title="20">if snap.fileNum != 0 </span><span class="cov6" title="20">{
                strList = append(strList, fmt.Sprintf("%s %d %s", m.getOPStr(), snap.fileNum, m.getSubject()))
        }</span>
        <span class="cov6" title="20">if snap.dirNum != 0 </span><span class="cov0" title="0">{
                str := fmt.Sprintf("%d directories", snap.dirNum)
                if snap.fileNum == 0 </span><span class="cov0" title="0">{
                        str = fmt.Sprintf("%s %d directories", m.getOPStr(), snap.dirNum)
                }</span>
                <span class="cov0" title="0">strList = append(strList, str)</span>
        }
        <span class="cov6" title="20">if snap.skipNum != 0 </span><span class="cov0" title="0">{
                strList = append(strList, fmt.Sprintf("skip %d %s", snap.skipNum, m.getSubject()))
        }</span>
        <span class="cov6" title="20">if snap.skipNumDir != 0 </span><span class="cov0" title="0">{
                strList = append(strList, fmt.Sprintf("skip %d directory", snap.skipNumDir))
        }</span>

        <span class="cov6" title="20">if len(strList) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov6" title="20">return fmt.Sprintf("(%s)", strings.Join(strList, ", "))</span>
}

func (m *CPMonitor) getSpeed(snap *CPMonitorSnap) float64 <span class="cov0" title="0">{
        return (float64(snap.incrementSize) / 1024) / (float64(snap.duration) * 1e-9)
}</span>

func (m *CPMonitor) getOPStr() string <span class="cov6" title="20">{
        switch m.op </span>{
        case operationTypePut:<span class="cov5" title="10">
                return "upload"</span>
        case operationTypeGet:<span class="cov5" title="10">
                return "download"</span>
        default:<span class="cov0" title="0">
                return "copy"</span>
        }
}

func (m *CPMonitor) getDealSizeDetail(snap *CPMonitorSnap) string <span class="cov0" title="0">{
        return fmt.Sprintf(", OK size: %s", getSizeString(snap.dealSize))
}</span>

func (m *CPMonitor) getSkipSize(snap *CPMonitorSnap) string <span class="cov6" title="20">{
        if snap.skipSize != 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(", Skip size: %s", getSizeString(snap.skipSize))
        }</span>
        <span class="cov6" title="20">return ""</span>
}

func (m *CPMonitor) getSizeDetail(snap *CPMonitorSnap) string <span class="cov0" title="0">{
        if snap.skipSize == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(", Transfer size: %s", getSizeString(snap.transferSize))
        }</span>
        <span class="cov0" title="0">if snap.transferSize == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(", Skip size: %s", getSizeString(snap.skipSize))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf(", OK size: %s(transfer: %s, skip: %s)", getSizeString(snap.transferSize+snap.skipSize), getSizeString(snap.transferSize), getSizeString(snap.skipSize))</span>
}

func (m *CPMonitor) getPrecent(snap *CPMonitorSnap) float64 <span class="cov0" title="0">{
        if m.seekAheadEnd &amp;&amp; m.seekAheadError == nil </span><span class="cov0" title="0">{
                if m.totalSize != 0 </span><span class="cov0" title="0">{
                        return float64((snap.dealSize)*100.0) / float64(m.totalSize)
                }</span>
                <span class="cov0" title="0">if m.totalNum != 0 </span><span class="cov0" title="0">{
                        return float64((snap.dealNum)*100.0) / float64(m.totalNum)
                }</span>
                <span class="cov0" title="0">return 100</span>
        }
        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package lib

import (
        "fmt"
        "strings"
        "sync"

        "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseObjectTag = SpecText{
        synopsisText: "设置、查询或者删除object的tag配置",

        paramText: "cloud_url [tag_parameter] [options]",

        syntaxText: ` 
    ossutil object-tagging --method put oss://bucket[/prefix] key#value [--encoding-type url] [-r] [--payer requester] [--version-id versionId] [-c file] 
    ossutil object-tagging --method get oss://bucket[/prefix] [--encoding-type url] [-r]  [--payer requester] [--version-id versionId] [-c file] 
    ossuitl object-tagging --method delete oss://bucket[/prefix] [--encoding-type url] [-r] [--payer requester] [--version-id versionId] [-c file] 
`,
        detailHelpText: ` 
    object-tagging命令通过设置method选项值为put、get、delete,可以设置、查询或者删除object的tag配置
    每个tag的key和value必须以字符'#'分隔,最多可以连续输入10个tag信息

用法:
    该命令有三种用法:
        
    1) ossutil object-tagging --method put oss://bucket/object  tagkey#tagvalue
        这个命令设置object的tag配置,key和value分别为tagkey、tagvalue
        
    2) ossutil object-tagging --method get oss://bucket/object 
        这个命令查询object的tag配置
        
    3) ossutil object-tagging --method delete oss://bucket/object
        这个命令删除object的tag配置
`,
        sampleText: ` 
    1) 设置object的tag配置
       ossutil object-tagging --method put oss://bucket/object  tagkey#tagvalue
    
    2) 批量设置objects的tag配置
       ossutil object-tagging --method put oss://bucket/prefix -r tagkey#tagvalue 
    
    3) 设置object的多个tag配置
       ossutil object-tagging --method put oss://bucket/object  tagkey1#tagvalue1 tagkey2#tagvalue2
        
    4) 查询object的tag配置
       ossutil object-tagging --method get oss://bucket/object
    
    5) 批量查询object的tag配置
       ossutil object-tagging --method get oss://bucket/prefix -r
        
    6) 删除object的tag配置
       ossutil object-tagging --method delete oss://bucket/object
    
    7) 批量删除object的tag配置
       ossutil object-tagging --method delete oss://bucket/prefix -r
`,
}

var specEnglishObjectTag = SpecText{
        synopsisText: "Set, get or delete object tag configuration",

        paramText: "cloud_url [tag_parameter] [options]",

        syntaxText: ` 
    ossutil object-tagging --method put oss://bucket[/prefix] key#value [--encoding-type url] [-r] [--payer requester] [--version-id versionId] [-c file] 
    ossutil object-tagging --method get oss://bucket[/prefix] [--encoding-type url] [-r]  [--payer requester] [--version-id versionId] [-c file] 
    ossuitl object-tagging --method delete oss://bucket[/prefix] [--encoding-type url] [-r] [--payer requester] [--version-id versionId] [-c file] 
`,
        detailHelpText: ` 
    object-tagging command can set, get and delete the tag configuration of the oss object by set method option value to put, get, delete
    the key and value of each tag must be separated by the character '#', you can enter up to 10 tag parameters.
Usage:
    There are three usages for this command:
        
    1) ossutil object-tagging --method put oss://bucket/object tagkey#tagvalue
        The command sets the tag configuration of the object. The key and value are tagkey and tagvalue
        
    2) ossutil object-tagging --method get oss://bucket/object 
        The command gets the tag configuration of object

    3) ossutil object-tagging --method delete oss://bucket/object
        The command deletes the tag configuration of bucket/object
`,
        sampleText: ` 
    1) set object tag configuration with one tag   
       ossutil object-tagging --method put oss://bucket/object tagkey#tagvalue
    
    2) batch set objects tag configuration
       ossutil object-tagging --method put oss://bucket/prefix -r tagkey#tagvalue 
    
    3) set object tag configuration with serveral tags
       ossutil object-tagging --method put oss://bucket/object tagkey1#tagvalue1 tagkey2#tagvalue2 

    4) get object tag configuration
       ossutil object-tagging --method get oss://bucket/object
    
    5) batch get objects tag configuration
       ossutil object-tagging --method get oss://bucket/prefix -r
        
    6) delete object tag configuration
       ossutil object-tagging --method delete oss://bucket/object
    
    7) batch delete objects tag configuration
       ossutil object-tagging --method delete oss://bucket/prefix -r
`,
}

type ObjectTagCommand struct {
        command       Command
        monitor       Monitor
        method        string
        tagging       oss.Tagging
        commonOptions []oss.Option
        lock          sync.Mutex
        printHeader   bool
        objectIndex   int32
        reportOption  batchOptionType
}

var objectTagCommand = ObjectTagCommand{
        command: Command{
                name:        "object-tagging",
                nameAlias:   []string{"object-tagging"},
                minArgc:     1,
                maxArgc:     11,
                specChinese: specChineseObjectTag,
                specEnglish: specEnglishObjectTag,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRoutines,
                        OptionMethod,
                        OptionLogLevel,
                        OptionEncodingType,
                        OptionRecursion,
                        OptionVersionId,
                        OptionRequestPayer,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (otc *ObjectTagCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return otc.command.formatHelpForWhole()
}</span>

func (otc *ObjectTagCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return otc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (otc *ObjectTagCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return otc.command.Init(args, options, otc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (otc *ObjectTagCommand) RunCommand() error <span class="cov0" title="0">{
        otc.tagging.Tags = []oss.Tag{} // clear tags for test
        otc.monitor.init("ObjectTagging")
        encodingType, _ := GetString(OptionEncodingType, otc.command.options)
        cloudUrL, err := GetCloudUrl(otc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">strMethod, _ := GetString(OptionMethod, otc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" &amp;&amp; strMethod != "delete" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get|delete")
        }</span>
        <span class="cov0" title="0">otc.method = strMethod

        payer, _ := GetString(OptionRequestPayer, otc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">otc.commonOptions = append(otc.commonOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        <span class="cov0" title="0">recursive, _ := GetBool(OptionRecursion, otc.command.options)
        versionId, _ := GetString(OptionVersionId, otc.command.options)
        if len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                if recursive </span><span class="cov0" title="0">{
                        return fmt.Errorf("--version-id and -r can't be both used")
                }</span> else<span class="cov0" title="0"> {
                        otc.commonOptions = append(otc.commonOptions, oss.VersionId(versionId))
                }</span>
        }

        <span class="cov0" title="0">if strMethod == "put" </span><span class="cov0" title="0">{
                if len(otc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("When the method value is put, there must be at least 2 parameters")
                }</span>

                <span class="cov0" title="0">tagList := otc.command.args[1:len(otc.command.args)]
                for _, tag := range tagList </span><span class="cov0" title="0">{
                        pSlice := strings.Split(tag, "#")
                        if len(pSlice) != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s error,tag name and tag value must be separated by #", tag)
                        }</span>
                        <span class="cov0" title="0">otc.tagging.Tags = append(otc.tagging.Tags, oss.Tag{Key: pSlice[0], Value: pSlice[1]})</span>
                }
        }

        <span class="cov0" title="0">bucket, err := otc.command.ossBucket(cloudUrL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !recursive </span><span class="cov0" title="0">{
                err = otc.SingleObjectTagging(bucket, cloudUrL.object)
        }</span> else<span class="cov0" title="0"> {
                err = otc.BatchObjectTagging(bucket, *cloudUrL)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (otc *ObjectTagCommand) SingleObjectTagging(bucket *oss.Bucket, objectName string) error <span class="cov0" title="0">{
        if len(objectName) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("object key is empty")
        }</span>

        <span class="cov0" title="0">var tagError error
        if otc.method == "put" </span><span class="cov0" title="0">{
                tagError = bucket.PutObjectTagging(objectName, otc.tagging, otc.commonOptions...)
        }</span> else<span class="cov0" title="0"> if otc.method == "get" </span><span class="cov0" title="0">{
                resutl, err := bucket.GetObjectTagging(objectName, otc.commonOptions...)
                tagError = err
                if err == nil </span><span class="cov0" title="0">{
                        otc.lock.Lock()
                        if len(resutl.Tags) &gt; 0 </span><span class="cov0" title="0">{
                                otc.objectIndex++
                                if !otc.printHeader </span><span class="cov0" title="0">{
                                        fmt.Printf("%-15s%-15s%s\t%s\t%s\n", "object index", "tag index", "tag key", "tag value", "object")
                                        fmt.Printf("---------------------------------------------------------------------------\n")
                                        otc.printHeader = true
                                }</span>
                        }

                        <span class="cov0" title="0">for index, tag := range resutl.Tags </span><span class="cov0" title="0">{
                                fmt.Printf("%-15d%-15d\"%s\"\t\"%s\"\t%s\n", otc.objectIndex, index, tag.Key, tag.Value, CloudURLToString(bucket.BucketName, objectName))
                        }</span>
                        <span class="cov0" title="0">otc.lock.Unlock()</span>
                }
        } else<span class="cov0" title="0"> if otc.method == "delete" </span><span class="cov0" title="0">{
                tagError = bucket.DeleteObjectTagging(objectName, otc.commonOptions...)
        }</span>

        <span class="cov0" title="0">if tagError == nil </span><span class="cov0" title="0">{
                LogInfo("%s tagging success,object:%s\n", otc.method, objectName)
        }</span> else<span class="cov0" title="0"> {
                LogError("%s tagging error,object:%s,error info:%s\n", otc.method, objectName, tagError.Error())
        }</span>

        <span class="cov0" title="0">return tagError</span>
}

func (otc *ObjectTagCommand) BatchObjectTagging(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov0" title="0">{
        otc.reportOption.ctnu = true
        outputDir, _ := GetString(OptionOutputDir, otc.command.options)

        var err error
        if otc.reportOption.reporter, err = GetReporter(otc.reportOption.ctnu, outputDir, commandLine); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer otc.reportOption.reporter.Clear()

        routines, _ := GetInt(OptionRoutines, otc.command.options)
        chObjects := make(chan string, ChannelBuf)
        chError := make(chan error, routines+1)
        chListError := make(chan error, 1)

        go otc.command.objectStatistic(bucket, cloudURL, &amp;otc.monitor, []filterOptionType{}, otc.commonOptions...)
        go otc.command.objectProducer(bucket, cloudURL, chObjects, chListError, []filterOptionType{}, otc.commonOptions...)
        for i := 0; int64(i) &lt; routines; i++ </span><span class="cov0" title="0">{
                go otc.objectTaggingConsumer(bucket, chObjects, chError)
        }</span>
        <span class="cov0" title="0">return otc.waitRoutinueComplete(chError, chListError, routines)</span>
}

func (otc *ObjectTagCommand) objectTaggingConsumer(bucket *oss.Bucket, chObjects &lt;-chan string, chError chan&lt;- error) <span class="cov0" title="0">{
        for object := range chObjects </span><span class="cov0" title="0">{
                err := otc.objectTaggingWithReport(bucket, object)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        if !otc.reportOption.ctnu </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }
        <span class="cov0" title="0">chError &lt;- nil</span>
}

func (otc *ObjectTagCommand) objectTaggingWithReport(bucket *oss.Bucket, object string) error <span class="cov0" title="0">{
        err := otc.SingleObjectTagging(bucket, object)
        if otc.method != "get" </span><span class="cov0" title="0">{
                otc.command.updateMonitor(err, &amp;otc.monitor)
                msg := fmt.Sprintf("%s %s object tagging", otc.method, CloudURLToString(bucket.BucketName, object))
                if err == nil </span><span class="cov0" title="0">{
                        otc.command.report(msg, err, &amp;otc.reportOption)
                }</span> else<span class="cov0" title="0"> {
                        otc.command.report(msg, ObjectError{err, bucket.BucketName, object}, &amp;otc.reportOption)
                }</span>
        }
        <span class="cov0" title="0">return ObjectError{err, bucket.BucketName, object}</span>
}

func (otc *ObjectTagCommand) waitRoutinueComplete(chError, chListError &lt;-chan error, routines int64) error <span class="cov0" title="0">{
        completed := 0
        var ferr error
        for int64(completed) &lt;= routines </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-chListError:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">completed++</span>
                case err := &lt;-chError:<span class="cov0" title="0">
                        if err == nil </span><span class="cov0" title="0">{
                                completed++
                        }</span> else<span class="cov0" title="0"> {
                                ferr = err
                                if !otc.reportOption.ctnu </span><span class="cov0" title="0">{
                                        fmt.Printf(otc.monitor.progressBar(true, errExit))
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return otc.formatResultPrompt(ferr)</span>
}

func (otc *ObjectTagCommand) formatResultPrompt(err error) error <span class="cov0" title="0">{
        if otc.method != "get" </span><span class="cov0" title="0">{
                fmt.Printf(otc.monitor.progressBar(true, normalExit))
        }</span>

        <span class="cov0" title="0">if err != nil &amp;&amp; otc.reportOption.ctnu </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package lib

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        goopt "github.com/droundy/goopt"
)

type optionType int

// option types, only support three kinds now
const (
        OptionTypeString optionType = iota
        OptionTypeInt64
        OptionTypeFlagTrue
        OptionTypeAlternative
)

// Option describe the component of a option
type Option struct {
        name        string
        nameAlias   string
        def         string
        optionType  optionType
        minVal      string // empty means no check, for OptionTypeAlternative, minVal is the alternative values connected by '/', eg: CN/EN
        maxVal      string // empty means no check, for OptionTypeAlternative, maxVal is empty
        helpChinese string
        helpEnglish string
}

// LEnglishLanguage is the lower case of EnglishLanguage
var LEnglishLanguage = strings.ToLower(EnglishLanguage)

// OptionMap is a collection of ossutil supported options
var OptionMap = map[string]Option{
        OptionConfigFile: Option{"-c", "--config-file", "", OptionTypeString, "", "",
                "ossutil工具的配置文件路径，ossutil启动时从配置文件读取配置，在config命令中，ossutil将配置写入该文件。",
                "Path of ossutil configuration file, where to dump config in config command, or to load config in other commands that need credentials."},
        OptionEndpoint: Option{"-e", "--endpoint", "", OptionTypeString, "", "",
                fmt.Sprintf("ossutil工具的基本endpoint配置（该选项值会覆盖配置文件中的相应设置），注意其必须为一个二级域名。"),
                fmt.Sprintf("Base endpoint for oss endpoint(Notice that the value of the option will cover the value in config file). Take notice that it should be second-level domain(SLD).")},
        OptionAccessKeyID:     Option{"-i", "--access-key-id", "", OptionTypeString, "", "", "访问oss使用的AccessKeyID（该选项值会覆盖配置文件中的相应设置）。", "AccessKeyID while access oss(Notice that the value of the option will cover the value in config file)."},
        OptionAccessKeySecret: Option{"-k", "--access-key-secret", "", OptionTypeString, "", "", "访问oss使用的AccessKeySecret（该选项值会覆盖配置文件中的相应设置）。", "AccessKeySecret while access oss(Notice that the value of the option will cover the value in config file)."},
        OptionSTSToken:        Option{"-t", "--sts-token", "", OptionTypeString, "", "", "访问oss使用的STSToken（该选项值会覆盖配置文件中的相应设置），非必须设置项。", "STSToken while access oss(Notice that the value of the option will cover the value in config file), not necessary."},
        OptionLimitedNum:      Option{"", "--limited-num", strconv.Itoa(DefaultLimitedNum), OptionTypeInt64, strconv.FormatInt(MinLimitedNum, 10), "", "返回结果的最大个数。", "the limited number of return results."},
        OptionMarker:          Option{"", "--marker", "", OptionTypeString, "", "", "列举Buckets时的marker，或列举objects或Multipart Uploads时的key marker, 或者其他有需要marker的地方。", "the marker of bucket when list buckets, or the marker of key when list object or Multipart Uploads, Or other places where a marker is needed"},
        OptionUploadIDMarker:  Option{"", "--upload-id-marker", "", OptionTypeString, "", "", "列举Multipart Uploads时的uploadID marker。", "the marker of object when list object or Multipart Uploads."},
        OptionACL:             Option{"", "--acl", "", OptionTypeString, "", "", "acl信息的配置。", "acl information."},
        OptionShortFormat:     Option{"-s", "--short-format", "", OptionTypeFlagTrue, "", "", "显示精简格式，如果未指定该选项，默认显示长格式。", "Show by short format, if the option is not specified, show long format by default."},
        OptionDirectory:       Option{"-d", "--directory", "", OptionTypeFlagTrue, "", "", "返回当前目录下的文件和子目录，而非递归显示所有子目录下的所有object。", "Return matching subdirectory names instead of contents of the subdirectory."},
        OptionMultipart:       Option{"-m", "--multipart", "", OptionTypeFlagTrue, "", "", "指定操作的对象为bucket中未完成的Multipart事件，而非默认情况下的object。", "Indicate that the subject of the command are uncompleted Multipart Uploads, instead of objects(which is the subject in default situation."},
        OptionAllType:         Option{"-a", "--all-type", "", OptionTypeFlagTrue, "", "", "指定操作的对象为bucket中的object和未完成的Multipart事件。", "Indicate that the subject of the command contains both objects and uncompleted Multipart Uploads."},
        OptionRecursion:       Option{"-r", "--recursive", "", OptionTypeFlagTrue, "", "", "递归进行操作。对于支持该选项的命令，当指定该选项时，命令会对bucket下所有符合条件的objects进行操作，否则只对url中指定的单个object进行操作。", "operate recursively, for those commands which support the option, when use them, if the option is specified, the command will operate on all match objects under the bucket, else we will search the specified object and operate on the single object."},
        OptionBucket:          Option{"-b", "--bucket", "", OptionTypeFlagTrue, "", "", "对bucket进行操作，该选项用于确认操作作用于bucket", "the option used to make sure the operation will operate on bucket"},
        OptionStorageClass: Option{"", "--storage-class", DefaultStorageClass, OptionTypeAlternative, fmt.Sprintf("%s/%s/%s/%s", StorageStandard, StorageIA, StorageArchive, StorageColdArchive), "",
                fmt.Sprintf("设置对象的存储方式，默认值：%s，取值范围：%s/%s/%s/%s。", DefaultStorageClass, StorageStandard, StorageIA, StorageArchive, StorageColdArchive),
                fmt.Sprintf("set the storage class of bucket(default: %s), value range is: %s/%s/%s/%s.", DefaultStorageClass, StorageStandard, StorageIA, StorageArchive, StorageColdArchive)},
        OptionForce:  Option{"-f", "--force", "", OptionTypeFlagTrue, "", "", "强制操作，不进行询问提示。", "operate silently without asking user to confirm the operation."},
        OptionUpdate: Option{"-u", "--update", "", OptionTypeFlagTrue, "", "", "更新操作", "update"},
        OptionDelete: Option{"", "--delete", "", OptionTypeFlagTrue, "", "", "删除操作", "delete"},
        OptionOutputDir: Option{"", "--output-dir", DefaultOutputDir, OptionTypeString, "", "",
                fmt.Sprintf("指定输出文件所在的目录，输出文件目前包含：cp命令批量拷贝文件出错时所产生的report文件（关于report文件更多信息，请参考cp命令帮助）。默认值为：当前目录下的%s目录。", DefaultOutputDir),
                fmt.Sprintf("The option specify the directory to place output file in, output file contains: report file generated by cp command when error happens of batch copy operation(for more information about report file, see help of cp command). The default value of the option is: %s directory in current directory.", DefaultOutputDir)},
        OptionBigFileThreshold: Option{"", "--bigfile-threshold", strconv.FormatInt(DefaultBigFileThreshold, 10), OptionTypeInt64, strconv.FormatInt(MinBigFileThreshold, 10), strconv.FormatInt(MaxBigFileThreshold, 10),
                fmt.Sprintf("开启大文件断点续传的文件大小阈值，默认值:%dM，取值范围：%dB-%dB", DefaultBigFileThreshold/1048576, MinBigFileThreshold, MaxBigFileThreshold),
                fmt.Sprintf("the threshold of file size, the file size larger than the threshold will use resume upload or download(default: %d), value range is: %d-%d", DefaultBigFileThreshold, MinBigFileThreshold, MaxBigFileThreshold)},
        OptionPartSize: Option{"", "--part-size", strconv.FormatInt(DefaultPartSize, 10), OptionTypeInt64, strconv.FormatInt(MinPartSize, 10), strconv.FormatInt(MaxPartSize, 10),
                fmt.Sprintf("分片大小，单位为Byte，默认情况下ossutil根据文件大小自行计算合适的分片大小值。如果有特殊需求或者需要性能调优，可以设置该值，取值范围：%d-%d(Byte)", MinPartSize, MaxPartSize),
                fmt.Sprintf("Part size, the unit is: Byte, in default situation, ossutil will calculate the suitable part size according to file size. The option is useful when user has special needs or user need to performance tuning, the value range is: %d-%d(Byte)", MinPartSize, MaxPartSize)},
        OptionDisableCRC64: Option{"", "--disable-crc64", "", OptionTypeFlagTrue, "", "", "该选项关闭crc64，默认情况下，ossutil进行数据传输都打开crc64校验。", "Disable crc64, in default situation, ossutil open crc64 check when transmit data."},
        OptionCheckpointDir: Option{"", "--checkpoint-dir", CheckpointDir, OptionTypeString, "", "",
                fmt.Sprintf("checkpoint目录的路径(默认值为:%s)，断点续传时，操作失败ossutil会自动创建该目录，并在该目录下记录checkpoint信息，操作成功会删除该目录。如果指定了该选项，请确保所指定的目录可以被删除。", CheckpointDir),
                fmt.Sprintf("Path of checkpoint directory(default:%s), the directory is used in resume upload or download, when operate failed, ossutil will create the directory automatically, and record the checkpoint information in the directory, when the operation is succeed, the directory will be removed, so when specify the option, please make sure the directory can be removed.", CheckpointDir)},
        OptionSnapshotPath: Option{"", "--snapshot-path", "", OptionTypeString, "", "",
                "该选项用于在某些场景下加速增量上传批量文件或者增量下载批量object。在cp上传文件或者下载object时使用该选项，ossutil在指定的目录下生成快照文件，记录文件上传或者object下载的快照信息，在下一次指定该选项上传或下载时，ossutil会读取指定目录下的快照信息进行增量上传或者下载。用户指定的snapshot目录必须为本地文件系统上的可写目录，若该目录不存在，ossutil会创建该文件用于记录快照信息，如果该目录已存在，ossutil会读取里面的快照信息，根据快照信息进行增量上传（只上传上次未成功上传的文件和本地进行过修改的文件）或者增量下载（只下载上次未成功下载的object和修改过的object），并更新快照信息。注意：该选项在本地记录了成功上传的文件的本地lastModifiedTime或者记录了下载object的lastModifiedTime，从而在下次上传或者下载时通过比较lastModifiedTime来决定是否跳过相同文件的上传或者跳过相同的object下载。当使用该选项上传时，请确保两次上传期间没有其他用户更改了oss上的对应object。当不满足该场景时，如果想要增量上传批量文件，请使用--update选项。ossutil不会主动删除snapshot-path下的快照信息，当用户确定快照信息无用时，请用户及时自行删除snapshot-path。",
                "This option is used to accelerate the incremental upload of batch files or download objects in certain scenarios. If you use the option when upload files or download objects, ossutil will generate files to record the snapshot information in the specified directory. When the next time you upload files or download objects with the option, ossutil will read the snapshot information under the specified directory for incremental upload or incremental download. The snapshot-path you specified must be a local file system directory can be written in, if the directory does not exist, ossutil creates the files for recording snapshot information, else ossutil will read snapshot information from the path for incremental upload(ossutil will only upload the files which haven't not been successfully uploaded to oss or been locally modified) or incremental download(ossutil will only download the objects which have not been successfully downloaded or have been modified), and update the snapshot information to the directory. Note: The option record the lastModifiedTime of local files which have been successfully uploaded in local file system or lastModifiedTime of objects which have been successfully downloaded, and compare the lastModifiedTime of local files or objects in the next cp to decided whether to skip the file or object. If you use the option to achieve incremental upload, please make sure no other user modified the corresponding object in oss during the two uploads. If you can not guarantee the scenarios, please use --update option to achieve incremental upload. In addition, ossutil does not automatically delete snapshot-path snapshot information, in order to avoid too much snapshot information, when the snapshot information is useless, please clean up your own snapshot-path on your own immediately."},
        OptionRetryTimes: Option{"", "--retry-times", strconv.Itoa(RetryTimes), OptionTypeInt64, strconv.FormatInt(MinRetryTimes, 10), strconv.FormatInt(MaxRetryTimes, 10),
                fmt.Sprintf("当错误发生时的重试次数，默认值：%d，取值范围：%d-%d", RetryTimes, MinRetryTimes, MaxRetryTimes),
                fmt.Sprintf("retry times when fail(default: %d), value range is: %d-%d", RetryTimes, MinRetryTimes, MaxRetryTimes)},
        OptionRoutines: Option{"-j", "--jobs", strconv.Itoa(Routines), OptionTypeInt64, strconv.FormatInt(MinRoutines, 10), strconv.FormatInt(MaxRoutines, 10),
                fmt.Sprintf("多文件操作时的并发任务数，默认值：%d，取值范围：%d-%d", Routines, MinRoutines, MaxRoutines),
                fmt.Sprintf("amount of concurrency tasks between multi-files(default: %d), value range is: %d-%d", Routines, MinRoutines, MaxRoutines)},
        OptionParallel: Option{"", "--parallel", "", OptionTypeInt64, strconv.FormatInt(MinParallel, 10), strconv.FormatInt(MaxParallel, 10),
                fmt.Sprintf("单文件内部操作的并发任务数，取值范围：%d-%d, 默认将由ossutil根据操作类型和文件大小自行决定。", MinRoutines, MaxRoutines),
                fmt.Sprintf("amount of concurrency tasks when work with a file, value range is: %d-%d, by default the value will be decided by ossutil intelligently.", MinRoutines, MaxRoutines)},
        OptionRange: Option{"", "--range", "", OptionTypeString, "", "", "下载文件时，指定文件下载的范围，格式为：3-9或3-或-9", "the range when download objects, the form is like: 3-9 or 3- or -9"},
        OptionEncodingType: Option{"", "--encoding-type", "", OptionTypeAlternative, URLEncodingType, "",
                fmt.Sprintf("输入或者输出的object名或文件名的编码方式，目前只支持url encode，即指定该选项时，取值范围为：%s，如果不指定该选项，则表示object名或文件名未经过编码。bucket名不支持url encode。注意，如果指定了该选项，则形如oss://bucket/object的cloud_url，输入形式为：oss://bucket/url_encode(object)，其中oss://bucket/字符串不需要编码。", URLEncodingType),
                fmt.Sprintf("the encoding type of object name or file name that user inputs or outputs, currently ossutil only supports url encode, which means the value range of the option is: %s, if you do not specify the option, it means the object name or file name that user inputed or outputed was not encoded. bucket name does not support url encode. Note, if the option is specified, the cloud_url like: oss://bucket/object should be inputted as: oss://bucket/url_encode(object), the string: oss://bucket/ should not be url encoded.", URLEncodingType)},
        OptionInclude: Option{"", "--include", DefaultNonePattern, OptionTypeString, "", "",
                fmt.Sprintf("包含对象匹配模式，如：*.jpg"),
                fmt.Sprintf("Include Pattern of key, e.g., *.jpg")},
        OptionExclude: Option{"", "--exclude", DefaultNonePattern, OptionTypeString, "", "",
                fmt.Sprintf("不包含对象匹配模式，如：*.txt"),
                fmt.Sprintf("Exclude Pattern of key, e.g., *.txt")},
        OptionMeta: Option{"", "--meta", "", OptionTypeString, "", "",
                fmt.Sprintf("设置object的meta为[header:value#header:value...]，如：Cache-Control:no-cache#Content-Encoding:gzip"),
                fmt.Sprintf("Set object meta as [header:value#header:value...], e.g., Cache-Control:no-cache#Content-Encoding:gzip")},
        OptionTimeout: Option{"", "--timeout", strconv.FormatInt(DefaultTimeout, 10), OptionTypeInt64, strconv.FormatInt(MinTimeout, 10), strconv.FormatInt(MaxTimeout, 10),
                fmt.Sprintf("签名url的超时时间，单位为秒，默认值为：%d，取值范围：%d-%d", DefaultTimeout, MinTimeout, MaxTimeout),
                fmt.Sprintf("time out of signurl, the unit is: s, default value is %d, the value range is: %d-%d", DefaultTimeout, MinTimeout, MaxTimeout)},
        OptionLanguage: Option{"-L", "--language", DefaultLanguage, OptionTypeAlternative, fmt.Sprintf("%s/%s", ChineseLanguage, EnglishLanguage), "",
                fmt.Sprintf("设置ossutil工具的语言，默认值：%s，取值范围：%s/%s，若设置成\"%s\"，请确保您的系统编码为UTF-8。", DefaultLanguage, ChineseLanguage, EnglishLanguage, ChineseLanguage),
                fmt.Sprintf("set the language of ossutil(default: %s), value range is: %s/%s, if you set it to \"%s\", please make sure your system language is UTF-8.", DefaultLanguage, ChineseLanguage, EnglishLanguage, ChineseLanguage)},
        OptionHashType: Option{"", "--type", DefaultHashType, OptionTypeAlternative, fmt.Sprintf("%s/%s", DefaultHashType, MD5HashType), "", fmt.Sprintf("计算的类型, 默认值：%s, 取值范围: %s/%s", DefaultHashType, DefaultHashType, MD5HashType),
                fmt.Sprintf("hash type, Default: %s, value range is: %s/%s", DefaultHashType, DefaultHashType, MD5HashType)},
        OptionVersion:      Option{"-v", "--version", "", OptionTypeFlagTrue, "", "", fmt.Sprintf("显示ossutil的版本（%s）并退出。", Version), fmt.Sprintf("Show ossutil version (%s) and exit.", Version)},
        OptionRequestPayer: Option{"", "--payer", "", OptionTypeString, "", "", "请求的支付方式，如果为请求者付费模式，可以将该值设置成\"requester\"", "The payer of the request. You can set this value to \"requester\" if you want pay for requester"},
        OptionLogLevel: Option{"", "--loglevel", "", OptionTypeString, "", "",
                "日志级别，默认为空,表示不输出日志文件,可选值为:info|debug,info输出提示信息日志,debug输出详细信息日志(包括http请求和响应信息)",
                "log level,default is empty(no log file output),optional value is:info|debug,info will output information logs,debug will output detail logs(including http request and response logs)"},
        OptionMaxUpSpeed: Option{"", "--maxupspeed", "", OptionTypeInt64, "", "",
                "最大上传速度,单位:KB/s,缺省值为0(不受限制)",
                "max upload speed,the unit is:KB/s,default value is 0(unlimited)"},
        OptionUpload: Option{"", "--upload", "", OptionTypeFlagTrue, "", "",
                "表示上传到oss,主要在命令probe中使用",
                "specifies upload action to oss,primarily used in probe command"},
        OptionDownload: Option{"", "--download", "", OptionTypeFlagTrue, "", "",
                "表示从oss下载,主要在命令probe中使用",
                "specifies download action from oss,primarily used in probe command"},
        OptionUrl: Option{"", "--url", "", OptionTypeString, "", "",
                "表示一个url地址,主要在命令probe中使用",
                "specifies a url address,primarily used in probe command"},
        OptionBucketName: Option{"", "--bucketname", "", OptionTypeString, "", "",
                "表示bucket的名称,主要在命令probe中使用",
                "specifies a name of bucket,primarily used in probe command"},
        OptionObject: Option{"", "--object", "", OptionTypeString, "", "",
                "表示oss中对象的名称,主要在命令probe中使用",
                "specifies a name of object,primarily used in probe command"},
        OptionAddr: Option{"", "--addr", "", OptionTypeString, "", "",
                "表示一个网络地址,通常为域名,主要在命令probe中使用",
                "specifies a network address,usually a domain,primarily used in probe command"},
        OptionUpMode: Option{"", "--upmode", "", OptionTypeString, "", "",
                "表示上传模式,缺省值为normal,取值为:normal|append|multipart,分别表示正常上传、追加上传、分块上传,主要在命令probe中使用",
                "specifies the upload mode,default value is normal,optional value is:normal|append|multipart, which means normal upload、append upload and multipart upload,it is primarily used in probe command."},
        OptionDisableEmptyReferer: Option{"", "--disable-empty-referer", "", OptionTypeFlagTrue, "", "",
                "表示不允许referer字段为空,主要在referer命令中使用",
                "specifies that the referer field is not allowed to be empty,primarily used in referer command"},
        OptionMethod: Option{"", "--method", "", OptionTypeString, "", "",
                "表示命令的操作类型,取值为PUT、GET、DELETE、LIST等",
                "specifies the command's operation type. the values ​​are PUT, GET, DELETE, LIST, etc"},
        OptionOrigin: Option{"", "--origin", "", OptionTypeString, "", "",
                "表示http请求头origin字段的值",
                "specifies the value of origin field in http header"},
        OptionPartitionDownload: Option{"", "--partition-download", "", OptionTypeString, "", "",
                "分区下载使用,一个ossutil命令下载一个分区,其值格式为\"分区编号:总分区数\",比如1:5,表示当前ossutil下载分区1,总共有5个分区;分区号从1开始编号,objects的分区规则由工具内部算法决定;利用该选项,待下载的objects分成多个区,可以由多个ossutil命令一起下载完成,每个ossutil命令下载各自的分区,多个ossutil命令可以并行在不同机器上执行",
                "the option is used in partition download mode, one command to download one partition,the value format is \"partition number:total count of partitions\",such as 1:5, indicating that the command downloads partition 1,total partition count is 5; the partition number is numbered from 1, and the partitioning rules for objects are determined by ossutil; with this option, the objects to be downloaded are divided into multiple partitions, which can be downloaded by multiple ossutil commands,each ossutil command can download its own partition,multiple ossutil commands can be executed on different machines in parallel."},
        OptionSSEAlgorithm: Option{"", "--sse-algorithm", "", OptionTypeString, "", "",
                "表示服务端加密算法，取值为KMS或者AES256",
                "specifies the server side encryption algorithm,value is KMS or AES256."},
        OptionKMSMasterKeyID: Option{"", "--kms-masterkey-id", "", OptionTypeString, "", "",
                "表示kms秘钥托管服务中的主秘钥id",
                "specifies the primary key id in the kms(key management service)"},
        OptionKMSDataEncryption: Option{"", "--kms-data-encryption", "", OptionTypeString, "", "",
                "表示kms秘钥托管服务使用的加密算法,目前取值仅支持为SM4, 或者为空",
                "specifies the kms data service encryption algorithm,Currently only supports the value SM4 or emtpy"},
        OptionAcrHeaders: Option{"", "--acr-headers", "", OptionTypeString, "", "",
                "表示http header Access-Control-Request-Headers的值,主要用于cors-options命令",
                "specifies the value of the http header Access-Control-Request-Headers, primarily used in cors-options command."},
        OptionAcrMethod: Option{"", "--acr-method", "", OptionTypeString, "", "",
                "表示http header Access-Control-Request-Method的值,主要用于cors-options命令",
                "specifies the value of the http header Access-Control-Request-Method,primarily used in cors-options command."},
        OptionVersionId: Option{"", "--version-id", "", OptionTypeString, "", "",
                "表示object的版本id",
                "specifies the object's version id"},
        OptionAllversions: Option{"", "--all-versions", "", OptionTypeFlagTrue, "", "",
                "表示object所有版本",
                "specifies the object's all versions"},
        OptionVersionIdMarker: Option{"", "--version-id-marker", "", OptionTypeString, "", "",
                "表示列举objects所有版本的version id marker",
                "specifies the marker of object version id when list objects's all versions"},
        OptionTrafficLimit: Option{"", "--trafic-limit", "", OptionTypeInt64, "", "",
                "http请求限速,单位:bit/s,缺省值为0(不受限制),用于sign命令",
                "http request speed limit,the unit is:bit/s,default value is 0(unlimited),primarily used in sign command"},
        OptionProxyHost: Option{"", "--proxy-host", "", OptionTypeString, "", "",
                "网络代理服务器的url地址,支持http/https/socks5,比如 https://120.79.128.211:3128, socks5://120.79.128.211:1080",
                "url of network proxy server, which supports http/https/socks5, such as https://120.79.128.211:3128, socks5://120.79.128.211:1080"},
        OptionProxyUser: Option{"", "--proxy-user", "", OptionTypeString, "", "",
                "网络代理服务器的用户名,默认为空",
                "username of network proxy, default is empty"},
        OptionProxyPwd: Option{"", "--proxy-pwd", "", OptionTypeString, "", "",
                "网络代理服务器的密码,默认为空",
                "password of network proxy, default is empty"},
        OptionLocalHost: Option{"", "--local-host", "", OptionTypeString, "", "",
                "工具的ip地址,比如 127.0.0.1",
                "ossutil's ip ,such as 127.0.0.1"},
        OptionEnableSymlinkDir: Option{"", "--enable-symlink-dir", "", OptionTypeFlagTrue, "", "",
                "表示允许上传链接子目录下的文件,默认不上传; probe命令可以探测是否存在死循环链接文件或者目录",
                "specifies uploading link subdirectories,default are not uploaded; The probe command can detect whether there is a dead cycle symlink file or directory."},
        OptionOnlyCurrentDir: Option{"", "--only-current-dir", "", OptionTypeFlagTrue, "", "",
                "表示仅操作当前目录下的文件或者object, 忽略子目录",
                "specifies that only files or objects in the current directory are manipulated, and subdirectories are ignored."},
        OptionProbeItem: Option{"", "--probe-item", "", OptionTypeString, "", "",
                "表示probe命令的探测项目, 取值可为upload-speed, download-speed, cycle-symlink",
                "specifies probe command's probe item, the value can be upload-speed, download-speed, cycle-symlink"},
        OptionDisableEncodeSlash: Option{"", "--disable-encode-slash", "", OptionTypeFlagTrue, "", "",
                "表示不对url path中的'/'进行编码, 主要用于sign命令",
                "specifies no encoding of '/' in url path section, primarily used in sign command"},
        OptionDisableDirObject: Option{"", "--disable-dir-object", "", OptionTypeFlagTrue, "", "",
                "表示上传文件时不为目录生成oss对象,主要用于cp命令",
                "specifies that oss object is not generated for directory itself when uploading, primarily used in cp command"},
        OptionRedundancyType: Option{"", "--redundancy-type", "", OptionTypeString, "", "",
                "表示bucket的数据容灾类型, 取值可为LRS, ZRS. LRS为默认值,表示本地容灾, ZRS表示更高可用的同城多可用区容灾(3AZ)",
                "specifies bucket data redundancy type, the value can be LRS, ZRS. LRS is default value, specifies locally redundant storage; ZRS specifies higher availability of redundant storage"},
        OptionDisableAllSymlink: Option{"", "--disable-all-symlink", "", OptionTypeFlagTrue, "", "",
                "表示不允许上传目录下的链接文件以及链接目录, 缺省值为false",
                "specifies that uploading of symlink files and symlink directories under the directory is not allowed, the default value is false."},
        OptionDisableIgnoreError: Option{"", "--disable-ignore-error", "", OptionTypeFlagTrue, "", "",
                "批量操作时候不忽略错误, 缺省值为false",
                "specifies that do not ignore errors during batch cp, default value is false"},
        OptionTagging: Option{"", "--tagging", "", OptionTypeString, "", "",
                "设置object的tagging,取值格式如[\"TagA=A&amp;TagB=B...\"]",
                "Set object tagging, value format is [\"TagA=A&amp;TagB=B...]\""},
        OptionStartTime: Option{"", "--start-time", "", OptionTypeInt64, "", "",
                "起始时间,为linux/Unix系统里面的时间戳,既从1970年1月1日(UTC/GMT的午夜)开始所经过的秒数",
                "The start time is the timestamp in the Linux/Unix system, that is, the number of seconds that have passed since January 1, 1970 (midnight UTC/GMT)"},
        OptionEndTime: Option{"", "--end-time", "", OptionTypeInt64, "", "",
                "结束时间,为linux/Unix系统里面的时间戳,既从1970年1月1日(UTC/GMT的午夜)开始所经过的秒数",
                "The end time is the timestamp in the Linux/Unix system, that is, the number of seconds that have passed since January 1, 1970 (midnight UTC/GMT)"},
        OptionBackupDir: Option{"", "--backup-dir", "", OptionTypeString, "", "",
                "sync命令使用的备份文件的目录",
                "The directory of the backup file used by the sync command"},
        OptionPassword: Option{"-p", "--password", "", OptionTypeFlagTrue, "", "",
                "表示从键盘输入accessKeySecret参数",
                "specifies that the accessKeySecret is inputted from the keyboard"},
        OptionBlockSize: Option{"-B", "--block-size", "", OptionTypeString, "", "",
                "表示du命令字节显示的单位,取值可以为KB, MB, GB, TB",
                "specifies the unit of byte display for du command, the value can be KB, MB, GB, TB"},
        OptionMode: Option{"", "--mode", "", OptionTypeString, "", "",
                "表示鉴权模式，取值可以为AK，StsToken，RamRoleArn，EcsRamRole，缺省值为空",
                "specifies the authentication mode, the value can be AK，StsToken，RamRoleArn，EcsRamRole, default value is empty."},
        OptionRamRoleName: Option{"", "--ram-role-name", "", OptionTypeString, "", "",
                "表示角色名，主要用于EcsRamRole模式",
                "specifies the authentication mode, primarily used in EcsRamRole mode."},
        OptionExpiredSeconds: Option{"", "--expired-seconds", "", OptionTypeInt64, "", "",
                "表示会话超时时间，单位为秒, 缺省值为3600，主要用于RamRoleArn模式下的AssumeRole参数",
                "specifies the session timeout period, the unit is: s, default value is 3600, primarily used for AssumeRole parameters in RamRoleArn mode"},
        OptionRamRoleArn: Option{"", "--ram-role-arn", "", OptionTypeString, "", "",
                "表示RAM角色的ARN，主要用于RamRoleArn模式",
                "specifies the ARN of ram role, primarily used in RamRoleArn mode."},
        OptionRoleSessionName: Option{"", "--role-session-name", "", OptionTypeString, "", "",
                "表示会话名字，主要用于RamRoleArn模式",
                "specifies the session name, primarily used in RamRoleArn mode."},
        OptionReadTimeout: Option{"", "--read-timeout", "", OptionTypeInt64, "", "",
                "表示客户端读超时的时间，单位为秒, 缺省值为1200",
                "specifies the time that the client read timed out, the unit is: s, default value is 1200."},
        OptionConnectTimeout: Option{"", "--connect-timeout", "", OptionTypeInt64, "", "",
                "表示客户端连接超时的时间，单位为秒, 缺省值为120",
                "specifies the time that the client connection timed out, the unit is: s, default value is 120."},
        OptionSTSRegion: Option{"", "--sts-region", "", OptionTypeString, "", "",
                "指定sts endpoint，缺省值为中央endpoint，主要用于RamRoleArn模式",
                "specifies the sts endpoint, default value is central endpoint, primarily used in RamRoleArn mode."},
}

func (T *Option) getHelp(language string) string <span class="cov0" title="0">{
        switch strings.ToLower(language) </span>{
        case LEnglishLanguage:<span class="cov0" title="0">
                return T.helpEnglish</span>
        default:<span class="cov0" title="0">
                return T.helpChinese</span>
        }
}

// OptionMapType is the type for ossutil got options
type OptionMapType map[string]interface{}

// ParseArgOptions parse command line and returns args and options
func ParseArgOptions() ([]string, OptionMapType, error) <span class="cov0" title="0">{
        options := initOption()
        goopt.Args = make([]string, 0, 4)
        goopt.Description = func() string </span><span class="cov0" title="0">{
                return "Simple tool for access OSS."
        }</span>
        <span class="cov0" title="0">goopt.Parse(nil)
        if err := checkOption(options); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return goopt.Args, options, nil</span>
}

func initOption() OptionMapType <span class="cov0" title="0">{
        m := make(OptionMapType, len(OptionMap))
        for name, option := range OptionMap </span><span class="cov0" title="0">{
                switch option.optionType </span>{
                case OptionTypeInt64:<span class="cov0" title="0">
                        val, _ := stringOption(option)
                        m[name] = val</span>
                case OptionTypeFlagTrue:<span class="cov0" title="0">
                        val, _ := flagTrueOption(option)
                        m[name] = val</span>
                case OptionTypeAlternative:<span class="cov0" title="0">
                        val, _ := stringOption(option)
                        m[name] = val</span>
                default:<span class="cov0" title="0">
                        val, _ := stringOption(option)
                        m[name] = val</span>
                }
        }
        <span class="cov0" title="0">return m</span>
}

func stringOption(option Option) (*string, error) <span class="cov0" title="0">{
        names, err := makeNames(option)
        if err == nil </span><span class="cov0" title="0">{
                // ignore option.def, set it to "", will assemble it after
                return goopt.String(names, "", option.getHelp(DefaultLanguage)), nil
        }</span>
        <span class="cov0" title="0">return nil, err</span>
}

func flagTrueOption(option Option) (*bool, error) <span class="cov0" title="0">{
        names, err := makeNames(option)
        if err == nil </span><span class="cov0" title="0">{
                return goopt.Flag(names, []string{}, option.getHelp(DefaultLanguage), ""), nil
        }</span>
        <span class="cov0" title="0">return nil, err</span>
}

func makeNames(option Option) ([]string, error) <span class="cov0" title="0">{
        if option.name == "" &amp;&amp; option.nameAlias == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Internal Error, invalid option whose name and nameAlias empty!")
        }</span>

        <span class="cov0" title="0">var names []string
        if option.name == "" || option.nameAlias == "" </span><span class="cov0" title="0">{
                names = make([]string, 1)
                if option.name == "" </span><span class="cov0" title="0">{
                        names[0] = option.nameAlias
                }</span> else<span class="cov0" title="0"> {
                        names[0] = option.name
                }</span>
        } else<span class="cov0" title="0"> {
                names = make([]string, 2)
                names[0] = option.name
                names[1] = option.nameAlias
        }</span>
        <span class="cov0" title="0">return names, nil</span>
}

func checkOption(options OptionMapType) error <span class="cov0" title="0">{
        for name, optionInfo := range OptionMap </span><span class="cov0" title="0">{
                if option, ok := options[name]; ok </span><span class="cov0" title="0">{
                        if optionInfo.optionType == OptionTypeInt64 </span><span class="cov0" title="0">{
                                if val, ook := option.(*string); ook &amp;&amp; *val != "" </span><span class="cov0" title="0">{
                                        num, err := strconv.ParseInt(*val, 10, 64)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("invalid option value of %s, the value: %s is not int64, please check", name, *val)
                                        }</span>

                                        <span class="cov0" title="0">if optionInfo.minVal != "" </span><span class="cov0" title="0">{
                                                minv, _ := strconv.ParseInt(optionInfo.minVal, 10, 64)
                                                if num &lt; minv </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("invalid option value of %s, the value: %d is smaller than the min value range: %d", name, num, minv)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if optionInfo.maxVal != "" </span><span class="cov0" title="0">{
                                                maxv, _ := strconv.ParseInt(optionInfo.maxVal, 10, 64)
                                                if num &gt; maxv </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("invalid option value of %s, the value: %d is bigger than the max value range: %d", name, num, maxv)
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if optionInfo.optionType == OptionTypeAlternative </span><span class="cov0" title="0">{
                                if val, ook := option.(*string); ook &amp;&amp; *val != "" </span><span class="cov0" title="0">{
                                        vals := strings.Split(optionInfo.minVal, "/")
                                        if FindPosCaseInsen(*val, vals) == -1 </span><span class="cov0" title="0">{
                                                return fmt.Errorf("invalid option value of %s, the value: %s is not anyone of %s", name, *val, optionInfo.minVal)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// GetBool is used to get bool option from option map parsed by ParseArgOptions
func GetBool(name string, options OptionMapType) (bool, error) <span class="cov8" title="592">{
        if option, ok := options[name]; ok </span><span class="cov7" title="236">{
                if val, ook := option.(*bool); ook </span><span class="cov7" title="236">{
                        return *val, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("Error: option value of %s is not bool", name)</span>
        }
        <span class="cov7" title="356">return false, fmt.Errorf("Error: there is no option for %s", name)</span>
}

// GetInt is used to get int option from option map parsed by ParseArgOptions
func GetInt(name string, options OptionMapType) (int64, error) <span class="cov7" title="357">{
        if option, ok := options[name]; ok </span><span class="cov4" title="26">{
                switch option.(type) </span>{
                case *string:<span class="cov4" title="26">
                        val, err := strconv.ParseInt(*(option.(*string)), 10, 64)
                        if err == nil </span><span class="cov4" title="26">{
                                return val, nil
                        }</span>
                        <span class="cov0" title="0">if *(option.(*string)) == "" </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("Option value of %s is empty", name)
                        }</span>
                        <span class="cov0" title="0">return 0, err</span>
                case *int64:<span class="cov0" title="0">
                        return *(option.(*int64)), nil</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("Option value of %s is not int64", name)</span>
                }
        } else<span class="cov7" title="331"> {
                return 0, fmt.Errorf("There is no option for %s", name)
        }</span>
}

// GetString is used to get string option from option map parsed by ParseArgOptions
func GetString(name string, options OptionMapType) (string, error) <span class="cov10" title="2189">{
        if option, ok := options[name]; ok </span><span class="cov9" title="1043">{
                if val, ook := option.(*string); ook </span><span class="cov9" title="1043">{
                        return *val, nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("Error: Option value of %s is not string", name)</span>
        }
        <span class="cov9" title="1146">return "", fmt.Errorf("Error: There is no option for %s", name)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package lib

import (
        "bytes"
        "fmt"
        "log"
        "os"
        "path/filepath"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var logName = "ossutil.log"
var logLevel = oss.LogOff
var utilLogger *log.Logger
var logFile *os.File

func openLogFile() (*os.File, error) <span class="cov0" title="0">{
        dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
        if err != nil </span><span class="cov0" title="0">{
                dir = "."
        }</span>
        <span class="cov0" title="0">absLogName := dir + string(os.PathSeparator) + logName
        f, err := os.OpenFile(absLogName, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0660)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("open %s error,info:%s.\n", absLogName, err.Error())
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("log file is %s\n", absLogName)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func InitLogger(level int, name string) <span class="cov0" title="0">{
        logLevel = level
        logName = name
        f, err := openLogFile()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">utilLogger = log.New(f, "", log.LstdFlags|log.Lmicroseconds)
        logFile = f</span>
}

func UnInitLogger() <span class="cov0" title="0">{
        if logFile == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logFile.Close()
        logFile = nil
        utilLogger = nil</span>
}

func writeLog(level int, format string, a ...interface{}) <span class="cov0" title="0">{
        if utilLogger == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var logBuffer bytes.Buffer
        logBuffer.WriteString(oss.LogTag[level-1])
        logBuffer.WriteString(fmt.Sprintf(format, a...))
        utilLogger.Printf("%s", logBuffer.String())
        return</span>
}

func LogError(format string, a ...interface{}) <span class="cov0" title="0">{
        if logLevel &lt; oss.Error </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">writeLog(oss.Error, format, a...)</span>
}

func LogWarn(format string, a ...interface{}) <span class="cov0" title="0">{
        if logLevel &lt; oss.Warn </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">writeLog(oss.Warn, format, a...)</span>
}

func LogInfo(format string, a ...interface{}) <span class="cov10" title="134">{

        if logLevel &lt; oss.Info </span><span class="cov10" title="134">{
                return
        }</span>
        <span class="cov0" title="0">writeLog(oss.Info, format, a...)</span>
}

func LogDebug(format string, a ...interface{}) <span class="cov5" title="10">{
        if logLevel &lt; oss.Debug </span><span class="cov5" title="10">{
                return
        }</span>
        <span class="cov0" title="0">writeLog(oss.Debug, format, a...)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package lib

import (
        "bytes"
        "container/list"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

const (
        objectPrefex string = "oss-test-probe-"
)

const (
        normalMode    string = "normal"
        appendMode           = "append"
        multipartMode        = "multipart"
)

var specChineseProbe = SpecText{
        synopsisText: "探测命令,支持多种功能探测",

        paramText: "file_name [options]",

        syntaxText: ` 
    ossutil probe --download --url http_url [--addr=domain_name] [file_name]
    ossutil probe --download --bucketname bucket-name  [--object=object_name] [--addr=domain_name] [file_name]
    ossutil probe --upload [file_name] --bucketname bucket-name [--object=object_name] [--addr=domain_name]
    ossutil probe --probe-item item_value --bucketname bucket-name [--object=object_name]
`,

        detailHelpText: ` 
    下载探测(--download表示)分两种情况
      1、利用--url直接输入一个url网络地址，工具会下载该链接地址到本地
      2、利用--bucketname指定某个bucket下载
        如果输入--object，则下载指定bucket的指定object
        如果不输入--object，工具生成一个临时文件上传到oss，再将其下载下来，探测结束后将临时文件和临时object删除
        
    上传探测(--upload表示)
      1、如果输入文件参数file_name，则将该文件上传到指定的bucket
        如果不输入文件参数file_name,则工具生成一个临时文件上传到bucket，探测结束后再将临时文件删除
      2、如果输入--object，则上传到oss中对象名称为object_name,如果该object已经存在，会提示是否覆盖
        如果不输入--object，则上传到oss中object名称是随机生成的，探测结束后会将该临时object删除
                   
    上述命令中，file_name是参数，下载探测表示下载文件保存的目录名或者文件名，上传探测表示文件名

    其他探测功能(--probe-item表示)
    取值cycle-symlink: 探测本地目录是否存在死循环链接文件或者目录
    取值upload-speed: 探测上传带宽
    取值download-speed: 探测下载带宽
     

--url选项

    表示一个网络地址,ossutil会下载该地址

--bucketname

    oss中bucket的名称

--object

    oss中object的名称

--addr选项

    需要网络探测的域名，工具会对该域名进行ping等操作，默认值为www.aliyun.com

--upmode选项

    表示上传模式,缺省值为normal,取值为:normal|append|multipart,分别表示正常上传、追加上传、分块上传

--probe-item选项

    表示其他探测功能的项目

用法：

    该命令有四种用法：

    1) ossutil probe --download --url http_url [--addr=domain_name] [file_name]
        该用法下载http_url地址到本地文件系统中，并输出探测报告;如果不输入file_name，则下载文
    件保存在当前目录下，文件名由工具自动判断;如果输入file_name,则file_name为文件名或者目录名，
    下载的文件名为file_name或者保存在file_name目录下。
        如果输入--addr，工具会探测domain_name, 默认探测 www.aliyun.com

    2) ossutil probe --download --bucketname bucket-name  [--object=object_name] [--addr=domain_name] [file_name]
        该用法下载bucket中的object，并输出探测报告;指定--object则会下载bucket-name中
    的object_name;不指定--object，则工具会生成一个临时文件上传到oss后再将其下载，下载结束后
    会将临时文件和临时object删除
        如果输入--addr，工具会探测domain_name, 默认探测 www.aliyun.com

    3) ossutil probe --upload [file_name] --bucketname bucket-name [--object=object_name] [--addr=domain_name] 
        该用法是上传探测,会输出探测报告;如果指定file_name,则将该file_name文件上传到oss;不指定
        file_name,则工具会生成一个临时文件上传，探测结束后将临时文件删除;如果输入--object，则oss
    中object名称为object_name;如果不输入--object，则oss中object名称为工具自动生成，探测结束
    后会将该临时object删除
        如果输入--addr，工具会探测domain_name, 默认探测 www.aliyun.com
    
    4) ossutil probe --probe-item item_value --bucketname bucket-name [--object=object_name]
       该功能通过选项--probe-item不同的取值,可以实现不同的探测功能,目前取值有cycle-symlink, upload-speed, download-speed
    分别表示本地死链检测, 探测上传带宽, 探测下载带宽
`,

        sampleText: ` 
        1) 下载指定url
        ossutil probe --download --url "http://bucket-name.oss-cn-shenzhen.aliyuncs.com/object_name"
        
    2) 下载指定Url到指定文件
        ossutil probe --download --url "http://bucket-name.oss-cn-shenzhen.aliyuncs.com/object_name"  file_name
        
    3) 下载指定url到指定文件、并检测指定地址网络状况
        ossutil probe  --download --url "http://bucket-name.oss-cn-shenzhen.aliyuncs.com/object_name"  file_name --addr www.aliyun.com

    4) 下载bucket临时文件
        ossutil probe --download --bucketname bucket-name
        
    5) 下载bucket指定文件
        ossutil probe --download --bucketname bucket-name --object object_name

    6) 下载bucket指定的文件并保存到本地指定文件
        ossutil probe --download --bucketname bucket-name --object object_name  file_name

    7) 下载bucket指定文件并保存到本地指定文件，并检测指定地址网络状况
        ossutil probe --download --bucketname bucket-name --object object_name  file_name --addr www.aliyun.com
   
    8) 上传临时文件，以normal方式上传
        ossutil probe --upload --bucketname bucket-name --upmode normal

    9) 上传临时文件，以append方式上传
        ossutil probe --upload --bucketname bucket-name --upmode append

    10) 上传临时文件，以multipart方式上传
        ossutil probe --upload --bucketname bucket-name --upmode multipart

    11) 上传指定文件到指定object
        ossutil probe --upload file_name --bucketname bucket-name --object object_name

    12) 上传指定文件到指定object,并检测addr地址
        ossutil probe --upload file_name --bucketname bucket-name --object object_name --addr www.aliyun.com
    
    13) 检测本地目录dir是否存在死循环链接文件或者目录
        ossutil probe --probe-item cycle-symlink dir

    14) 探测上传带宽
        ossutil probe --probe-item upload-speed --bucketname bucket-name
    
    15) 探测下载带宽, object要已经存在,且大小最好超过5M
        ossutil probe --probe-item download-speed --bucketname bucket-name --object object_name
`,
}

var specEnglishProbe = SpecText{
        synopsisText: "Probe command, support for multiple function detection",

        paramText: "file_name [options]",

        syntaxText: ` 
        ossutil probe --download --url http_url [--addr=domain_name] [file_name]
    ossutil probe --download --bucketname bucket-name  [--object=object_name] [--addr=domain_name] [file_name]
    ossutil probe --upload [file_name] --bucketname bucket-name [--object=object_name] [--addr=domain_name] 
    ossutil probe --probe-item item_value --bucketname bucket-name [--object=object_name]
`,

        detailHelpText: ` 
        Download probe (--download) has two usages
      1、Use --url to input a url, ossutil will download the link
      2、Use --bucketname to download the specified bucket's object
        If input --object, downloads the specified object of the specified bucket.
        If do not input --object, ossutil creates a temporary file to upload to oss, then downloads it, and deletes the temporary file and temporary object after the probe ends.
        
    Upload probe (--upload)
      1、If input parameter file_name, the specified file is uploaded to the specified bucket.
         If do not input parameter file_name, ossutil creates a temporary file to upload, and then deletes the temporary file after the probe ends.
      2、If input --object, the object name is specified,if the object already exists, you will be prompted to overwrite or not.
         If do not input --object, the object name is randomly generated, and the temporary object will be deleted after the probe ends.
                   
    In the above commands, file_name is a parameter which may be a directory name or a file name in the case of download probe, and must be a exist file name in the case of upload probe

    Other detection functions(--probe-item)
    value cycle-symlink: Detects whether there is an infinite loop link file or directory in the local directory
    value upload-speed: probe upload bandwidth
    value download-speed: probe download bandwidth

--url option

    Specifies a network address which will be downloaded by ossutil

--bucketname option

    Specifies a bucket name in oss
   
--object option

    Specifies a object name in oss bucket

--addr option
    
    Specifies a domain name which will be probed by ossutil,the default value is www.aliyun.com

--upmode option

    specifies the upload mode,default value is normal,value is:normal|append|multipart

--probe-item选项

    specifies other detection functions

Usage:

    There are four usages for this command:

    1) ossutil probe --download --url http_url [--addr=domain_name] [file_name]
                
        The command downloads the http_url address to the local file system and outputs
        probe report; if you do not input file_name, the downloaded file is saved in the 
        current directory and the file name is determined by ossutil; if file_name is inputed, 
        The downloaded file is named file_name.
        If you input --addr, ossutil will probe the domain_name,default probe www.aliyun.com

    2) ossutil probe --download --bucketname bucket-name  [--object=object_name] [--addr=domain_name] [file_namefile_name]
                
        The command downloads object in the specified bucket and outputs probe report; 
        if you input --object,ossutil downloads the specified object; if you don't input --object
        ,ossutil creates a temporary file to upload and then downloads it; after probe end,temporary 
    file and temporary object will all be deleted
        If you input --addr, ossutil will probe the domain_name,default probe www.aliyun.com

    3) ossutil probe --upload [file_name] --bucketname bucket-name [--object=object_name] [--addr=domain_name] 
                
        The command uploads a file to oss and outputs probe report; if you input file_name,
        the file named file_name is uploaded; if you don't input file_name,ossutil creates a temporary
        file to upload and delete it after the probe ends; if you input --object, the uploaded object
        is named object_name; if you don't input --object, the uploaded object's name is determined by 
        ossutil, and after probe end,the temporary object will be deleted
        If you input --addr, ossutil will probe the domain_name,default probe www.aliyun.com
    
    4) ossutil probe --probe-item item_value --bucketname bucket-name [--object=object_name]
        You can implement different detection functions by using the value of the option --probe-item.
    The current values ​​are cycle-symlink, upload-speed, download-speed which represents local dead link detection, 
    probe upload bandwidth, and probe download bandwidth
`,

        sampleText: ` 
        1) downloads specified url
        ossutil probe --download --url "http://bucket-name.oss-cn-shenzhen.aliyuncs.com/object_name"
        
    2) downloads specified url to specified file
        ossutil probe --download --url "http://bucket-name.oss-cn-shenzhen.aliyuncs.com/object_name"  file_name
        
    3) downloads specified url to specified file,and ping domain
        ossutil probe  --download --url "http://bucket-name.oss-cn-shenzhen.aliyuncs.com/object_name"  file_name --addr www.aliyun.com

    4) downloads temporary file from specified bucket
        ossutil probe --download --bucketname bucket-name
        
    5) downloads specified object from specified bucket
        ossutil probe --download --bucketname bucket-name --object object_name

    6) downloads specified object from specified bucket to specified file
        ossutil probe --download --bucketname bucket-name --object object_name  file_name

    7) downloads specified object from specified bucket to specified file,and probe domain
        ossutil probe --download --bucketname bucket-name --object object_name  file_name --addr www.aliyun.com
   
    8) uploads a temporary file with normal mode
        ossutil probe --upload --bucketname bucket-name --upmode normal

    9) uploads a temporary file with append mode
        ossutil probe --upload --bucketname bucket-name --upmode append

    10) uploads a temporary file with multipart mode
        ossutil probe --upload --bucketname bucket-name --upmode multipart

    11) uploads specified file to specified object
        ossutil probe --upload file_name --bucketname bucket-name --object object_name

    12) uploads specified file to specified object, and probe domain
        ossutil probe --upload file_name --bucketname bucket-name --object object_name --addr www.aliyun.com
    
    13) Check if the local directory dir has an infinite loop link file or directory
        ossutil probe --probe-item cycle-symlink dir

    14) Probe upload bandwidth
        ossutil probe --probe-item upload-speed --bucketname bucket-name
    
    15) Detect download bandwidth, object must already exist, and the size is better than 5M
        ossutil probe --probe-item download-speed --bucketname bucket-name --object object_name
`,
}

type probeOptionType struct {
        disableNetDetect bool
        opUpload         bool
        opDownload       bool
        fromUrl          string
        bucketName       string
        objectName       string
        netAddr          string
        upMode           string
        logFile          *os.File
        logName          string
        dlFileSize       int64
        dlFilePath       string
        ulObject         string
        probeItem        string
}

type ProbeCommand struct {
        command  Command
        pbOption probeOptionType
}

var probeCommand = ProbeCommand{
        command: Command{
                name:        "probe",
                nameAlias:   []string{"probe"},
                minArgc:     0,
                maxArgc:     MaxInt,
                specChinese: specChineseProbe,
                specEnglish: specEnglishProbe,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionUpload,
                        OptionDownload,
                        OptionUrl,
                        OptionBucketName,
                        OptionObject,
                        OptionAddr,
                        OptionUpMode,
                        OptionLogLevel,
                        OptionProbeItem,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

type TestAppendReader struct {
        RandText []byte
        bClosed  bool
}

// Read
func (r *TestAppendReader) Close() <span class="cov0" title="0">{
        r.bClosed = true
}</span>

// Read
func (r *TestAppendReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if r.bClosed </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("ossutil probe closed")
        }</span>

        <span class="cov0" title="0">n = copy(p, r.RandText)
        for n &lt; len(p) </span><span class="cov0" title="0">{
                nn := copy(p[n:], r.RandText)
                n += nn
        }</span>
        <span class="cov0" title="0">return n, nil</span>
}

type AverageInfo struct {
        Parallel int
        AveSpeed float64
}

type StatBandWidth struct {
        Mu         sync.Mutex
        Parallel   int
        StartTick  int64
        TotalBytes int64
        MaxSpeed   float64
}

func (s *StatBandWidth) Reset(pc int) <span class="cov0" title="0">{
        s.Mu.Lock()
        defer s.Mu.Unlock()
        s.Parallel = pc
        s.StartTick = time.Now().UnixNano() / 1000 / 1000
        atomic.StoreInt64(&amp;s.TotalBytes, 0)
        s.MaxSpeed = 0.0
}</span>

func (s *StatBandWidth) AddBytes(bc int64) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;s.TotalBytes, bc)
}</span>

func (s *StatBandWidth) SetMaxSpeed(ms float64) <span class="cov0" title="0">{
        s.Mu.Lock()
        defer s.Mu.Unlock()
        s.MaxSpeed = ms
}</span>

func (s *StatBandWidth) GetStat() *StatBandWidth <span class="cov0" title="0">{
        var rs StatBandWidth
        s.Mu.Lock()
        defer s.Mu.Unlock()
        rs.Parallel = s.Parallel
        rs.StartTick = s.StartTick
        rs.TotalBytes = atomic.LoadInt64(&amp;s.TotalBytes)
        rs.MaxSpeed = s.MaxSpeed
        return &amp;rs
}</span>

func (s *StatBandWidth) ProgressChanged(event *oss.ProgressEvent) <span class="cov0" title="0">{
        if event.EventType == oss.TransferDataEvent || event.EventType == oss.TransferCompletedEvent </span><span class="cov0" title="0">{
                s.AddBytes(event.RwBytes)
        }</span>
}

// function for FormatHelper interface
func (pc *ProbeCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return pc.command.formatHelpForWhole()
}</span>

func (pc *ProbeCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return pc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (pc *ProbeCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        err := pc.command.Init(args, options, pc)
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">errStr := err.Error()
        if strings.Contains(errStr, "Read config file error") &amp;&amp; isNotNeedConigFile(options) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

func isNotNeedConigFile(options OptionMapType) bool <span class="cov0" title="0">{
        isDownload, _ := GetBool(OptionDownload, options)
        fromUrl, _ := GetString(OptionUrl, options)
        probeItem, _ := GetString(OptionProbeItem, options)
        if (isDownload &amp;&amp; fromUrl != "") || probeItem == "cycle-symlink" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// RunCommand simulate inheritance, and polymorphism
func (pc *ProbeCommand) RunCommand() error <span class="cov0" title="0">{
        var err error

        pc.pbOption.opUpload, _ = GetBool(OptionUpload, pc.command.options)
        pc.pbOption.opDownload, _ = GetBool(OptionDownload, pc.command.options)
        pc.pbOption.fromUrl, _ = GetString(OptionUrl, pc.command.options)
        pc.pbOption.bucketName, _ = GetString(OptionBucketName, pc.command.options)
        pc.pbOption.objectName, _ = GetString(OptionObject, pc.command.options)
        pc.pbOption.netAddr, _ = GetString(OptionAddr, pc.command.options)
        pc.pbOption.upMode, _ = GetString(OptionUpMode, pc.command.options)
        pc.pbOption.probeItem, _ = GetString(OptionProbeItem, pc.command.options)

        if pc.pbOption.probeItem != "" </span><span class="cov0" title="0">{
                var err error
                if pc.pbOption.probeItem == "cycle-symlink" </span><span class="cov0" title="0">{
                        err = pc.CheckCycleSymlinkWithDeepTravel()
                        if err == nil </span><span class="cov0" title="0">{
                                fmt.Println("\n", "success")
                        }</span>
                } else<span class="cov0" title="0"> if pc.pbOption.probeItem == "upload-speed" || pc.pbOption.probeItem == "download-speed" </span><span class="cov0" title="0">{
                        err = pc.DetectBandWidth()
                }</span> else<span class="cov0" title="0"> {
                        err = fmt.Errorf("not support %s", pc.pbOption.probeItem)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">pc.pbOption.logFile, pc.pbOption.logName, err = logFileMake()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probe logFileMake error,%s", err.Error())
        }</span>
        <span class="cov0" title="0">defer pc.pbOption.logFile.Close()

        pc.pbOption.logFile.WriteString("*************************        system information        *************************\n")
        pc.pbOption.logFile.WriteString(fmt.Sprintf("operating system:%s_%s\n", runtime.GOOS, runtime.GOARCH))
        pc.pbOption.logFile.WriteString(fmt.Sprintf("operating time:%s\n", time.Now().Format("2006-01-02 15:04:05")))

        if pc.pbOption.opUpload &amp;&amp; pc.pbOption.opDownload </span><span class="cov0" title="0">{
                err = fmt.Errorf("error,upload and download are both true")
        }</span> else<span class="cov0" title="0"> if !pc.pbOption.opUpload &amp;&amp; !pc.pbOption.opDownload </span><span class="cov0" title="0">{
                err = fmt.Errorf("error,upload and download are both false")
        }</span> else<span class="cov0" title="0"> if !pc.pbOption.opUpload &amp;&amp; pc.pbOption.opDownload </span><span class="cov0" title="0">{
                err = pc.probeDownload()
        }</span> else<span class="cov0" title="0"> {
                err = pc.probeUpload()
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (pc *ProbeCommand) PutObject(bucket *oss.Bucket, st *StatBandWidth, reader io.Reader) <span class="cov0" title="0">{
        var options []oss.Option
        options = append(options, oss.Progress(st))
        uniqKey := strconv.FormatInt(time.Now().UnixNano(), 10) + "-" + randStr(10)
        objectName := objectPrefex + uniqKey
        err := bucket.PutObject(objectName, reader, options...)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "ossutil probe closed") </span><span class="cov0" title="0">{
                fmt.Printf("%s\n", err.Error())
        }</span>
}

func (pc *ProbeCommand) GetObject(bucket *oss.Bucket, objectName string, st *StatBandWidth) <span class="cov0" title="0">{
        var options []oss.Option
        options = append(options, oss.Progress(st))
        options = append(options, oss.AcceptEncoding("identity"))
        for </span><span class="cov0" title="0">{
                result, err := bucket.DoGetObject(&amp;oss.GetObjectRequest{ObjectKey: objectName}, options)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("GetObject error,%s", err.Error())
                        return
                }</span>
                <span class="cov0" title="0">io.Copy(ioutil.Discard, result.Response.Body)
                result.Response.Close()</span>
        }
}

func (pc *ProbeCommand) DetectBandWidth() error <span class="cov0" title="0">{
        if pc.pbOption.bucketName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--bucketname is empty")
        }</span>

        <span class="cov0" title="0">bucket, err := pc.command.ossBucket(pc.pbOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if pc.pbOption.probeItem == "download-speed" </span><span class="cov0" title="0">{
                if pc.pbOption.objectName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("--object is empty when probe-item is download-speed")
                }</span>

                <span class="cov0" title="0">bExist, err := bucket.IsObjectExist(pc.pbOption.objectName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !bExist </span><span class="cov0" title="0">{
                        return fmt.Errorf("oss object is not exist,%s", pc.pbOption.objectName)
                }</span>
        }

        <span class="cov0" title="0">numCpu := runtime.NumCPU()
        var statBandwidth StatBandWidth
        statBandwidth.Reset(numCpu)

        var appendReader TestAppendReader
        if pc.pbOption.probeItem == "upload-speed" </span><span class="cov0" title="0">{
                appendReader.RandText = []byte(strings.Repeat("1", 32*1024))
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; numCpu; i++ </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(50) * time.Millisecond)
                if pc.pbOption.probeItem == "upload-speed" </span><span class="cov0" title="0">{
                        go pc.PutObject(bucket, &amp;statBandwidth, &amp;appendReader)
                }</span> else<span class="cov0" title="0"> if pc.pbOption.probeItem == "download-speed" </span><span class="cov0" title="0">{
                        go pc.GetObject(bucket, pc.pbOption.objectName, &amp;statBandwidth)
                }</span>
        }

        <span class="cov0" title="0">time.Sleep(time.Duration(2) * time.Second)

        fmt.Printf("cpu core count:%d\n", numCpu)
        startTick := time.Now().UnixNano() / 1000 / 1000
        nowTick := startTick
        changeTick := startTick
        nowParallel := numCpu
        addParallel := numCpu / 5
        if addParallel == 0 </span><span class="cov0" title="0">{
                addParallel = 1
        }</span>
        <span class="cov0" title="0">var averageList []AverageInfo

        // ignore the first max speed
        bDiscarded := false
        var oldStat *StatBandWidth
        var nowStat *StatBandWidth

        oldStat = statBandwidth.GetStat()
        for nowParallel &lt;= 2*numCpu </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(1) * time.Second)
                nowStat = statBandwidth.GetStat()
                nowTick = time.Now().UnixNano() / 1000 / 1000

                nowSpeed := float64(nowStat.TotalBytes-oldStat.TotalBytes) / 1024
                averSpeed := float64(nowStat.TotalBytes/1024) / float64((nowTick-nowStat.StartTick)/1000)
                maxSpeed := nowStat.MaxSpeed
                if nowSpeed &gt; maxSpeed </span><span class="cov0" title="0">{
                        if !bDiscarded &amp;&amp; maxSpeed &lt; 0.0001 </span><span class="cov0" title="0">{
                                bDiscarded = true
                                oldStat.Reset(nowParallel)
                                statBandwidth.Reset(nowParallel) //discard the first max speed,becase is not accurate
                                continue</span>
                        }
                        <span class="cov0" title="0">maxSpeed = nowSpeed
                        statBandwidth.SetMaxSpeed(maxSpeed)</span>
                }
                <span class="cov0" title="0">fmt.Printf("\rparallel:%d,average speed:%.2f(KB/s),current speed:%.2f(KB/s),max speed:%.2f(KB/s)", nowStat.Parallel, averSpeed, nowSpeed, maxSpeed)
                oldStat = nowStat

                // 30 second
                if nowTick-changeTick &gt;= 30000 </span><span class="cov0" title="0">{
                        nowParallel += addParallel
                        for i := 0; i &lt; addParallel; i++ </span><span class="cov0" title="0">{
                                time.Sleep(time.Duration(50) * time.Millisecond)
                                if pc.pbOption.probeItem == "upload-speed" </span><span class="cov0" title="0">{
                                        go pc.PutObject(bucket, &amp;statBandwidth, &amp;appendReader)
                                }</span> else<span class="cov0" title="0"> if pc.pbOption.probeItem == "download-speed" </span><span class="cov0" title="0">{
                                        go pc.GetObject(bucket, pc.pbOption.objectName, &amp;statBandwidth)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("\n")
                        bDiscarded = false
                        averageList = append(averageList, AverageInfo{Parallel: nowStat.Parallel, AveSpeed: averSpeed})
                        changeTick = nowTick
                        oldStat.Reset(nowParallel)
                        statBandwidth.Reset(nowParallel)</span>
                }
        }

        <span class="cov0" title="0">appendReader.Close()

        maxIndex := 0
        maxSpeed := 0.0
        for k, v := range averageList </span><span class="cov0" title="0">{
                if v.AveSpeed &gt; maxSpeed </span><span class="cov0" title="0">{
                        maxIndex = k
                        maxSpeed = v.AveSpeed
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nsuggest parallel is %d, max average speed is %.2f(KB/s)\n", averageList[maxIndex].Parallel, averageList[maxIndex].AveSpeed)

        return nil</span>
}

func (pc *ProbeCommand) CheckCycleSymlinkWithDeepTravel() error <span class="cov0" title="0">{
        if len(pc.command.args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("dir parameter is emtpy")
        }</span>

        <span class="cov0" title="0">dpath := pc.command.args[0]
        fileInfo, err := os.Stat(dpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !fileInfo.IsDir() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !strings.HasSuffix(dpath, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                dpath += string(os.PathSeparator)
        }</span>

        <span class="cov0" title="0">DirStack := list.New()
        DirStack.PushBack(dpath)
        for DirStack.Len() &gt; 0 </span><span class="cov0" title="0">{
                dirItem := DirStack.Back()
                DirStack.Remove(dirItem)
                dirName := dirItem.Value.(string)
                fileList, err := ioutil.ReadDir(dirName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, fileInfo := range fileList </span><span class="cov0" title="0">{
                        realInfo, err := os.Stat(dirName + fileInfo.Name())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if realInfo.IsDir() </span><span class="cov0" title="0">{
                                DirStack.PushBack(dirName + fileInfo.Name() + string(os.PathSeparator))
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (pc *ProbeCommand) probeDownload() error <span class="cov0" title="0">{
        var err error
        pingPath := ""
        if pc.pbOption.fromUrl != "" </span><span class="cov0" title="0">{
                pingPath, _, err = urlCheck(pc.pbOption.fromUrl)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("probeDownloadWithHttpUrl error,%s", err.Error())
                }</span>
        } else<span class="cov0" title="0"> {
                if pc.pbOption.bucketName == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("probeDownloadWithParameter error,bucketName is not exist")
                }</span>

                <span class="cov0" title="0">endPoint, _ := pc.command.getEndpoint(pc.pbOption.bucketName)
                if endPoint == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("probeDownloadWithParameter error,endpoint is not exist")
                }</span>

                <span class="cov0" title="0">pSlice := strings.Split(endPoint, "//")
                if len(pSlice) == 1 </span><span class="cov0" title="0">{
                        endPoint = pSlice[0]
                }</span> else<span class="cov0" title="0"> {
                        endPoint = pSlice[1]
                }</span>
                <span class="cov0" title="0">pingPath = endPoint</span>
        }

        <span class="cov0" title="0">fmt.Printf("begin parse parameters and prepare object...[√]\n")

        fmt.Printf("begin network detection...")
        pc.ossNetDetection(pingPath)
        fmt.Printf("\rbegin network detection...[√]\n")

        startT := time.Now()
        if pc.pbOption.fromUrl != "" </span><span class="cov0" title="0">{
                err = pc.downloadWithHttpUrl()
        }</span> else<span class="cov0" title="0"> {
                err = pc.probeDownloadWithParameter()
        }</span>
        <span class="cov0" title="0">endT := time.Now()

        var logBuff bytes.Buffer
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf("\rbegin download file...[√]\n")

                logBuff.WriteString("\n*************************  download result  *************************\n")
                logBuff.WriteString("download file:success\n")
                logBuff.WriteString(fmt.Sprintf("download file size:%d(byte)\n", pc.pbOption.dlFileSize))
                logBuff.WriteString(fmt.Sprintf("download time consuming:%d(ms)\n", endT.UnixNano()/1000/1000-startT.UnixNano()/1000/1000))
                logBuff.WriteString("(only the time consumed by probe command)\n\n")

                if pc.pbOption.dlFilePath != "" </span><span class="cov0" title="0">{
                        logBuff.WriteString(fmt.Sprintf("download file is %s\n", pc.pbOption.dlFilePath))
                }</span>

        } else<span class="cov0" title="0"> {
                fmt.Printf("\rbegin download file...[x]\n\n")

                logBuff.WriteString("\n*************************  download result  *************************\n")
                logBuff.WriteString("download file:failure\n")

                logBuff.WriteString("\n*************************  error message *************************\n")
                logBuff.WriteString(fmt.Sprintf("%s\n", err.Error()))
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s", logBuff.String())
        pc.pbOption.logFile.WriteString(logBuff.String())

        fmt.Printf("\n************************* report log info*************************\n")
        fmt.Printf("report log file:%s\n\n", pc.pbOption.logName)

        return err</span>
}

// the only arg in this command is input or output file name
func (pc *ProbeCommand) getFileNameArg() (fileName string, err error) <span class="cov0" title="0">{
        if len(pc.command.args) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">fileName = pc.command.args[0]
        fileURL, err := StorageURLFromString(fileName, "")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("StorageURLFromString error:%s", err.Error())
        }</span>

        <span class="cov0" title="0">if !fileURL.IsFileURL() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("not a local file name:%s", fileURL.ToString())
        }</span>
        <span class="cov0" title="0">return</span>
}

func (pc *ProbeCommand) downloadWithHttpUrl() error <span class="cov0" title="0">{
        _, srcName, err := urlCheck(pc.pbOption.fromUrl)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("downloadWithHttpUrl urlCheck error,%s", err.Error())
        }</span>

        <span class="cov0" title="0">fileName, err := pc.getFileNameArg()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("downloadWithHttpUrl getFileNameArg error,%s", err.Error())
        }</span>

        <span class="cov0" title="0">downloadFileName, err := prepareLocalFileName(srcName, fileName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("downloadWithHttpUrl prepareLocalFileName error,%s", err.Error())
        }</span>

        <span class="cov0" title="0">sizeStat, err := os.Stat(downloadFileName)
        if err == nil </span><span class="cov0" title="0">{
                bConitnue := confirm(downloadFileName)
                if !bConitnue </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">res, err := http.Get(pc.pbOption.fromUrl)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("downloadWithHttpUrl http.Get error,%s", err.Error())
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        pc.pbOption.logFile.WriteString("\n************************* response info*************************\n")
        pc.pbOption.logFile.WriteString(fmt.Sprintf("status code:%s\n", res.Status))
        res.Header.Write(pc.pbOption.logFile)

        if res.StatusCode != 200 </span><span class="cov0" title="0">{
                return fmt.Errorf("http status code:%s", res.Status)
        }</span>

        <span class="cov0" title="0">fileRecord, err := os.Create(downloadFileName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("downloadWithHttpUrl http.Get error,%s", err.Error())
        }</span>
        <span class="cov0" title="0">io.Copy(fileRecord, res.Body)
        sizeStat, err = fileRecord.Stat()
        fileRecord.Close()

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("downloadWithHttpUrl fileRecord.Stat error,%s", err.Error())
        }</span>

        <span class="cov0" title="0">pc.pbOption.dlFileSize = sizeStat.Size()
        pc.pbOption.dlFilePath = downloadFileName

        return nil</span>
}

func (pc *ProbeCommand) probeDownloadWithParameter() error <span class="cov0" title="0">{
        var err error
        var srcURL CloudURL
        var bDeleteObject = false
        srcURL.bucket = pc.pbOption.bucketName
        if pc.pbOption.objectName == "" </span><span class="cov0" title="0">{
                uniqKey := strconv.FormatInt(time.Now().UnixNano(), 10) + "-" + randStr(10)
                objectName := objectPrefex + uniqKey
                err := pc.prepareRandomObject(objectName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("prepareRandomObject error,%s", err.Error())
                }</span>

                <span class="cov0" title="0">srcURL.object = objectName
                bDeleteObject = true</span>
        } else<span class="cov0" title="0"> {
                srcURL.object = pc.pbOption.objectName
        }</span>

        <span class="cov0" title="0">srcURL.urlStr = srcURL.ToString()
        err = pc.probeDownloadObject(srcURL, bDeleteObject)
        return err</span>
}

func (pc *ProbeCommand) probeDownloadObject(srcURL CloudURL, bDeleteObject bool) error <span class="cov0" title="0">{
        fileName, err := pc.getFileNameArg()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeDownloadObject error,%s", err.Error())
        }</span>

        <span class="cov0" title="0">downloadFileName, err := prepareLocalFileName(srcURL.object, fileName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeDownloadObject error,%s", err.Error())
        }</span> else<span class="cov0" title="0"> {
                _, err := os.Stat(downloadFileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := confirm(downloadFileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">bucket, err := pc.command.ossBucket(srcURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("bucket:%s,probeDownloadObject error,%s", srcURL.bucket, err.Error())
        }</span>

        <span class="cov0" title="0">err = bucket.GetObjectToFile(srcURL.object, downloadFileName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("bucket:%s,GetObjectToFile error,%s", srcURL.bucket, err.Error())
        }</span>

        <span class="cov0" title="0">sizeStat, err := os.Stat(downloadFileName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("GetObjectToFile error,%s", err.Error())
        }</span>

        <span class="cov0" title="0">pc.pbOption.dlFileSize = sizeStat.Size()
        pc.pbOption.dlFilePath = downloadFileName

        if bDeleteObject </span><span class="cov0" title="0">{
                pc.deleteObject(srcURL.object)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (pc *ProbeCommand) prepareRandomObject(objectName string) (err error) <span class="cov0" title="0">{
        //judge objectName exist or not
        bucket, err := pc.command.ossBucket(pc.pbOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">isExist, err := bucket.IsObjectExist(objectName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                return fmt.Errorf("random object %s exist,please try again", objectName)
        }</span>

        // put up object
        <span class="cov0" title="0">var textBuffer bytes.Buffer
        for i := 0; i &lt; 10240; i++ </span><span class="cov0" title="0">{
                textBuffer.WriteString("testossprobe")
        }</span>

        <span class="cov0" title="0">err = bucket.PutObject(objectName, strings.NewReader(textBuffer.String()))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (pc *ProbeCommand) deleteObject(objectName string) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, pc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                bucket, err := pc.command.ossBucket(pc.pbOption.bucketName)
                if err == nil </span><span class="cov0" title="0">{
                        err = bucket.DeleteObject(objectName)
                        if err == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">_, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || noNeedRetry </span><span class="cov0" title="0">{
                        return err
                }</span>

                // wait 1 second
                <span class="cov0" title="0">time.Sleep(time.Duration(1) * time.Second)</span>
        }
}

func (pc *ProbeCommand) ossNetDetection(pingPath string) <span class="cov0" title="0">{
        if pc.pbOption.disableNetDetect </span><span class="cov0" title="0">{
                return // for test:reduce test time
        }</span>

        <span class="cov0" title="0">var netAddr = "www.aliyun.com"

        if pc.pbOption.netAddr != "" </span><span class="cov0" title="0">{
                netAddr = pc.pbOption.netAddr
        }</span>

        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                pingProcess(pc.pbOption.logFile, "ping", netAddr)
                pingProcess(pc.pbOption.logFile, "ping", pingPath)
                pingProcess(pc.pbOption.logFile, "tracert", pingPath)
                pingProcess(pc.pbOption.logFile, "nslookup", pingPath)
        }</span> else<span class="cov0" title="0"> {
                // linux or mac
                pingProcess(pc.pbOption.logFile, "ping", netAddr, "-c", "4")
                pingProcess(pc.pbOption.logFile, "ping", pingPath, "-c", "4")
                pingProcess(pc.pbOption.logFile, "traceroute", "-m", "20", pingPath)
                pingProcess(pc.pbOption.logFile, "dig", pingPath)
        }</span>
}

func prepareLocalFileName(srcName string, destName string) (absDestFileName string, err error) <span class="cov0" title="0">{
        absDestFileName = ""
        err = nil

        keyName := srcName
        urlSplits := strings.Split(srcName, "/")
        if len(urlSplits) &gt; 1 </span><span class="cov0" title="0">{
                keyName = urlSplits[len(urlSplits)-1]
        }</span>

        // it is absolute path
        <span class="cov0" title="0">currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if destName == "" </span><span class="cov0" title="0">{
                absDestFileName = currentDir + string(os.PathSeparator) + keyName
                return
        }</span>

        // get absolute path
        <span class="cov0" title="0">absDestFileName, err = filepath.Abs(destName)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if strings.HasSuffix(destName, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                err = os.MkdirAll(absDestFileName, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">absDestFileName = absDestFileName + string(os.PathSeparator) + keyName</span>
        } else<span class="cov0" title="0"> {
                f, serr := os.Stat(absDestFileName)
                if serr == nil &amp;&amp; f.IsDir() </span><span class="cov0" title="0">{
                        absDestFileName = absDestFileName + string(os.PathSeparator) + keyName
                }</span> else<span class="cov0" title="0"> {
                        err = os.MkdirAll(filepath.Dir(absDestFileName), 0755)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func urlCheck(strUrl string) (string, string, error) <span class="cov0" title="0">{
        var err error
        urlSplits := strings.Split(strUrl, "/")
        if len(urlSplits) &lt; 4 </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid url:%s", strUrl)
                return "", "", err
        }</span>
        <span class="cov0" title="0">pingPath := urlSplits[2]
        urlGetFileName := urlSplits[len(urlSplits)-1]
        endPos := strings.Index(urlGetFileName, "?")
        if endPos &gt; 0 </span><span class="cov0" title="0">{
                urlGetFileName = urlGetFileName[0:endPos]
        }</span>

        <span class="cov0" title="0">if pingPath == "" || urlGetFileName == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid url:%s", strUrl)
        }</span>

        <span class="cov0" title="0">return pingPath, urlGetFileName, nil</span>
}

func logFileMake() (logFile *os.File, logName string, err error) <span class="cov0" title="0">{
        dirName, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">logName = dirName + string(os.PathSeparator) + "logOssProbe" + time.Now().Format("20060102150405") + ".log"
        logFile, err = os.OpenFile(logName, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0660)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">return</span>
}

func pingProcess(logFile *os.File, instruction string, args ...string) <span class="cov0" title="0">{
        logFile.WriteString("\n\n")
        logFile.WriteString(fmt.Sprintf("*************************        %s        *************************\n", instruction))
        logFile.WriteString(fmt.Sprintf("Command =&gt; %s", instruction))
        for _, v := range args </span><span class="cov0" title="0">{
                logFile.WriteString(fmt.Sprintf(" %s", v))
        }</span>
        <span class="cov0" title="0">logFile.WriteString("\n")

        c := exec.Command(instruction, args...)
        d, _ := c.Output()
        logFile.WriteString(string(d))
        c.Run()</span>
}

func confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("probe: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (pc *ProbeCommand) probeUpload() error <span class="cov0" title="0">{
        upMode := pc.pbOption.upMode
        if upMode == "" </span><span class="cov0" title="0">{
                upMode = normalMode
        }</span> else<span class="cov0" title="0"> {
                if upMode != normalMode &amp;&amp; upMode != appendMode &amp;&amp; upMode != multipartMode </span><span class="cov0" title="0">{
                        return fmt.Errorf("probeUpload errro,invalid mode flag:%s", upMode)
                }</span>
        }

        <span class="cov0" title="0">if pc.pbOption.bucketName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUpload error,bucketName is not exist")
        }</span>

        <span class="cov0" title="0">endPoint, _ := pc.command.getEndpoint(pc.pbOption.bucketName)
        if endPoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUpload error,endpoint is not exist")
        }</span>

        <span class="cov0" title="0">pSlice := strings.Split(endPoint, "//")
        if len(pSlice) == 1 </span><span class="cov0" title="0">{
                endPoint = pSlice[0]
        }</span> else<span class="cov0" title="0"> {
                endPoint = pSlice[1]
        }</span>
        <span class="cov0" title="0">pingPath := endPoint

        objectName := pc.pbOption.objectName
        srcFileName, err := pc.getFileNameArg()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUpload errro,getFileNameArg error:%s", err.Error())
        }</span>

        <span class="cov0" title="0">var bDeleteLocalFile = false
        fileSize := int64(0)
        if srcFileName == "" </span><span class="cov0" title="0">{
                // it is absolute path
                currentDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("probeUpload errro,os.Getwd error:%s", err.Error())
                }</span>
                <span class="cov0" title="0">uniqKey := strconv.FormatInt(time.Now().UnixNano(), 10) + "-" + randStr(10)
                tempName := objectPrefex + uniqKey
                srcFileName = currentDir + string(os.PathSeparator) + tempName

                _, err = os.Stat(srcFileName)
                if err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("temp file exist:%s,please retry", srcFileName)
                }</span>

                // prepare a local file
                <span class="cov0" title="0">var textBuffer bytes.Buffer
                for i := 0; i &lt; 10240; i++ </span><span class="cov0" title="0">{
                        textBuffer.WriteString("testossprobe")
                }</span>

                <span class="cov0" title="0">err = ioutil.WriteFile(srcFileName, textBuffer.Bytes(), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("prepare temp file error,%s", err.Error())
                }</span>
                <span class="cov0" title="0">bDeleteLocalFile = true
                fileSize = int64(textBuffer.Len())</span>
        } else<span class="cov0" title="0"> {
                fStat, err := os.Stat(srcFileName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s not exist,stat error:%s", srcFileName, err.Error())
                }</span>

                <span class="cov0" title="0">if fStat.IsDir() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s is dir,not file", srcFileName)
                }</span>

                <span class="cov0" title="0">fileSize = fStat.Size()</span>
        }

        <span class="cov0" title="0">var bDeleteObject = false
        if objectName == "" </span><span class="cov0" title="0">{
                uniqKey := strconv.FormatInt(time.Now().UnixNano(), 10) + "-" + randStr(10)
                objectName = objectPrefex + uniqKey
                bDeleteObject = true
        }</span> else<span class="cov0" title="0"> {
                pc.pbOption.ulObject = objectName
        }</span>

        // judge object is exist or not
        <span class="cov0" title="0">bucket, err := pc.command.ossBucket(pc.pbOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUpload ossBucket error:%s", err.Error())
        }</span>

        <span class="cov0" title="0">isExist, err := bucket.IsObjectExist(objectName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUpload IsObjectExist error:%s", err.Error())
        }</span>

        <span class="cov0" title="0">if isExist </span><span class="cov0" title="0">{
                if bDeleteObject </span><span class="cov0" title="0">{
                        return fmt.Errorf("oss temp object %s exist,please try again", objectName)
                }</span> else<span class="cov0" title="0"> {
                        bConitnue := confirm(objectName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("begin parse parameters and prepare file...[√]\n")

        fmt.Printf("begin network detection...")
        pc.ossNetDetection(pingPath)
        fmt.Printf("\rbegin network detection...[√]\n")
        fmt.Printf("begin upload file(%s)...", upMode)

        // begin upload
        startT := time.Now()
        if upMode == appendMode </span><span class="cov0" title="0">{
                err = pc.probeUploadFileAppend(srcFileName, objectName)
        }</span> else<span class="cov0" title="0"> if upMode == multipartMode </span><span class="cov0" title="0">{
                err = pc.probeUploadFileMultiPart(srcFileName, objectName)
        }</span> else<span class="cov0" title="0"> {
                err = pc.probeUploadFileNormal(srcFileName, objectName)
        }</span>
        <span class="cov0" title="0">endT := time.Now()

        var logBuff bytes.Buffer
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf("\rbegin upload file(%s)...[√]\n", upMode)

                logBuff.WriteString("\n*************************  upload result  *************************\n")
                logBuff.WriteString("upload file:success\n")
                logBuff.WriteString(fmt.Sprintf("upload file size:%d(byte)\n", fileSize))
                logBuff.WriteString(fmt.Sprintf("upload time consuming:%d(ms)\n", endT.UnixNano()/1000/1000-startT.UnixNano()/1000/1000))
                logBuff.WriteString("(only the time consumed by probe command)\n\n")

                if pc.pbOption.ulObject != "" </span><span class="cov0" title="0">{
                        logBuff.WriteString(fmt.Sprintf("upload object is %s\n", pc.pbOption.ulObject))
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("\rbegin upload file(%s)...[x]\n\n", upMode)

                logBuff.WriteString("\n*************************  upload result  *************************\n")
                logBuff.WriteString("upload file:failure\n")

                logBuff.WriteString("\n*************************  error message  *************************\n")
                logBuff.WriteString(fmt.Sprintf("%s\n", err.Error()))
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s", logBuff.String())
        pc.pbOption.logFile.WriteString(logBuff.String())

        fmt.Printf("\n************************* report log info*************************\n")
        fmt.Printf("report log file:%s\n\n", pc.pbOption.logName)

        // delete oss temp object
        if bDeleteObject </span><span class="cov0" title="0">{
                pc.deleteObject(objectName)
        }</span>

        // delete local file
        <span class="cov0" title="0">if bDeleteLocalFile </span><span class="cov0" title="0">{
                os.Remove(srcFileName)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (pc *ProbeCommand) probeUploadFileAppend(absFileName string, objectName string) error <span class="cov0" title="0">{
        bucket, err := pc.command.ossBucket(pc.pbOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUploadFileAppend error:%s", err.Error())
        }</span>

        <span class="cov0" title="0">var nextPos int64 = 0
        fd, err := os.Open(absFileName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUploadFileAppend,open %s error:%s", absFileName, err.Error())
        }</span>
        <span class="cov0" title="0">defer fd.Close()
        nextPos, err = bucket.AppendObject(objectName, fd, nextPos)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUploadFileAppend error:%s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (pc *ProbeCommand) probeUploadFileMultiPart(absFileName string, objectName string) error <span class="cov0" title="0">{
        bucket, err := pc.command.ossBucket(pc.pbOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUploadFileMultiPart error:%s", err.Error())
        }</span>

        <span class="cov0" title="0">err = bucket.UploadFile(objectName, absFileName, 100*1024, oss.Routines(5), oss.Checkpoint(true, ""))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("probeUploadFileMultiPart error:%s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (pc *ProbeCommand) probeUploadFileNormal(absFileName string, objectName string) error <span class="cov0" title="0">{
        bucket, err := pc.command.ossBucket(pc.pbOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = bucket.PutObjectFromFile(objectName, absFileName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("PutObjectFromFile error:%s", err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package lib

import (
        "fmt"
        "net/http"
        "sort"
        "strings"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseReadSymlink = SpecText{

        synopsisText: "读取符号链接文件的描述信息",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil read-symlink oss://bucket/object [--encoding-type url] [--version-id versionId] [--payer requester] [-c file] 
`,

        detailHelpText: ` 
    该命令获取指定符号链接object的描述信息，此操作要求用户对该符号链接有读权限。
    如果需要读取符合链接object的文件内容，请使用cp命令下载该object。
    
    返回的项中X-Oss-Symlink-Target表示符号链接的目标文件。

    如果object并非符号链接文件，该操作返回错误：NotSymlink。

    更多信息见官网API文档：https://help.aliyun.com/document_detail/45146.html?spm=5176.doc31968.6.871.24y1VX

用法：

    ossutil read-symlink oss://bucket/symlink-object [--version-id versionId] [--payer requester]
`,

        sampleText: ` 
    ossutil read-symlink oss://bucket1/object1 
        Etag                    : 455E20DBFFF1D588B67D092C46B16DB6
        Last-Modified           : 2017-04-17 14:49:42 +0800 CST
        X-Oss-Symlink-Target    : a
    
    ossutil read-symlink oss://bucket1/object --version-id versionId

    ossutil read-symlink oss://bucket1/object --payer requester
`,
}

var specEnglishReadSymlink = SpecText{

        synopsisText: "Display meta information of symlink object",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil read-symlink oss://bucket/object [--encoding-type url] [--payer requester] [-c file]
`,

        detailHelpText: ` 
    The command display the meta information of symlink object. The operation 
    requires that the user have read permission of the symlink object. If you 
    want to get the file data of symlink object, please use cp command to download 
    the symlink object. 

    The item X-Oss-Symlink-Target shows the target object of the symlink object.

    If the object is not symlink object, ossutil return error: NotSymlink.

    More information about symlink see: https://help.aliyun.com/document_detail/45146.html?spm=5176.doc31968.6.871.24y1VX 

Usage:

    ossutil read-symlink oss://bucket/symlink-object [--version-id versionId] [--payer requester]
`,

        sampleText: ` 
    ossutil read-symlink oss://bucket1/object1 
        Etag                    : 455E20DBFFF1D588B67D092C46B16DB6
        Last-Modified           : 2017-04-17 14:49:42 +0800 CST
        X-Oss-Symlink-Target    : a
    
    ossutil read-symlink oss://bucket1/object --version-id versionId

    ossutil read-symlink oss://bucket1/object --payer requester
`,
}

// ReadSymlinkCommand is the command list buckets or objects
type ReadSymlinkCommand struct {
        command       Command
        commonOptions []oss.Option
}

var readSymlinkCommand = ReadSymlinkCommand{
        command: Command{
                name:        "read-symlink",
                nameAlias:   []string{},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseReadSymlink,
                specEnglish: specEnglishReadSymlink,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionEncodingType,
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionLogLevel,
                        OptionVersionId,
                        OptionRequestPayer,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (rc *ReadSymlinkCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return rc.command.formatHelpForWhole()
}</span>

func (rc *ReadSymlinkCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return rc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (rc *ReadSymlinkCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return rc.command.Init(args, options, rc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (rc *ReadSymlinkCommand) RunCommand() error <span class="cov0" title="0">{
        encodingType, _ := GetString(OptionEncodingType, rc.command.options)
        cloudURL, err := ObjectURLFromString(rc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">versionId, _ := GetString(OptionVersionId, rc.command.options)
        symlinkOptions := []oss.Option{}
        if len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                symlinkOptions = append(symlinkOptions, oss.VersionId(versionId))
        }</span>

        <span class="cov0" title="0">payer, _ := GetString(OptionRequestPayer, rc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">rc.commonOptions = append(rc.commonOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        <span class="cov0" title="0">symlinkOptions = append(symlinkOptions, rc.commonOptions...)
        bucket, err := rc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return rc.linkStat(bucket, cloudURL, symlinkOptions...)</span>
}

func (rc *ReadSymlinkCommand) linkStat(bucket *oss.Bucket, cloudURL CloudURL, options ...oss.Option) error <span class="cov0" title="0">{
        // normal info
        props, err := rc.ossGetSymlinkRetry(bucket, cloudURL.object, options...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sortNames := []string{}
        attrMap := map[string]string{}
        for name := range props </span><span class="cov0" title="0">{
                ln := strings.ToLower(name)
                if ln != strings.ToLower(oss.HTTPHeaderDate) &amp;&amp;
                        ln != strings.ToLower(oss.HTTPHeaderOssRequestID) &amp;&amp;
                        ln != strings.ToLower(oss.HTTPHeaderServer) &amp;&amp;
                        ln != strings.ToLower(oss.HTTPHeaderContentLength) &amp;&amp;
                        ln != "x-oss-server-time" &amp;&amp;
                        ln != "connection" </span><span class="cov0" title="0">{
                        sortNames = append(sortNames, name)
                        attrMap[name] = props.Get(name)
                }</span>
        }

        <span class="cov0" title="0">if lm, err := time.Parse(http.TimeFormat, attrMap[StatLastModified]); err == nil </span><span class="cov0" title="0">{
                attrMap[StatLastModified] = fmt.Sprintf("%s", utcToLocalTime(lm.UTC()))
        }</span>

        <span class="cov0" title="0">sort.Strings(sortNames)

        for _, name := range sortNames </span><span class="cov0" title="0">{
                if strings.ToLower(name) != "etag" </span><span class="cov0" title="0">{
                        fmt.Printf("%-24s: %s\n", name, attrMap[name])
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%-24s: %s\n", name, strings.Trim(attrMap[name], "\""))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (rc *ReadSymlinkCommand) ossGetSymlinkRetry(bucket *oss.Bucket, symlinkObject string, options ...oss.Option) (http.Header, error) <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                props, err := bucket.GetSymlink(symlinkObject, options...)
                if err == nil </span><span class="cov0" title="0">{
                        return props, err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return props, ObjectError{err, bucket.BucketName, symlinkObject}
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package lib

import (
        "fmt"
        "log"
        "os"
        "time"
)

type Reporter struct {
        rlogger    *log.Logger
        written    bool
        prompted   bool
        path       string
        comment    string
        outputDir  string
        createDir  bool
        fileHandle *os.File
}

func (re *Reporter) Init(outputDir, comment string) error <span class="cov0" title="0">{
        if outputDir == "" </span><span class="cov0" title="0">{
                outputDir = DefaultOutputDir
        }</span>
        <span class="cov0" title="0">re.outputDir = outputDir
        re.createDir = false
        if _, err := os.Stat(outputDir); err != nil &amp;&amp; os.IsNotExist(err) </span><span class="cov0" title="0">{
                re.createDir = true
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">re.path = re.outputDir + string(os.PathSeparator) + ReportPrefix + time.Now().Format("20060102_150405") + ReportSuffix
        re.comment = comment
        re.written = false
        re.prompted = false
        f, err := os.OpenFile(re.path, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0664)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Create reporter file error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">re.fileHandle = f
        re.rlogger = log.New(f, "", log.Ldate|log.Ltime)
        re.Comment()
        re.rlogger.SetFlags(log.Ldate | log.Ltime)
        return nil</span>
}

func (re *Reporter) Clear() <span class="cov10" title="24">{
        if re != nil &amp;&amp; re.fileHandle != nil </span><span class="cov0" title="0">{
                re.fileHandle.Close()
        }</span>

        <span class="cov10" title="24">if re != nil &amp;&amp; !re.written </span><span class="cov0" title="0">{
                os.Remove(re.path)
                if re.createDir </span><span class="cov0" title="0">{
                        os.RemoveAll(re.outputDir)
                }</span>
        }
}

func (re *Reporter) HasPrompt() bool <span class="cov0" title="0">{
        if re == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return re.prompted == false</span>
}

func (re *Reporter) Comment() <span class="cov0" title="0">{
        if re != nil &amp;&amp; !re.written </span><span class="cov0" title="0">{
                re.rlogger.SetFlags(0)
                re.rlogger.SetPrefix("# ")
                re.rlogger.Println(re.comment)
        }</span>
}

func (re *Reporter) ReportError(msg string) <span class="cov0" title="0">{
        if re != nil &amp;&amp; re.rlogger != nil </span><span class="cov0" title="0">{
                re.written = true
                re.rlogger.SetPrefix("[Error] ")
                re.rlogger.Println(msg)
        }</span>
}

func (re *Reporter) Prompt(err error) <span class="cov0" title="0">{
        if re != nil &amp;&amp; re.written &amp;&amp; re.HasPrompt() </span><span class="cov0" title="0">{
                re.prompted = true
                fmt.Printf("\r%s\rError occurs, message: %s. See more information in file: %s\n", clearStr, err.Error(), re.path)
        }</span>
}

func GetReporter(need bool, outputDir, comment string) (*Reporter, error) <span class="cov10" title="24">{
        if need </span><span class="cov0" title="0">{
                var reporter Reporter
                if err := reporter.Init(outputDir, comment); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;reporter, nil</span>
        }
        <span class="cov10" title="24">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package lib

import (
        "fmt"
        "strings"

        "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseRequestPayment = SpecText{
        synopsisText: "设置、查询bucket的访问者付费配置",

        paramText: "bucket_url [payment_parameter] [options]",

        syntaxText: ` 
    ossutil request-payment --method put oss://bucket payment_parameter
    ossutil request-payment --method get oss://bucket 
`,
        detailHelpText: ` 
    request-payment命令通过设置method选项值为put、get, 可以设置、查询bucket的访问者付费配置
    选项--method为put时,参数只能为Requester, BucketOwner

用法:
    该命令有三种用法:
        
    1) ossutil request-payment --method put oss://bucket Requester
        这个命令设置由bucket的访问者付费
        
    2) ossutil request-payment --method put oss://bucket BucketOwner
        这个命令设置由bucket的拥有者付费
        
    3) ossutil request-payment --method get oss://bucket
        这个命令查询bucket的付费配置
`,
        sampleText: ` 
    1) 设置由bucket的访问者付费
       ossutil request-payment --method put oss://bucket Requester
    
    2) 设置由bucket的拥有者付费
       ossutil request-payment --method put oss://bucket BucketOwner
        
    3) 查询bucket的付费配置
       ossutil request-payment --method get oss://bucket
`,
}

var specEnglishRequestPayment = SpecText{
        synopsisText: "Set, get bucket request payment configuration",

        paramText: "bucket_url [payment_parameter] [options]",

        syntaxText: ` 
    ossutil request-payment --method put oss://bucket payment_parameter
    ossutil request-payment --method get oss://bucket 
`,
        detailHelpText: ` 
    request-payment command can set, get the bucket request payment configuration by set method option value to put, get
    If the --method option value is put, the parameter can only be Requester, BucketOwner
Usage:
    There are three usages for this command:
        
    1) ossutil request-payment --method put oss://bucket Requester
    This command sets that request is paid by the requester of the bucket

    2) ossutil request-payment --method put oss://bucket BucketOwner
    This command sets that request is paid by the owner of the bucket

    3) ossutil request-payment --method get oss://bucket
    This command query the bucket request payment configuration
`,
        sampleText: ` 
    1) setting request is paid by the requester of the bucket
       ossutil request-payment --method put oss://bucket Requester
    
    2) setting request is paid by the owner of the bucket
       ossutil request-payment --method put oss://bucket BucketOwner
        
    3) query the bucket request payment configuration 
       ossutil request-payment --method get oss://bucket
`,
}

type RequestPaymentCommand struct {
        command       Command
        bucketName    string
        paymentResult oss.RequestPaymentConfiguration
}

var requestPaymentCommand = RequestPaymentCommand{
        command: Command{
                name:        "request-payment",
                nameAlias:   []string{"request-payment"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseRequestPayment,
                specEnglish: specEnglishRequestPayment,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionMethod,
                        OptionLogLevel,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (reqpc *RequestPaymentCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return reqpc.command.formatHelpForWhole()
}</span>

func (reqpc *RequestPaymentCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return reqpc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (reqpc *RequestPaymentCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return reqpc.command.Init(args, options, reqpc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (reqpc *RequestPaymentCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, reqpc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "put" &amp;&amp; strMethod != "get" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is not in the optional value:put|get")
        }</span>

        <span class="cov0" title="0">srcBucketUrL, err := GetCloudUrl(reqpc.command.args[0], "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">reqpc.bucketName = srcBucketUrL.bucket

        if strMethod == "put" </span><span class="cov0" title="0">{
                err = reqpc.PutRequestPayment()
        }</span> else<span class="cov0" title="0"> if strMethod == "get" </span><span class="cov0" title="0">{
                err = reqpc.GetRequestPayment()
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (reqpc *RequestPaymentCommand) PutRequestPayment() error <span class="cov0" title="0">{
        if len(reqpc.command.args) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter,payment parameter is empty")
        }</span>

        <span class="cov0" title="0">strPayment := strings.ToLower(reqpc.command.args[1])

        if strPayment != strings.ToLower(string(oss.Requester)) &amp;&amp;
                strPayment != strings.ToLower(string(oss.BucketOwner)) </span><span class="cov0" title="0">{
                return fmt.Errorf("payment parameter must be %s or %s", string(oss.Requester), string(oss.BucketOwner))
        }</span>

        // put bucket payment
        <span class="cov0" title="0">client, err := reqpc.command.ossClient(reqpc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var paymentConfig oss.RequestPaymentConfiguration
        if strPayment == strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                paymentConfig.Payer = string(oss.Requester)
        }</span> else<span class="cov0" title="0"> if strPayment == strings.ToLower(string(oss.BucketOwner)) </span><span class="cov0" title="0">{
                paymentConfig.Payer = string(oss.BucketOwner)

        }</span>
        <span class="cov0" title="0">return client.SetBucketRequestPayment(reqpc.bucketName, paymentConfig)</span>
}

func (reqpc *RequestPaymentCommand) GetRequestPayment() error <span class="cov0" title="0">{
        client, err := reqpc.command.ossClient(reqpc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">reqpc.paymentResult, err = client.GetBucketRequestPayment(reqpc.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n%s\n", string(reqpc.paymentResult.Payer))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package lib

import (
        "fmt"
        "io/ioutil"
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

type batchOptionType struct {
        ctnu     bool
        reporter *Reporter
}

var specChineseRestore = SpecText{

        synopsisText: "恢复冷冻状态的Objects为可读状态",

        paramText: "cloud_url [local_xml_file] [options]",

        syntaxText: ` 
    ossutil restore cloud_url [local_xml_file] [--encoding-type url] [-r] [-f] [--output-dir=odir] [--version-id versionId] [--payer requester] [-c file]
`,

        detailHelpText: ` 
    该命令恢复处于冷冻状态的object进入可读状态，即操作对象object的存储类型为StorageArchive、StorageColdArchive

    一个Archive、StorageColdArchive类型的object初始时处于冷冻状态。

    针对处于冷冻状态的object调用restore命令，返回成功。object处于解冻中，服务端执行解
    冻，在此期间再次调用restore命令，同样成功，且不会延长object可读状态持续时间。

    待服务端执行完成解冻任务后，object就进入了解冻状态，此时用户可以读取object。

    解冻状态默认持续1天，对于解冻状态的object调用restore命令，会将object的解冻状态延长
    一天，最多可以延长到7天，之后object又回到初始时的冷冻状态。

    更多信息见官网文档：https://help.aliyun.com/document_detail/52930.html?spm=5176.doc31947.6.874.8GjVvu 


用法：

    该命令有两种用法：

    1) ossutil restore oss://bucket/object [--encoding-type url] [local_xml_file] 
        该用法恢复单个冷冻状态object为可读状态，当指定object不存在时，ossutil会提示错
    误，此时请确保指定的url精确匹配需要设置acl的object，并且不要指定--recursive选项（
    否则ossutil会进行前缀匹配，恢复多个冷冻状态的objects为可读状态）。无论--force选项
    是否指定，都不会进行询问提示。

    2) ossutil restore oss://bucket[/prefix] -r [--encoding-type url] [-f] [--output-dir=odir] [local_xml_file]
        该用法可批量恢复多个冷冻状态的objects为可读状态，此时必须输入--recursive选项，
    ossutil会查找所有前缀匹配url的objects，恢复它们为可读状态。当一个object操作出现错
    误时，会将出错object的错误信息记录到report文件，并继续操作其他object，成功操作的
    object信息将不会被记录到report文件中（更多信息见cp命令的帮助）。如果--force选项被
    指定，则不会进行询问提示。

    上面的local_xml_file是本地xml格式文件, 支持设置更多的restore参数, 举例如下
    &lt;RestoreRequest&gt;
        &lt;Days&gt;2&lt;/Days&gt;
        &lt;JobParameters&gt;
            &lt;Tier&gt;Bulk&lt;/Tier&gt;
        &lt;/JobParameters&gt;
    &lt;/RestoreRequest&gt;
`,

        sampleText: ` 
    1) ossutil restore oss://bucket-restore/object-store
    2) ossutil restore oss://bucket-restore/object-prefix -r
    3) ossutil restore oss://bucket-restore/object-prefix -r -f
    4) ossutil restore oss://bucket-restore/%e4%b8%ad%e6%96%87 --encoding-type url
    5) ossutil restore oss://bucket-restore/object-store --payer requester
    6) ossutil restore oss://bucket-restore/object-prefix -r -f local_xml_file
`,
}

var specEnglishRestore = SpecText{

        synopsisText: "Restore Frozen State Object to Read Ready Status",

        paramText: "cloud_url [local_xml_file] [options]",

        syntaxText: ` 
    ossutil restore cloud_url [local_xml_file] [--encoding-type url] [-r] [-f] [--output-dir=odir] [--version-id versionId] [--payer requester] [-c file]
`,

        detailHelpText: ` 
    The command restore frozen state object to read ready status, the object must be in the storage 
    class of StorageArchive、StorageColdArchive

    An object of Archive storage class will be in frozen state at first.

    If user restore a frozen state object, the operation will success, and the object will be in 
    restroing status, oss will thaw the object. In this period, if user restore the object again, 
    the operation will success, but the time that the object can be downloaded will not be extended.

    When oss has finished restoring the object, the object can be downloaded.

    The time that an restored object can be downloaded is one day in default, if user restore the 
    object again during the time, the time that the object can be downloaded will be extended for 
    one day, the time can be at most extended to seven days. 

    More information about restore see: https://help.aliyun.com/document_detail/52930.html?spm=5176.doc31947.6.874.8GjVvu  


Usage:

    There are two usages:

    1) ossutil restore oss://bucket/object [--encoding-type url] [local_xml_file]
        If --recursive option is not specified, ossutil restore the specified frozen state object 
    to readable status. In the usage, please make sure url exactly specified the object you want to 
    restore, if object not exist, error occurs. No matter --force option is specified or not, ossutil 
    will not show prompt question. 

    2) ossutil restore oss://bucket[/prefix] -r [--encoding-type url] [-f] [--output-dir=odir] [local_xml_file]
        The usage restore the objects with the specified prefix and in frozen state to readable status. 
    --recursive option is required for the usage, and ossutil will search for prefix-matching objects 
    and restore those objects. When an error occurs when restore an object, ossutil will record the 
    error message to report file, and ossutil will continue to attempt to set acl on the remaining 
    objects(more information see help of cp command). If --force option is specified, ossutil will 
    not show prompt question. 

    The local_xml_file is a local XML format file, which supports setting more restore configurations. For example:
    &lt;RestoreRequest&gt;
        &lt;Days&gt;2&lt;/Days&gt;
        &lt;JobParameters&gt;
            &lt;Tier&gt;Bulk&lt;/Tier&gt;
        &lt;/JobParameters&gt;
    &lt;/RestoreRequest&gt;
`,

        sampleText: ` 
    1) ossutil restore oss://bucket-restore/object-store
    2) ossutil restore oss://bucket-restore/object-prefix -r
    3) ossutil restore oss://bucket-restore/object-prefix -r -f
    4) ossutil restore oss://bucket-restore/%e4%b8%ad%e6%96%87 --encoding-type url
    5) ossutil restore oss://bucket-restore/object-store --payer requester
    6) ossutil restore oss://bucket-restore/object-prefix -r -f local_xml_file
`,
}

// RestoreCommand is the command list buckets or objects
type RestoreCommand struct {
        monitor       Monitor //Put first for atomic op on some fileds
        command       Command
        reOption      batchOptionType
        commonOptions []oss.Option
        restoreConfig oss.RestoreConfiguration
        hasConfig     bool
        configXml     string
}

var restoreCommand = RestoreCommand{
        command: Command{
                name:        "restore",
                nameAlias:   []string{},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseRestore,
                specEnglish: specEnglishRestore,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionRecursion,
                        OptionForce,
                        OptionEncodingType,
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionRoutines,
                        OptionOutputDir,
                        OptionLogLevel,
                        OptionVersionId,
                        OptionRequestPayer,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (rc *RestoreCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return rc.command.formatHelpForWhole()
}</span>

func (rc *RestoreCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return rc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (rc *RestoreCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return rc.command.Init(args, options, rc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (rc *RestoreCommand) RunCommand() error <span class="cov0" title="0">{
        rc.monitor.init("Restored")

        encodingType, _ := GetString(OptionEncodingType, rc.command.options)
        recursive, _ := GetBool(OptionRecursion, rc.command.options)
        versionid, _ := GetString(OptionVersionId, rc.command.options)

        payer, _ := GetString(OptionRequestPayer, rc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">rc.commonOptions = append(rc.commonOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        <span class="cov0" title="0">cloudURL, err := CloudURLFromString(rc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = rc.checkArgs(cloudURL, recursive, versionid); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(rc.command.args) == 2 </span><span class="cov0" title="0">{
                xmlFile := rc.command.args[1]
                fileInfo, err := os.Stat(xmlFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s is dir,not the expected file", xmlFile)
                }</span>

                <span class="cov0" title="0">if fileInfo.Size() == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s is empty file", xmlFile)
                }</span>

                // parsing the xml file
                <span class="cov0" title="0">file, err := os.Open(xmlFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer file.Close()
                text, err := ioutil.ReadAll(file)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">rc.hasConfig = true
                rc.configXml = string(text)</span>
        }

        <span class="cov0" title="0">bucket, err := rc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !recursive </span><span class="cov0" title="0">{
                return rc.ossRestoreObject(bucket, cloudURL.object, versionid)
        }</span>
        <span class="cov0" title="0">return rc.batchRestoreObjects(bucket, cloudURL)</span>
}

func (rc *RestoreCommand) checkArgs(cloudURL CloudURL, recursive bool, versionid string) error <span class="cov0" title="0">{
        if cloudURL.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", rc.command.args[0])
        }</span>
        <span class="cov0" title="0">if !recursive &amp;&amp; cloudURL.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("restore object invalid cloud url: %s, object empty. Restore bucket is not supported, if you mean batch restore objects, please use --recursive", rc.command.args[0])
        }</span>
        <span class="cov0" title="0">if recursive &amp;&amp; len(versionid) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("restore bucket dose not support the --version-id=%s argument.", versionid)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (rc *RestoreCommand) ossRestoreObject(bucket *oss.Bucket, object string, versionid string) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                var options []oss.Option
                if len(versionid) &gt; 0 </span><span class="cov0" title="0">{
                        options = append(options, oss.VersionId(versionid))
                }</span>
                <span class="cov0" title="0">options = append(options, rc.commonOptions...)

                var err error
                if rc.hasConfig </span><span class="cov0" title="0">{
                        err = bucket.RestoreObjectXML(object, rc.configXml, options...)
                }</span> else<span class="cov0" title="0"> {
                        err = bucket.RestoreObject(object, options...)
                }</span>

                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">switch err.(type) </span>{
                case oss.ServiceError:<span class="cov0" title="0">
                        if err.(oss.ServiceError).StatusCode == 409 &amp;&amp; err.(oss.ServiceError).Code == "RestoreAlreadyInProgress" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, object}
                }</span>
        }
}

func (rc *RestoreCommand) batchRestoreObjects(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov0" title="0">{
        force, _ := GetBool(OptionForce, rc.command.options)
        if !force </span><span class="cov0" title="0">{
                var val string
                fmt.Printf("Do you really mean to recursivlly restore objects of %s(y or N)? ", rc.command.args[0])
                if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                        fmt.Println("operation is canceled.")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">rc.reOption.ctnu = true
        outputDir, _ := GetString(OptionOutputDir, rc.command.options)

        // init reporter
        var err error
        if rc.reOption.reporter, err = GetReporter(rc.reOption.ctnu, outputDir, commandLine); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rc.reOption.reporter.Clear()

        return rc.restoreObjects(bucket, cloudURL)</span>
}

func (rc *RestoreCommand) restoreObjects(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov0" title="0">{
        routines, _ := GetInt(OptionRoutines, rc.command.options)

        chObjects := make(chan string, ChannelBuf)
        chError := make(chan error, routines+1)
        chListError := make(chan error, 1)
        go rc.command.objectStatistic(bucket, cloudURL, &amp;rc.monitor, []filterOptionType{}, rc.commonOptions...)
        go rc.command.objectProducer(bucket, cloudURL, chObjects, chListError, []filterOptionType{}, rc.commonOptions...)
        for i := 0; int64(i) &lt; routines; i++ </span><span class="cov0" title="0">{
                go rc.restoreConsumer(bucket, cloudURL, chObjects, chError)
        }</span>

        <span class="cov0" title="0">return rc.waitRoutinueComplete(chError, chListError, routines)</span>
}

func (rc *RestoreCommand) restoreConsumer(bucket *oss.Bucket, cloudURL CloudURL, chObjects &lt;-chan string, chError chan&lt;- error) <span class="cov0" title="0">{
        for object := range chObjects </span><span class="cov0" title="0">{
                err := rc.restoreObjectWithReport(bucket, object)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        if !rc.reOption.ctnu </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        <span class="cov0" title="0">chError &lt;- nil</span>
}

func (rc *RestoreCommand) restoreObjectWithReport(bucket *oss.Bucket, object string) error <span class="cov0" title="0">{
        err := rc.ossRestoreObject(bucket, object, "")
        rc.command.updateMonitor(err, &amp;rc.monitor)
        msg := fmt.Sprintf("restore %s", CloudURLToString(bucket.BucketName, object))
        rc.command.report(msg, err, &amp;rc.reOption)
        return err
}</span>

func (rc *RestoreCommand) waitRoutinueComplete(chError, chListError &lt;-chan error, routines int64) error <span class="cov0" title="0">{
        completed := 0
        var ferr error
        for int64(completed) &lt;= routines </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-chListError:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">completed++</span>
                case err := &lt;-chError:<span class="cov0" title="0">
                        if err == nil </span><span class="cov0" title="0">{
                                completed++
                        }</span> else<span class="cov0" title="0"> {
                                ferr = err
                                if !rc.reOption.ctnu </span><span class="cov0" title="0">{
                                        fmt.Printf(rc.monitor.progressBar(true, errExit))
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return rc.formatResultPrompt(ferr)</span>
}

func (rc *RestoreCommand) formatResultPrompt(err error) error <span class="cov0" title="0">{
        fmt.Printf(rc.monitor.progressBar(true, normalExit))
        if err != nil &amp;&amp; rc.reOption.ctnu </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package lib

import (
        "fmt"
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseRevert = SpecText{
        synopsisText: "将object从删除状态恢复成最近的多版本状态",

        paramText: "cloud_url [options]",

        syntaxText: ` 
        ossutil revert-versioning oss://bucket[/prefix] [--encoding-type encodeType] [-r] [--start-time startTime] [--end-time endTime]  [--include include-pattern] [--exclude exclude-pattern] [--payer requester]
`,

        detailHelpText: ` 
    该命令通过删除最新的删除标记,使object从删除状态恢复成最近的多版本状态
    
--recursive选项
    如果输入--recursive或者-r,表示批量操作匹配prefix的所有objects, 否则只操作key为prefix的单个object

--start-time
    时间戳, 既从1970年1月1日(UTC/GMT的午夜)开始所经过的秒数
    如果输入这个选项, object的删除时间小于该时间戳将被忽略

--end-time
    时间戳, 既从1970年1月1日(UTC/GMT的午夜)开始所经过的秒数
    如果输入这个选项, object的删除时间大于该时间戳将被忽略
  
用法：

    该命令只有一种用法：

    1) ossutil revert-versioning oss://bucket[/prefix] [--encoding-type encodeType] [-r] [--start-time startTime] [--end-time endTime]  [--include include-pattern] [--exclude exclude-pattern] [--payer requester]
       恢复bucket下面满足前缀为prefix的object为多版本状态
`,

        sampleText: ` 
        1) 恢复整个bucket的处于删除状态的objects为最近的多版本状态
       ossutil revert-versioning oss://bucket -r
    
    2) 恢复单个处于删除状态的object为最近多版本状态
       ossutil revert-versioning oss://bucket/object
    
    3) 恢复处于删除状态的objects为最近的多版本状态, key的后缀满足输入的过滤条件
       ossutil revert-versioning oss://bucket/prefix -r --include *.jpg --exclude *.txt
    
    4) 恢复处于删除状态的objects为最近的多版本状态, object的最后删除时间必须在输入范围内
       起始时间为北京时间2020/6/16 16:22:58, 结束时间为北京时间2020/6/16 16:39:38
       ossutil revert-versioning oss://bucket/prefix -r --start-time 1592295778 --end-time 1592296778
    
    5) 访问者付费模式
       ossutil revert-versioning oss://bucket/prefix -r --payer requester
`,
}

var specEnglishRevert = SpecText{
        synopsisText: "Revert the deleted object to the latest versioning state",

        paramText: "cloud_url [options]",

        syntaxText: ` 
        ossutil revert-versioning oss://bucket[/prefix] [--encoding-type encodeType] [-r] [--start-time startTime] [--end-time endTime]  [--include include-pattern] [--exclude exclude-pattern] [--payer requester]
`,

        detailHelpText: ` 
        This command revert the object from the deleted state to the latest versioning state by deleting the latest delete mark

Usages：

    There is only one usage for this command:

    1) ossutil revert-versioning oss://bucket[/prefix] [--encoding-type encodeType] [-r] [--start-time startTime] [--end-time endTime]  [--include include-pattern] [--exclude exclude-pattern] [--payer requester]
       Revert the bucket's objects whose prefix are "prefix" to the versioning state
`,

        sampleText: ` 
        1) Revert the bucket's deleted objects to the latest versioning state
       ossutil revert-versioning oss://bucket -r
    
    2) Revert a single deleted object to the latest versioning state
       ossutil revert-versioning oss://bucket/object
    
    3) Revert deleted objects to the latest versioning state, the key suffix meets the input filter conditions
       ossutil revert-versioning oss://bucket/prefix -r --include *.jpg --exclude *.txt
    
    4) Revert deleted objects to the latest versioning state, the last deletion time of objects must be within the input range
       The start time is Beijing time 2020/6/16 16:22:58, and the end time is Beijing time 2020/6/16 16:39:38
       ossutil revert-versioning oss://bucket/prefix -r --start-time 1592295778 --end-time 1592296778
    
    5) Use requester to pay mode
       ossutil revert-versioning oss://bucket/prefix -r --payer requester
`,
}

type revertOptionType struct {
        bucketName  string
        object      string
        startTime   int64
        endTime     int64
        payer       string
        filters     []filterOptionType
        options     []oss.Option
        recursive   bool
        revertCount int64
}

type RevertCommand struct {
        command      Command
        revertOption revertOptionType
}

var revertCommand = RevertCommand{
        command: Command{
                name:        "revert-versioning",
                nameAlias:   []string{"revert-versioning"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseRevert,
                specEnglish: specEnglishRevert,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionRecursion,
                        OptionRequestPayer,
                        OptionStartTime,
                        OptionEndTime,
                        OptionInclude,
                        OptionExclude,
                        OptionEncodingType,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (revert *RevertCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return revert.command.formatHelpForWhole()
}</span>

func (revert *RevertCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return revert.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (revert *RevertCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return revert.command.Init(args, options, revert)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (revert *RevertCommand) RunCommand() error <span class="cov0" title="0">{
        encodingType, _ := GetString(OptionEncodingType, revert.command.options)
        srcBucketUrL, err := GetCloudUrl(revert.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">revert.revertOption.bucketName = srcBucketUrL.bucket
        revert.revertOption.object = srcBucketUrL.object
        revert.revertOption.recursive, _ = GetBool(OptionRecursion, revert.command.options)
        if !revert.revertOption.recursive &amp;&amp; revert.revertOption.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("please input object key when option recursive is false")
        }</span>

        <span class="cov0" title="0">revert.revertOption.startTime, _ = GetInt(OptionStartTime, revert.command.options)
        revert.revertOption.endTime, _ = GetInt(OptionEndTime, revert.command.options)
        if revert.revertOption.endTime &gt; 0 &amp;&amp; revert.revertOption.startTime &gt; revert.revertOption.endTime </span><span class="cov0" title="0">{
                return fmt.Errorf("start time %d is larger than end time %d", revert.revertOption.startTime, revert.revertOption.endTime)
        }</span>

        <span class="cov0" title="0">revert.revertOption.payer, _ = GetString(OptionRequestPayer, revert.command.options)
        if revert.revertOption.payer != "" </span><span class="cov0" title="0">{
                if strings.ToLower(revert.revertOption.payer) != strings.ToLower(string(oss.Requester)) &amp;&amp;
                        strings.ToLower(revert.revertOption.payer) != strings.ToLower(string(oss.BucketOwner)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("option payer value must be %s or %s",
                                strings.ToLower(string(oss.Requester)), strings.ToLower(string(oss.BucketOwner)))
                }</span>
                <span class="cov0" title="0">revert.revertOption.options = append(revert.revertOption.options, oss.RequestPayer(oss.PayerType(revert.revertOption.payer)))</span>
        }

        <span class="cov0" title="0">var res bool
        res, revert.revertOption.filters = getFilter(os.Args)
        if !res </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude does not support format containing dir info")
        }</span>

        <span class="cov0" title="0">bucket, err := revert.command.ossBucket(revert.revertOption.bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return revert.revertObjects(bucket)</span>
}

func (revert *RevertCommand) revertObjects(bucket *oss.Bucket) error <span class="cov0" title="0">{
        pre := oss.Prefix(revert.revertOption.object)
        keyMarker := oss.KeyMarker("")
        versionIdMarker := oss.VersionIdMarker("")
        listOptions := []oss.Option{pre, keyMarker, versionIdMarker, oss.MaxKeys(1000)}
        if revert.revertOption.payer != "" </span><span class="cov0" title="0">{
                listOptions = append(listOptions, oss.RequestPayer(oss.PayerType(revert.revertOption.payer)))
        }</span>

        <span class="cov0" title="0">bStopped := false
        batchCount := 0
        for </span><span class="cov0" title="0">{
                if bStopped </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">batchCount++
                lor, err := bucket.ListObjectVersions(listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">var objectVersions []oss.DeleteObject
                for _, deleteMarker := range lor.ObjectDeleteMarkers </span><span class="cov0" title="0">{
                        if !revert.revertOption.recursive &amp;&amp; deleteMarker.Key != revert.revertOption.object </span><span class="cov0" title="0">{
                                bStopped = true
                                break</span>
                        }

                        <span class="cov0" title="0">if deleteMarker.IsLatest &amp;&amp; revert.filterDeleteMarker(&amp;deleteMarker) </span><span class="cov0" title="0">{
                                objectVersions = append(objectVersions, oss.DeleteObject{
                                        Key:       deleteMarker.Key,
                                        VersionId: deleteMarker.VersionId,
                                })
                        }</span>
                }

                <span class="cov0" title="0">if len(objectVersions) &gt; 0 </span><span class="cov0" title="0">{
                        deleteOptions := append(revert.revertOption.options, oss.DeleteObjectsQuiet(true))
                        delRes, err := bucket.DeleteObjectVersions(objectVersions, deleteOptions...)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if len(delRes.DeletedObjectsDetail) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\n")
                                for _, object := range delRes.DeletedObjectsDetail </span><span class="cov0" title="0">{
                                        fmt.Printf("delete deleteMarker failure, key:%s,version:%s\n", object.Key, object.VersionId)
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("delete deleteMarker failure")</span>
                        }
                        <span class="cov0" title="0">revert.revertOption.revertCount += int64(len(objectVersions))
                        for _, object := range objectVersions </span><span class="cov0" title="0">{
                                LogInfo("revert %s %s\n", object.Key, object.VersionId)
                        }</span>
                }
                <span class="cov0" title="0">keyMarker = oss.KeyMarker(lor.NextKeyMarker)
                versionIdMarker := oss.VersionIdMarker(lor.NextVersionIdMarker)
                listOptions = []oss.Option{pre, keyMarker, versionIdMarker, oss.MaxKeys(1000)}
                if revert.revertOption.payer != "" </span><span class="cov0" title="0">{
                        listOptions = append(listOptions, oss.RequestPayer(oss.PayerType(revert.revertOption.payer)))
                }</span>
                <span class="cov0" title="0">fmt.Printf("\rrevert versioning object count is %d, batch list count is %d", revert.revertOption.revertCount, batchCount)
                if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">fmt.Printf("\n")
        return nil</span>
}

func (revert *RevertCommand) filterDeleteMarker(deleteMarker *oss.ObjectDeleteMarkerProperties) bool <span class="cov0" title="0">{
        if !doesSingleObjectMatchPatterns(deleteMarker.Key, revert.revertOption.filters) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if (revert.revertOption.startTime &gt; 0 &amp;&amp; deleteMarker.LastModified.Unix() &lt; revert.revertOption.startTime) ||
                (revert.revertOption.endTime &gt; 0 &amp;&amp; deleteMarker.LastModified.Unix() &gt; revert.revertOption.endTime) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package lib

import (
        "fmt"
        "os"
        "strings"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

type uploadIdInfoType struct {
        key      string
        uploadId string
}

type removeOptionType struct {
        recursive bool
        force     bool
        typeSet   int64

        //version
        versionId   string
        allVersions bool
}

var specChineseRemove = SpecText{

        synopsisText: "删除Bucket或Objects",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil rm oss://bucket[/prefix] [-r] [-b] [-m] [-a] [-f]  [--include include-pattern] [--exclude exclude-pattern]  [--version-id versionId | --all-versions] [--payer requester] [-c file]
`,

        detailHelpText: ` 
    该命令删除Bucket或objects，在某些情况下可一并删除二者。请小心使用该命令！！
    在删除objects前确定objects可以删除，在删除bucket前确定整个bucket连同其下的所有
    objects都可以删除！

        （1）删除单个object，参考用法1)
        （2）删除bucket，不删除objects，参考用法2)
        （3）删除objects，不删除bucket，参考用法3)
        （4）删除bucket和objects，参考用法4)

        对bucket进行删除，都需要添加--bucket选项。
        如果指定了--force选项，则删除前不会进行询问提示。
        
        结果：显示命令耗时前未报错，则表示成功删除。

    默认情况下，删除object时，不包括以指定object名称进行的未complete的Multipart Upload
    事件。如果用户需要删除指定object名称下的所有未complete的Multipart Upload事件，需要
    指定--multipart选项（ossutil会删除所有匹配的Multipart Upload事件，但不支持删除特定
    的某个Multipart Upload事件）。

    如果要同时删除object和相应的Multipart Upload事件，需要指定--all-type选项。

    注意：删除未complete的Multipart Upload事件可能造成下次上传相同的UploadId失败，由于
    cp命令使用Multipart来进行断点续传，删除未complete的Multipart Upload事件可能造成cp
    命令断点续传失败（报错：NoSuchUpload），这种时候如果想要重新上传整个文件，请删除
    checkpoint目录中相应的文件。

--include和--exclude选项

    可以指定该选项以指定规则筛选要操作的文件/object

    规则支持以下格式：
    *：匹配索引
    ?：匹配单个字符
    [sequence]：匹配sequence的任意字符
    [!sequence]：匹配不在sequence的任意字符
    注意：规则不支持带目录的格式，e.g.，--include "/usr/*/test/*.jpg"。

    --include和--exclude可以出现多次。当多个规则出现时，这些规则按从左往右的顺序应用


用法：

    该命令有四种用法：

    1) ossutil rm oss://bucket/object [-m] [-a] [--version-id versionId | --all-versions]
        （删除单个object）
        如果未指定--recursive和--bucket选项，删除指定的单个object，此时请确保cloud_url
    精确指定了待删除的object，ossutil不会进行前缀匹配。无论是否指定--force选项，ossutil
    都不会进行询问提示。如果此时指定了--bucket选项，将会报错，单独删除bucket参考用法4)。
        如果指定了--multipart选项, 删除指定object下未complete的Multipart Upload事件。
        如果指定了--all-type选项, 删除指定object以及其下未complete的Multipart Upload事件。
        如果指定了--version-id选项, 删除指定版本的object。
        如果指定了--all-versions选项, 删除所有版本的object。

    2) ossutil rm oss://bucket -b [-f]
        （删除bucket，不删除objects）
        如果指定了--bucket选项，未指定--recursive选项，ossutil删除指定的bucket，但并不去
    删除该bucket下的objects。此时请确保cloud_url精确匹配待删除的bucket，并且指定的bucket
    内容为空，否则会报错。如果指定了--force选项，则删除前不会进行询问提示。

    3) ossutil rm oss://bucket[/prefix] -r [-m] [-a] [-f] [--all-versions]
        （删除objects，不删除bucket）
        如果指定了--recursive选项，未指定--bucket选项。则可以进行objects的批量删除。该用
    法查找与指定cloud_url前缀匹配的所有objects（prefix为空代表bucket下的所有objects），删
    除这些objects。由于未指定--bucket选项，则ossutil保留bucket。如果指定了--force选项，则
    删除前不会进行询问提示。
        如果指定了--multipart选项，删除以指定prefix开头的所有object下的未complete的Multipart 
    Upload任务。
        如果指定了--all-type，删除以指定prefix开头的所有object，以及其下的所有未complete
    的Multipart Upload任务。
            如果指定了--all-versions，删除以指定prefix开头的所有版本的所有object。

    4) ossutil rm oss://bucket[/prefix] -r -b [-m] [-a] [-f] [--all-versions]
        （删除bucket和objects）
        如果同时指定了--bucket和--recursive选项，ossutil进行批量删除后会尝试去一并删除
    bucket。当用户想要删除某个bucket连同其中的所有objects时，可采用该操作。如果指定了
    --force选项，则删除前不会进行询问提示。
        如果指定了--multipart选项，删除以指定prefix开头的所有object下的未complete的Multipart
    Upload任务。
        如果指定了--all-type, 删除以指定prefix开头的所有object，以及其下的所有未complete
    的Multipart Upload任务。
            如果指定了--all-versions，删除以指定prefix开头的所有版本的所有object。
    
    不支持的用法：
    1) ossutil rm oss://bucket/object -m -b [-f]
        不能尝试删除一个指定object名称下未complete的Multipart Upload任务后紧接着删除该bucket。
    2) ossutil rm oss://bucket/object -a -b [-f]
        不能尝试删除一个指定的object和其下所有未complete的Multipart Upload任务后紧接着删除该bucket。
`,

        sampleText: ` 
    ossutil rm oss://bucket1/obj1
    ossutil rm oss://bucket1/obj1 -m
    ossutil rm oss://bucket1/obj1 -a
    ossutil rm oss://bucket1/objdir -r 
    ossutil rm oss://bucket1/multidir -m -r 
    ossutil rm oss://bucket1/dir -a -r 
    ossutil rm oss://bucket1 -b
    ossutil rm oss://bucket2 -r -b -f
    ossutil rm oss://bucket2 -a -r -b -f
    ossutil rm oss://bucket2/%e4%b8%ad%e6%96%87 --encoding-type url
    ossutil rm oss://bucket1/objdir -r --include "*.jpg" --include "*.png" --exclude "*.avi" --exclude "*.mp4"
    ossutil rm oss://bucket1/obj1 --version-id versionId
    ossutil rm oss://bucket1/obj1 --all-versions
    ossutil rm oss://bucket1/objdir -r  --all-versions
    ossutil rm oss://bucket1 -r -b --all-versions
    ossutil rm oss://bucket1 -r --payer requester
`,
}

var specEnglishRemove = SpecText{

        synopsisText: "Remove Bucket or Objects",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil rm oss://bucket[/prefix] [-r] [-b] [-m] [-a] [-f]  [--include include-pattern] [--exclude exclude-pattern]  [--version-id versionId | --all-versions] [--payer requester] [-c file]
`,

        detailHelpText: ` 
    The command remove bucket or objects, in some case remove both. Please use the 
    command carefully!! 
    Make sure the objects can be removed before useing the command to remove objects! 
    Make sure the bucket and objects inside can be removed before useing the command 
    to remove bucket!

        (1) Remove single object, see usage 1)
        (2) Remove bucket, don't remove objects inside, see usage 2)
        (3) Batch remove many objects, reserve bucket, see usage 3)
        (4) Remove bucket and objects inside, see usage 4)

        When remove bucket, the --bucket option must be specified.
        If --force option is specified, remove silently without asking user to confirm the 
        operation.  

        Result: if no error displayed before show elasped time, then the target is removed 
        successfully.

    By default, when remove object, ossutil will reserve the uncompleted multipart upload 
    tasks whose object name match the specified cloud_url, if you want to remove those multipart 
    upload tasks, please specify --multipart option. Note: ossutil will remove all the multipart 
    upload tasks of the specified cloud_url, remove a special single multipart upload task 
    is unsupported. 

    If you need to remove object and the multipart upload tasks whose object name match the 
    specified cloud_url meanwhile, please use --all-type option.

    Note: remove the multipart upload tasks uncompleted will cause upload the part fail next 
    time. Because cp command use multipart upload to realize resume upload/download/copy, so 
    remove the multipart upload tasks uncompleted may cause resume upload/download/copy fail 
    the next time(Error: NoSuchUpload). If you want to reupload/download/copy the entire file 
    again, please remove the checkpoint file in checkpoint directory. 

--include and --exclude option:

    These parameters perform pattern matching to either exclude or include a particular file or object

    The following pattern symbols are supported.
    *: Matches everything
    ?: Matches any single character
    [sequence]: Matches any character in sequence
    [!sequence]: Matches any character not in sequence
    Note: does not support patterns containing directory info. e.g., --include "/usr/*/test/*.jpg" 

    Any number of these parameters can be passed to a command. You can do this by providing an --exclude
    or --include argument multiple times, e.g.,
      --include "*.txt" --include "*.png". 
    When there are multi filters, the rule is the filters that appear later in the command take precedence
    over filters that appear earlier in the command


Usage:

    There are four usages:

    1) ossutil rm oss://bucket/object [-m] [-a] [--version-id versionId | --all-versions]
        (Remove single object)
        If you remove without --recursive and --bucket option, ossutil remove the single 
    object specified in cloud_url. In the usage, please make sure cloud_url exactly specified 
    the object you want to remove, ossutil will not treat object as prefix and remove prefix 
    matching objects. No matter --force is specified or not, ossutil will not show prompt 
    question.
        If --multipart option is specified, ossutil will remove the multipart upload tasks 
    of the specified object.
        If --all-type option is specified, ossutil will remove the specified object along 
    with the multipart upload tasks of the specified object. 
        If --version-id is specified, ossutil will remove a specific version of object. 
        If --all-versions option is specified, ossutil will remove all the versions of object. 

    2) ossutil rm oss://bucket -b [-f] 
        (Remove bucket, don't remove objects inside)
        If you remove with --bucket option, without --recursive option, ossutil try to 
    remove the bucket, if the bucket is not empty, error occurs. In the usage, please make 
    sure cloud_url exactly specified the bucket you want to remove, or error occurs. If --force 
    option is specified, ossutil will not show prompt question. 

    3) ossutil rm oss://bucket[/prefix] -r [-m] [-a] [-f] [--all-versions]
        (Remove objects, reserve bucket)
        If you remove with --recursive option, without --bucket option, ossutil remove all 
    the objects that prefix-matching the cloud_url you specified(empty prefix means all 
    objects in the bucket), bucket will be reserved because of missing --bucket option.
        If --multipart option is specified, ossutil will remove the multipart upload tasks 
    whose object name start with the specified prefix.
        If --all-type option is specified, ossutil will remove the objects with the specified 
    prefix along with the multipart upload tasks whose object name start with the specified 
    prefix. 
        If --all-versions option is specified, ossutil will remove all versions of the objects with the specified 
    prefix. 

    4) ossutil rm oss://bucket[/prefix] -r -b [-a] [-f] [--all-versions]
        (Remove bucket and objects inside)
        If you remove with both --recursive and --bucket option, after ossutil removed all 
    the prefix-matching objects, ossutil will try to remove the bucket together. If user want 
    to remove bucket and objects inside, the usage is recommended. If --force option is 
    specified, ossutil will not show prompt question. 
        If --multipart option is specified, ossutil will remove the multipart upload tasks 
    whose object name start with the specified prefix.
        If --all-type option is specified, ossutil will remove the objects with the specified 
    prefix along with the multipart upload tasks whose object name start with the specified 
    prefix. 
            If --all-versions option is specified, ossutil will remove all versions of the objects with the specified 
    prefix. 

        Invalid Usage: 
    1) ossutil rm oss://bucket/object -m -b [-f]
                It's invalid to remove the bucket right after remove uncompleted upload tasks of single 
    object.
    2) ossutil rm oss://bucket/object -a -b [-f]
        It's invalid to remove the bucket right after remove the object and uncompleted upload 
    tasks of the single object you specified.
`,

        sampleText: ` 
    ossutil rm oss://bucket1/obj1
    ossutil rm oss://bucket1/obj1 -m
    ossutil rm oss://bucket1/obj1 -a
    ossutil rm oss://bucket1/objdir -r 
    ossutil rm oss://bucket1/multidir -m -r 
    ossutil rm oss://bucket1/dir -a -r 
    ossutil rm oss://bucket1 -b
    ossutil rm oss://bucket2 -r -b -f
    ossutil rm oss://bucket2 -a -r -b -f
    ossutil rm oss://bucket2/%e4%b8%ad%e6%96%87 --encoding-type url
    ossutil rm oss://bucket1/objdir -r --include "*.jpg" --include "*.png" --exclude "*.avi" --exclude "*.mp4"
    ossutil rm oss://bucket1/obj1 --version-id versionId
    ossutil rm oss://bucket1/obj1 --all-versions
    ossutil rm oss://bucket1/objdir -r  --all-versions
    ossutil rm oss://bucket1 -r -b --all-versions
    ossutil rm oss://bucket1 -r --payer requester
`,
}

// RemoveCommand is the command remove bucket or objects
type RemoveCommand struct {
        monitor       RMMonitor //Put first for atomic op on some fileds
        command       Command
        rmOption      removeOptionType
        commonOptions []oss.Option
        filters       []filterOptionType
}

var removeCommand = RemoveCommand{
        command: Command{
                name:        "rm",
                nameAlias:   []string{"remove", "delete", "del"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseRemove,
                specEnglish: specEnglishRemove,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionLogLevel,
                        OptionRecursion,
                        OptionBucket,
                        OptionForce,
                        OptionMultipart,
                        OptionAllType,
                        OptionEncodingType,
                        OptionInclude,
                        OptionExclude,
                        OptionVersionId,
                        OptionAllversions,
                        OptionRequestPayer,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (rc *RemoveCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return rc.command.formatHelpForWhole()
}</span>

func (rc *RemoveCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return rc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (rc *RemoveCommand) Init(args []string, options OptionMapType) error <span class="cov10" title="28">{
        return rc.command.Init(args, options, rc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (rc *RemoveCommand) RunCommand() error <span class="cov10" title="28">{
        rc.monitor.init()

        encodingType, _ := GetString(OptionEncodingType, rc.command.options)
        cloudURL, err := CloudURLFromString(rc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="28">payer, _ := GetString(OptionRequestPayer, rc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">rc.commonOptions = append(rc.commonOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        <span class="cov10" title="28">if cloudURL.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", rc.command.args[0])
        }</span>

        <span class="cov10" title="28">bucket, err := rc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // assembleOption
        <span class="cov10" title="28">if err := rc.assembleOption(cloudURL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="28">var res bool
        res, rc.filters = getFilter(os.Args)
        if !res </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude does not support format containing dir info")
        }</span>

        <span class="cov10" title="28">if !rc.rmOption.recursive &amp;&amp; len(rc.filters) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude only work with --recursive")
        }</span>

        // confirm remove objects/multiparts/allTypes before statistic
        <span class="cov10" title="28">if !rc.confirmRemoveObject(cloudURL) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // start progressbar
        <span class="cov10" title="28">go rc.entryStatistic(bucket, cloudURL)

        exitStat := normalExit
        if err = rc.removeEntry(bucket, cloudURL); err != nil </span><span class="cov4" title="4">{
                exitStat = errExit
        }</span>
        <span class="cov10" title="28">fmt.Printf(rc.monitor.progressBar(true, exitStat))
        return err</span>
}

func (rc *RemoveCommand) assembleOption(cloudURL CloudURL) error <span class="cov10" title="28">{
        rc.rmOption.recursive, _ = GetBool(OptionRecursion, rc.command.options)
        rc.rmOption.force, _ = GetBool(OptionForce, rc.command.options)
        isMultipart, _ := GetBool(OptionMultipart, rc.command.options)
        isAllType, _ := GetBool(OptionAllType, rc.command.options)
        toBucket, _ := GetBool(OptionBucket, rc.command.options)
        rc.rmOption.versionId, _ = GetString(OptionVersionId, rc.command.options)
        rc.rmOption.allVersions, _ = GetBool(OptionAllversions, rc.command.options)

        if err := rc.checkOption(cloudURL, isMultipart, isAllType, toBucket); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="28">rc.rmOption.typeSet = 0
        if isMultipart </span><span class="cov0" title="0">{
                rc.rmOption.typeSet |= multipartType
        }</span>
        <span class="cov10" title="28">if isAllType </span><span class="cov8" title="14">{
                rc.rmOption.typeSet |= allType
        }</span>
        <span class="cov10" title="28">if toBucket </span><span class="cov8" title="14">{
                rc.rmOption.typeSet |= bucketType
        }</span>
        <span class="cov10" title="28">if !rc.rmOption.recursive </span><span class="cov0" title="0">{
                if rc.rmOption.typeSet == 0 </span><span class="cov0" title="0">{
                        rc.rmOption.typeSet |= objectType
                }</span>
        } else<span class="cov10" title="28"> {
                if rc.rmOption.typeSet&amp;allType == 0 </span><span class="cov8" title="14">{
                        rc.rmOption.typeSet |= objectType
                }</span>
        }

        <span class="cov10" title="28">return nil</span>
}

func (rc *RemoveCommand) checkOption(cloudURL CloudURL, isMultipart, isAllType, toBucket bool) error <span class="cov10" title="28">{
        if !rc.rmOption.recursive </span><span class="cov0" title="0">{
                if !toBucket </span><span class="cov0" title="0">{
                        // "rm -a/m" miss object, invalid
                        if cloudURL.object == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("remove bucket, miss --bucket option, if you mean remove object, invalid url: %s, miss object", rc.command.args[0])
                        }</span>
                } else<span class="cov0" title="0"> {
                        if isMultipart || isAllType </span><span class="cov0" title="0">{
                                // "rm -mb" and "rm -ab", with or without object, both invalid
                                if cloudURL.object == "" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("remove bucket redundant option: --multipart or --all-type, if you mean remove all objects and the bucket meanwhile, you should add --recursive option")
                                }</span> else<span class="cov0" title="0"> {
                                        return fmt.Errorf("remove object redundant option: --bucket, remove bucket after remove single object is not supported")
                                }</span>
                        } else<span class="cov0" title="0"> if cloudURL.object != "" </span><span class="cov0" title="0">{
                                // "rm -b" with object, invalid
                                return fmt.Errorf("remove bucket invalid url: %s, object not empty, if you mean remove object, you should not use --bucket option", rc.command.args[0])
                        }</span>
                }
        }

        <span class="cov10" title="28">if len(rc.rmOption.versionId) &gt; 0 </span><span class="cov0" title="0">{
                if rc.rmOption.recursive </span><span class="cov0" title="0">{
                        return fmt.Errorf("remove objects: %s, do not support --version-id", rc.command.args[0])
                }</span>

                <span class="cov0" title="0">if rc.rmOption.allVersions </span><span class="cov0" title="0">{
                        return fmt.Errorf("remove object: %s, do not support --version-id and --all-versions at the same time.", rc.command.args[0])
                }</span>
        }

        <span class="cov10" title="28">return nil</span>
}

func (rc *RemoveCommand) confirmRemoveObject(cloudURL CloudURL) bool <span class="cov10" title="28">{
        if !rc.rmOption.force &amp;&amp; rc.rmOption.recursive &amp;&amp; rc.rmOption.typeSet&amp;allType != 0 </span><span class="cov0" title="0">{
                stringList := []string{}
                if rc.rmOption.typeSet&amp;objectType != 0 </span><span class="cov0" title="0">{
                        stringList = append(stringList, "objects")
                }</span>
                <span class="cov0" title="0">if rc.rmOption.typeSet&amp;multipartType != 0 </span><span class="cov0" title="0">{
                        stringList = append(stringList, "multipart uploadIds")
                }</span>
                <span class="cov0" title="0">var val string
                fmt.Printf("Do you really mean to remove recursively %s of %s(y or N)? ", strings.Join(stringList, " and "), rc.command.args[0])
                if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                        fmt.Println("operation is canceled.")
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov10" title="28">return true</span>
}

func (rc *RemoveCommand) entryStatistic(bucket *oss.Bucket, cloudURL CloudURL) <span class="cov10" title="28">{
        if rc.rmOption.typeSet&amp;objectType != 0 </span><span class="cov10" title="28">{
                rc.objectStatistic(bucket, cloudURL)
        }</span>
        <span class="cov9" title="27">if rc.rmOption.typeSet&amp;multipartType != 0 </span><span class="cov7" title="12">{
                rc.multipartUploadsStatistic(bucket, cloudURL)
        }</span>
        <span class="cov9" title="27">rc.monitor.setScanEnd()</span>
}

func (rc *RemoveCommand) objectStatistic(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov10" title="28">{
        // single object statistic before remove
        if rc.rmOption.recursive </span><span class="cov10" title="28">{
                if rc.rmOption.allVersions </span><span class="cov8" title="14">{
                        return rc.batchObjectStatisticVersion(bucket, cloudURL)
                }</span> else<span class="cov8" title="14"> {
                        return rc.batchObjectStatistic(bucket, cloudURL)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (rc *RemoveCommand) touchObject(bucket *oss.Bucket, cloudURL CloudURL) (bool, error) <span class="cov0" title="0">{
        exist, err := rc.ossIsObjectExistRetry(bucket, cloudURL.object)
        if err != nil </span><span class="cov0" title="0">{
                rc.monitor.setScanError(err)
        }</span> else<span class="cov0" title="0"> if exist </span><span class="cov0" title="0">{
                rc.monitor.updateScanNum(1)
        }</span>
        <span class="cov0" title="0">return exist, err</span>
}

func (rc *RemoveCommand) ossIsObjectExistRetry(bucket *oss.Bucket, object string) (bool, error) <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                exist, err := bucket.IsObjectExist(object, rc.commonOptions...)
                if err == nil </span><span class="cov0" title="0">{
                        return exist, err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return false, ObjectError{err, bucket.BucketName, object}
                }</span>
        }
}

func (rc *RemoveCommand) batchObjectStatistic(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov8" title="14">{
        pre := oss.Prefix(cloudURL.object)
        marker := oss.Marker("")
        for </span><span class="cov8" title="14">{
                listOptions := append(rc.commonOptions, marker, pre, oss.MaxKeys(1000))
                lor, err := rc.command.ossListObjectsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov1" title="1">{
                        rc.monitor.setScanError(err)
                        return err
                }</span>

                <span class="cov7" title="12">if len(rc.filters) == 0 </span><span class="cov7" title="12">{
                        rc.monitor.updateScanNum(int64(len(lor.Objects)))
                }</span> else<span class="cov0" title="0"> {
                        for _, object := range lor.Objects </span><span class="cov0" title="0">{
                                if doesSingleObjectMatchPatterns(object.Key, rc.filters) </span><span class="cov0" title="0">{
                                        rc.monitor.updateScanNum(int64(1))
                                }</span>
                        }
                }

                <span class="cov7" title="12">pre = oss.Prefix(lor.Prefix)
                marker = oss.Marker(lor.NextMarker)
                if !lor.IsTruncated </span><span class="cov7" title="12">{
                        break</span>
                }
        }
        <span class="cov7" title="12">return nil</span>
}

func (rc *RemoveCommand) multipartUploadsStatistic(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov7" title="12">{
        pre := oss.Prefix(cloudURL.object)
        keyMarker := oss.KeyMarker("")
        uploadIdMarker := oss.UploadIDMarker("")
        for </span><span class="cov7" title="12">{
                listOptions := append(rc.commonOptions, keyMarker, uploadIdMarker, pre)
                lmr, err := rc.command.ossListMultipartUploadsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        rc.monitor.setScanError(err)
                        return err
                }</span>

                <span class="cov7" title="12">if rc.rmOption.recursive </span><span class="cov7" title="12">{
                        if len(rc.filters) == 0 </span><span class="cov7" title="12">{
                                rc.monitor.updateScanUploadIdNum(int64(len(lmr.Uploads)))
                        }</span> else<span class="cov0" title="0"> {
                                for _, upload := range lmr.Uploads </span><span class="cov0" title="0">{
                                        if doesSingleObjectMatchPatterns(upload.Key, rc.filters) </span><span class="cov0" title="0">{
                                                rc.monitor.updateScanUploadIdNum(int64(1))
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        for _, uploadId := range lmr.Uploads </span><span class="cov0" title="0">{
                                if uploadId.Key == cloudURL.object </span><span class="cov0" title="0">{
                                        rc.monitor.updateScanUploadIdNum(1)
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                        }
                }

                <span class="cov7" title="12">pre = oss.Prefix(lmr.Prefix)
                keyMarker = oss.KeyMarker(lmr.NextKeyMarker)
                uploadIdMarker = oss.UploadIDMarker(lmr.NextUploadIDMarker)
                if !lmr.IsTruncated </span><span class="cov7" title="12">{
                        break</span>
                }
        }
        <span class="cov7" title="12">return nil</span>
}

func (rc *RemoveCommand) removeEntry(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov10" title="28">{
        // op control whether to show progress bar of the type,
        // but do not control whether to record the ok/error num of the type,
        // so the show and record can be separated.
        rc.monitor.updateOP(rc.rmOption.typeSet &amp; allType)

        if rc.rmOption.typeSet&amp;objectType != 0 </span><span class="cov10" title="28">{
                if err := rc.removeObjectEntry(bucket, cloudURL); err != nil </span><span class="cov4" title="4">{
                        return err
                }</span>

                <span class="cov9" title="24">if rc.rmOption.recursive &amp;&amp; len(rc.filters) == 0 </span><span class="cov9" title="24">{
                        // check again
                        // the key including special character can't be deleted by function removeObjectEntry
                        // so delete them one by one
                        if err := rc.removeSpecialCharacterObjects(bucket, cloudURL); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov9" title="24">if rc.rmOption.typeSet&amp;multipartType != 0 </span><span class="cov7" title="12">{
                if err := rc.removeMultipartUploadsEntry(bucket, cloudURL); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov9" title="24">if rc.rmOption.typeSet&amp;bucketType != 0 </span><span class="cov7" title="12">{
                return rc.removeBucket(bucket, cloudURL)
        }</span>

        <span class="cov7" title="12">return nil</span>
}

func (rc *RemoveCommand) removeObjectEntry(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov10" title="28">{
        //version mode
        if len(rc.rmOption.versionId) &gt; 0 || rc.rmOption.allVersions </span><span class="cov8" title="14">{
                if len(rc.rmOption.versionId) &gt; 0 </span><span class="cov0" title="0">{
                        return rc.removeObjectVersion(bucket, cloudURL, rc.rmOption.versionId)
                }</span> else<span class="cov8" title="14"> if !rc.rmOption.recursive </span><span class="cov0" title="0">{
                        return rc.removeObjectAllVersion(bucket, cloudURL)
                }</span> else<span class="cov8" title="14"> {
                        return rc.batchDeleteObjectsVersion(bucket, cloudURL)
                }</span>
        } else<span class="cov8" title="14"> {
                if !rc.rmOption.recursive </span><span class="cov0" title="0">{
                        return rc.removeObject(bucket, cloudURL)
                }</span> else<span class="cov8" title="14"> {
                        return rc.batchDeleteObjects(bucket, cloudURL)
                }</span>
        }
}

func (rc *RemoveCommand) removeObject(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov0" title="0">{
        // single object statistic before remove to avoid inconsistency
        exist, err := rc.touchObject(bucket, cloudURL)
        if err != nil || exist </span><span class="cov0" title="0">{
                err = rc.deleteObjectWithMonitor(bucket, cloudURL.object)
                if err != nil &amp;&amp; rc.monitor.op == objectType </span><span class="cov0" title="0">{
                        // remove single object error, return error information, do not print progressbar
                        rc.monitor.setOP(0)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (rc *RemoveCommand) deleteObjectWithMonitor(bucket *oss.Bucket, object string) error <span class="cov0" title="0">{
        err := rc.ossDeleteObjectRetry(bucket, object)
        if err == nil </span><span class="cov0" title="0">{
                rc.updateObjectMonitor(1, 0)
        }</span> else<span class="cov0" title="0"> {
                rc.updateObjectMonitor(0, 1)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (rc *RemoveCommand) ossDeleteObjectRetry(bucket *oss.Bucket, object string) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                err := bucket.DeleteObject(object, rc.commonOptions...)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, object}
                }</span>
        }
}

func (rc *RemoveCommand) updateObjectMonitor(okNum, errNum int64) <span class="cov9" title="24">{
        rc.monitor.updateObjectNum(okNum)
        rc.monitor.updateErrObjectNum(errNum)
        fmt.Printf(rc.monitor.progressBar(false, normalExit))
}</span>

func (rc *RemoveCommand) batchDeleteObjects(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov8" title="14">{
        // list objects
        pre := oss.Prefix(cloudURL.object)
        marker := oss.Marker("")
        for </span><span class="cov8" title="14">{
                listOptions := append(rc.commonOptions, marker, pre, oss.MaxKeys(1000))
                lor, err := rc.command.ossListObjectsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>

                // batch delete
                <span class="cov7" title="12">skipLor := rc.getObjectsFromListResult(lor)
                delNum, err := rc.ossBatchDeleteObjectsRetry(bucket, skipLor)
                rc.updateObjectMonitor(int64(delNum), int64(len(skipLor)-delNum))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="12">pre = oss.Prefix(lor.Prefix)
                marker = oss.Marker(lor.NextMarker)
                if !lor.IsTruncated </span><span class="cov7" title="12">{
                        break</span>
                }
        }
        <span class="cov7" title="12">return nil</span>
}

func (rc *RemoveCommand) ossBatchDeleteObjectsRetry(bucket *oss.Bucket, objects []string) (int, error) <span class="cov7" title="12">{
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        num := len(objects)
        if num &lt;= 0 </span><span class="cov7" title="12">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">deletedNum := 0
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                listOptions := append(rc.commonOptions, oss.DeleteObjectsQuiet(true))
                delRes, err := bucket.DeleteObjects(objects, listOptions...)
                if err == nil </span><span class="cov0" title="0">{
                        deletedNum += (len(objects) - len(delRes.DeletedObjects))
                        if len(delRes.DeletedObjects) == 0 </span><span class="cov0" title="0">{
                                return deletedNum, nil
                        }</span>
                        <span class="cov0" title="0">objects = delRes.DeletedObjects</span>
                } else<span class="cov0" title="0"> {
                        // when 4XX,5XX error,delRes.DeletedObjects is empty
                        if len(delRes.DeletedObjects) &gt; 0 </span><span class="cov0" title="0">{
                                deletedNum += (len(objects) - len(delRes.DeletedObjects))
                                objects = delRes.DeletedObjects
                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        serviceError, noNeedRetry := err.(oss.ServiceError)
                        if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                                return deletedNum, fmt.Errorf("%s,delete objects: %#v failed", err.Error(), objects)
                        }</span>
                }
        }
}

func (rc *RemoveCommand) removeSpecialCharacterObjects(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov9" title="24">{
        pre := oss.Prefix(cloudURL.object)
        marker := oss.Marker("")
        for </span><span class="cov9" title="24">{
                listOptions := append(rc.commonOptions, marker, pre, oss.MaxKeys(1000))
                lor, err := rc.command.ossListObjectsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="24">for _, object := range lor.Objects </span><span class="cov0" title="0">{
                        if err := bucket.DeleteObject(object.Key, rc.commonOptions...); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov9" title="24">pre = oss.Prefix(lor.Prefix)
                marker = oss.Marker(lor.NextMarker)
                if !lor.IsTruncated </span><span class="cov9" title="24">{
                        break</span>
                }
        }
        <span class="cov9" title="24">return nil</span>
}

func (rc *RemoveCommand) getObjectsFromListResult(lor oss.ListObjectsResult) []string <span class="cov7" title="12">{
        objects := []string{}
        for _, object := range lor.Objects </span><span class="cov0" title="0">{
                if doesSingleObjectMatchPatterns(object.Key, rc.filters) </span><span class="cov0" title="0">{
                        objects = append(objects, object.Key)
                }</span>
        }
        <span class="cov7" title="12">return objects</span>
}

func (rc *RemoveCommand) removeMultipartUploadsEntry(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov7" title="12">{
        routines := 1
        chUploadIds := make(chan uploadIdInfoType, ChannelBuf)
        chError := make(chan error, routines+1)
        chListError := make(chan error, 1)
        go rc.multipartUploadsProducer(bucket, cloudURL, chUploadIds, chListError)
        for i := 0; i &lt; routines; i++ </span><span class="cov7" title="12">{
                go rc.abortMultipartUploadConsumer(bucket, chUploadIds, chError)
        }</span>

        <span class="cov7" title="12">completed := 0
        for completed &lt;= routines </span><span class="cov9" title="24">{
                select </span>{
                case err := &lt;-chListError:<span class="cov7" title="12">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov7" title="12">completed++</span>
                case err := &lt;-chError:<span class="cov7" title="12">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov7" title="12">completed++</span>
                }
        }
        <span class="cov7" title="12">return nil</span>
}

func (rc *RemoveCommand) multipartUploadsProducer(bucket *oss.Bucket, cloudURL CloudURL, chUploadIds chan&lt;- uploadIdInfoType, chListError chan&lt;- error) <span class="cov7" title="12">{
        pre := oss.Prefix(cloudURL.object)
        keyMarker := oss.KeyMarker("")
        uploadIdMarker := oss.UploadIDMarker("")
        for </span><span class="cov7" title="12">{
                listOptions := append(rc.commonOptions, keyMarker, uploadIdMarker, pre)
                lmr, err := rc.command.ossListMultipartUploadsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        chListError &lt;- err
                        break</span>
                }

                <span class="cov7" title="12">for _, uploadId := range lmr.Uploads </span><span class="cov0" title="0">{
                        if !rc.rmOption.recursive &amp;&amp; uploadId.Key != cloudURL.object </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if doesSingleObjectMatchPatterns(uploadId.Key, rc.filters) </span><span class="cov0" title="0">{
                                chUploadIds &lt;- uploadIdInfoType{uploadId.Key, uploadId.UploadID}
                        }</span>
                }

                <span class="cov7" title="12">pre = oss.Prefix(lmr.Prefix)
                keyMarker = oss.KeyMarker(lmr.NextKeyMarker)
                uploadIdMarker = oss.UploadIDMarker(lmr.NextUploadIDMarker)
                if !lmr.IsTruncated </span><span class="cov7" title="12">{
                        break</span>
                }
        }
        <span class="cov7" title="12">defer close(chUploadIds)
        chListError &lt;- nil</span>
}

func (rc *RemoveCommand) abortMultipartUploadConsumer(bucket *oss.Bucket, chUploadIds &lt;-chan uploadIdInfoType, chError chan&lt;- error) <span class="cov7" title="12">{
        for uploadIdInfo := range chUploadIds </span><span class="cov0" title="0">{
                err := rc.ossAbortMultipartUploadRetry(bucket, uploadIdInfo.key, uploadIdInfo.uploadId)
                rc.updateUploadIdMonitor(err)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        return
                }</span>
        }

        <span class="cov7" title="12">chError &lt;- nil</span>
}

func (rc *RemoveCommand) updateUploadIdMonitor(err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                rc.monitor.updateUploadIdNum(1)
        }</span> else<span class="cov0" title="0"> {
                rc.monitor.updateErrUploadIdNum(1)
        }</span>
        <span class="cov0" title="0">fmt.Printf(rc.monitor.progressBar(false, normalExit))</span>
}

func (rc *RemoveCommand) ossAbortMultipartUploadRetry(bucket *oss.Bucket, key, uploadId string) error <span class="cov0" title="0">{
        var imur = oss.InitiateMultipartUploadResult{Bucket: bucket.BucketName, Key: key, UploadID: uploadId}
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                err := bucket.AbortMultipartUpload(imur, rc.commonOptions...)

                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">switch err.(type) </span>{
                case oss.ServiceError:<span class="cov0" title="0">
                        if err.(oss.ServiceError).Code == "NoSuchUpload" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, key}
                }</span>
        }
}

func (rc *RemoveCommand) removeBucket(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov7" title="12">{
        if !rc.confirmRemoveBucket(cloudURL) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov7" title="12">rc.monitor.updateOP(bucketType)
        err := rc.ossDeleteBucketRetry(&amp;bucket.Client, cloudURL.bucket)
        if err == nil </span><span class="cov7" title="12">{
                rc.monitor.updateRemovedBucket(cloudURL.bucket)
        }</span>
        <span class="cov7" title="12">return err</span>
}

func (rc *RemoveCommand) confirmRemoveBucket(cloudURL CloudURL) bool <span class="cov7" title="12">{
        if !rc.rmOption.force </span><span class="cov0" title="0">{
                var val string
                fmt.Printf(getClearStr(fmt.Sprintf("Do you really mean to remove the Bucket: %s(y or N)? ", cloudURL.bucket)))
                if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                        fmt.Println("operation is canceled.")
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov7" title="12">return true</span>
}

func (rc *RemoveCommand) ossDeleteBucketRetry(client *oss.Client, bucket string) error <span class="cov7" title="12">{
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        for i := 1; ; i++ </span><span class="cov7" title="12">{
                err := client.DeleteBucket(bucket)
                if err == nil </span><span class="cov7" title="12">{
                        return err
                }</span>

                // http 4XX error no need to retry
                // only network error or internal error need to retry
                <span class="cov0" title="0">serviceError, noNeedRetry := err.(oss.ServiceError)
                if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "bucket you tried to delete is not empty") </span><span class="cov0" title="0">{
                                fmt.Printf("\nWhether new objects were uploaded during the deletion?\n\n")
                        }</span>
                        <span class="cov0" title="0">return BucketError{err, bucket}</span>
                }

                // wait 1 second
                <span class="cov0" title="0">time.Sleep(time.Duration(1) * time.Second)</span>
        }
}

//version
func (rc *RemoveCommand) removeObjectVersion(bucket *oss.Bucket, cloudURL CloudURL, versionId string) error <span class="cov0" title="0">{
        err := rc.deleteObjectWithMonitorVersion(bucket, cloudURL.object, versionId)
        if err != nil &amp;&amp; rc.monitor.op == objectType </span><span class="cov0" title="0">{
                // remove single object error, return error information, do not print progressbar
                rc.monitor.setOP(0)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (rc *RemoveCommand) deleteObjectWithMonitorVersion(bucket *oss.Bucket, object string, versionId string) error <span class="cov0" title="0">{
        err := rc.ossDeleteObjectRetryVersion(bucket, object, versionId)
        if err == nil </span><span class="cov0" title="0">{
                rc.monitor.updateScanNum(1)
                rc.updateObjectMonitor(1, 0)
        }</span> else<span class="cov0" title="0"> {
                rc.updateObjectMonitor(0, 1)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (rc *RemoveCommand) ossDeleteObjectRetryVersion(bucket *oss.Bucket, object string, versionId string) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                listOptions := append(rc.commonOptions, oss.VersionId(versionId))
                err := bucket.DeleteObject(object, listOptions...)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, object}
                }</span>
        }
}

func (rc *RemoveCommand) removeObjectAllVersion(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov0" title="0">{

        // list objects
        pre := oss.Prefix(cloudURL.object)
        keyMarker := oss.KeyMarker("")
        versionIdMarker := oss.VersionIdMarker("")

        for </span><span class="cov0" title="0">{
                listOptions := append(rc.commonOptions, pre, keyMarker, versionIdMarker, oss.MaxKeys(1000))
                lor, err := rc.command.ossListObjectVersionsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">objectsToDelete := make([]oss.DeleteObject, 0)
                for _, object := range lor.ObjectDeleteMarkers </span><span class="cov0" title="0">{
                        if object.Key != cloudURL.object </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">objectsToDelete = append(objectsToDelete, oss.DeleteObject{
                                Key:       object.Key,
                                VersionId: object.VersionId,
                        })</span>
                }

                <span class="cov0" title="0">for _, object := range lor.ObjectVersions </span><span class="cov0" title="0">{
                        if object.Key != cloudURL.object </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">objectsToDelete = append(objectsToDelete, oss.DeleteObject{
                                Key:       object.Key,
                                VersionId: object.VersionId,
                        })</span>
                }

                <span class="cov0" title="0">rc.monitor.updateScanNum(int64(len(objectsToDelete)))

                // batch delete
                delNum, err := rc.ossBatchDeleteObjectsRetryVersion(bucket, objectsToDelete)
                rc.updateObjectMonitor(int64(delNum), int64(len(objectsToDelete)-delNum))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">pre = oss.Prefix(lor.Prefix)
                keyMarker = oss.KeyMarker(lor.NextKeyMarker)
                versionIdMarker = oss.VersionIdMarker(lor.NextVersionIdMarker)

                if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if lor.NextKeyMarker != cloudURL.object </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (rc *RemoveCommand) batchObjectStatisticVersion(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov8" title="14">{
        pre := oss.Prefix(cloudURL.object)
        keyMarker := oss.KeyMarker("")
        versionIdMarker := oss.VersionIdMarker("")

        for </span><span class="cov8" title="14">{
                listOptions := append(rc.commonOptions, pre, keyMarker, versionIdMarker, oss.MaxKeys(1000))
                lor, err := rc.command.ossListObjectVersionsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov2" title="2">{
                        rc.monitor.setScanError(err)
                        return err
                }</span>

                <span class="cov7" title="12">if len(rc.filters) == 0 </span><span class="cov7" title="12">{
                        rc.monitor.updateScanNum(int64(len(lor.ObjectDeleteMarkers) + len(lor.ObjectVersions)))
                }</span> else<span class="cov0" title="0"> {
                        for _, object := range lor.ObjectDeleteMarkers </span><span class="cov0" title="0">{
                                if doesSingleObjectMatchPatterns(object.Key, rc.filters) </span><span class="cov0" title="0">{
                                        rc.monitor.updateScanNum(int64(1))
                                }</span>
                        }

                        <span class="cov0" title="0">for _, object := range lor.ObjectVersions </span><span class="cov0" title="0">{
                                if doesSingleObjectMatchPatterns(object.Key, rc.filters) </span><span class="cov0" title="0">{
                                        rc.monitor.updateScanNum(int64(1))
                                }</span>
                        }
                }

                <span class="cov7" title="12">pre = oss.Prefix(lor.Prefix)
                keyMarker = oss.KeyMarker(lor.NextKeyMarker)
                versionIdMarker = oss.VersionIdMarker(lor.NextVersionIdMarker)

                if !lor.IsTruncated </span><span class="cov7" title="12">{
                        break</span>
                }
        }
        <span class="cov7" title="12">return nil</span>
}

func (rc *RemoveCommand) batchDeleteObjectsVersion(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov8" title="14">{
        // list objects
        pre := oss.Prefix(cloudURL.object)
        keyMarker := oss.KeyMarker("")
        versionIdMarker := oss.VersionIdMarker("")

        for </span><span class="cov8" title="14">{
                listOptions := append(rc.commonOptions, pre, keyMarker, versionIdMarker, oss.MaxKeys(1000))
                lor, err := rc.command.ossListObjectVersionsRetry(bucket, listOptions...)
                if err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>

                <span class="cov7" title="12">objectsToDelete := make([]oss.DeleteObject, 0)
                for _, object := range lor.ObjectDeleteMarkers </span><span class="cov0" title="0">{
                        if doesSingleObjectMatchPatterns(object.Key, rc.filters) </span><span class="cov0" title="0">{
                                objectsToDelete = append(objectsToDelete, oss.DeleteObject{
                                        Key:       object.Key,
                                        VersionId: object.VersionId,
                                })
                        }</span>
                }

                <span class="cov7" title="12">for _, object := range lor.ObjectVersions </span><span class="cov6" title="7">{
                        if doesSingleObjectMatchPatterns(object.Key, rc.filters) </span><span class="cov6" title="7">{
                                objectsToDelete = append(objectsToDelete, oss.DeleteObject{
                                        Key:       object.Key,
                                        VersionId: object.VersionId,
                                })
                        }</span>
                }

                // batch delete
                <span class="cov7" title="12">delNum, err := rc.ossBatchDeleteObjectsRetryVersion(bucket, objectsToDelete)
                rc.updateObjectMonitor(int64(delNum), int64(len(objectsToDelete)-delNum))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="12">pre = oss.Prefix(lor.Prefix)
                keyMarker = oss.KeyMarker(lor.NextKeyMarker)
                versionIdMarker = oss.VersionIdMarker(lor.NextVersionIdMarker)
                if !lor.IsTruncated </span><span class="cov7" title="12">{
                        break</span>
                }
        }
        <span class="cov7" title="12">return nil</span>
}

func (rc *RemoveCommand) ossBatchDeleteObjectsRetryVersion(bucket *oss.Bucket, objectVersions []oss.DeleteObject) (int, error) <span class="cov7" title="12">{
        retryTimes, _ := GetInt(OptionRetryTimes, rc.command.options)
        num := len(objectVersions)
        if num &lt;= 0 </span><span class="cov5" title="5">{
                return 0, nil
        }</span>

        <span class="cov6" title="7">deletedNum := 0
        for i := 1; ; i++ </span><span class="cov6" title="7">{
                listOptions := append(rc.commonOptions, oss.DeleteObjectsQuiet(true))
                delRes, err := bucket.DeleteObjectVersions(objectVersions, listOptions...)
                getFailedObject := false
                if err == nil </span><span class="cov6" title="7">{
                        deletedNum += (len(objectVersions) - len(delRes.DeletedObjectsDetail))
                        if len(delRes.DeletedObjectsDetail) == 0 </span><span class="cov6" title="7">{
                                return deletedNum, nil
                        }</span>
                        <span class="cov0" title="0">getFailedObject = true</span>
                } else<span class="cov0" title="0"> {
                        // when 4XX,5XX error,delRes.DeletedObjects is empty
                        if len(delRes.DeletedObjectsDetail) &gt; 0 </span><span class="cov0" title="0">{
                                deletedNum += (len(objectVersions) - len(delRes.DeletedObjectsDetail))
                                getFailedObject = true
                        }</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        serviceError, noNeedRetry := err.(oss.ServiceError)
                        if int64(i) &gt;= retryTimes || (noNeedRetry &amp;&amp; serviceError.StatusCode &lt; 500) </span><span class="cov0" title="0">{
                                return deletedNum, fmt.Errorf("%s,delete versioning objects: %#v failed", err.Error(), objectVersions)
                        }</span>
                }

                <span class="cov0" title="0">if getFailedObject </span><span class="cov0" title="0">{
                        objectVersions = make([]oss.DeleteObject, 0)
                        for _, object := range delRes.DeletedObjectsDetail </span><span class="cov0" title="0">{
                                objectVersions = append(objectVersions, oss.DeleteObject{
                                        Key:       object.Key,
                                        VersionId: object.VersionId,
                                })
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package lib

import (
        "fmt"
        "os"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var aclMap = map[oss.ACLType][]string{
        oss.ACLPublicReadWrite: []string{},
        oss.ACLPublicRead:      []string{},
        oss.ACLPrivate:         []string{},
        oss.ACLDefault:         []string{},
}

var bucketACLList = []oss.ACLType{
        oss.ACLPublicReadWrite,
        oss.ACLPublicRead,
        oss.ACLPrivate,
}

var objectACLList = []oss.ACLType{
        oss.ACLPublicReadWrite,
        oss.ACLPublicRead,
        oss.ACLPrivate,
        oss.ACLDefault,
}

type setACLType int

const (
        bucketACL setACLType = iota
        objectACL
)

func formatACLString(aclType setACLType, sep string) string <span class="cov6" title="8">{
        var list []oss.ACLType
        if aclType == bucketACL </span><span class="cov4" title="4">{
                list = bucketACLList
        }</span> else<span class="cov4" title="4"> {
                list = objectACLList
        }</span>

        <span class="cov6" title="8">strList := []string{}
        for _, acl := range list </span><span class="cov10" title="28">{
                str := string(acl)
                if len(aclMap[acl]) != 0 </span><span class="cov0" title="0">{
                        str += "(" + strings.Join(aclMap[acl][:], ",") + ")"
                }</span>
                <span class="cov10" title="28">strList = append(strList, str)</span>
        }
        <span class="cov6" title="8">return strings.Join(strList, sep)</span>
}

var specChineseSetACL = SpecText{

        synopsisText: "设置bucket或者objects的acl",

        paramText: "cloud_url [acl] [options]",

        syntaxText: ` 
    ossutil set-acl oss://bucket[/prefix] [acl] [-r] [-b] [-f] [-c file] [--version-id versionId]
`,

        detailHelpText: ` 
    该命令设置指定bucket或者objects的acl。使用命令时若缺失了acl信息时，ossutil会询问用户acl信息。

        （1）设置bucket的acl，参考用法1)
        （2）设置单个object的acl，参考用法2)
        （3）批量设置objects的acl，不设置bucket的acl，参考用法3)

    对bucket设置acl，需要添加--bucket选项，否则视为对其中的objects设置acl。
    该命令不支持同时设置bucket和objects的acl，请分开操作。

    结果：显示命令耗时前未报错，则表示成功设置。
    查看bucket或者object的acl信息，请使用stat命令。

ACL：

    bucket的acl有三种，括号里为ossutil额外支持的简写模式：
        ` + formatACLString(bucketACL, "\n        ") + `

    object的acl有四种：
        ` + formatACLString(objectACL, "\n        ") + `

    acl的详细信息请参见：https://help.aliyun.com/document_detail/31867.html?spm=5176.doc31960.6.147.8dVwsh中的权限控制。

用法：

    该命令有三种用法：

    1) ossutil set-acl oss://bucket [acl] -b [-c file]
        当设置了--bucket选项时，ossutil会尝试设置bucket的acl，此时不支持--recursive选项，并且请
    确保输入的cloud_url精确匹配想要设置acl的bucket，无论--force选项是否指定，都不会进行询问提示。
    如果用户在命令行中缺失acl信息，会进入交互模式，询问用户的acl信息。 

    2) ossutil set-acl oss://bucket/object [acl] [-c file] [--version-id versionId]
        该用法设置指定单个object的acl，当指定object不存在时，ossutil会提示错误，此时请确保指定的
    cloud_url精确匹配需要设置acl的object，并且不要指定--recursive选项（否则ossutil会进行前缀匹配，
    设置多个objects的acl），无论--force选项是否指定，都不会进行询问提示。如果用户在命令行中缺失
    acl信息，会进入交互模式，询问用户的acl信息。

    3) ossutil set-acl oss://bucket[/prefix] [acl] -r [-f] [-c file]
        该用法可批量设置objects的acl，此时必须输入--recursive选项，ossutil会查找所有前缀匹配cloud_url
    的objects，设置它们的acl，当一个object操作出现错误时，会将出错object的错误信息记录到report文件，
    并继续操作其他object，成功操作的object信息将不会被记录到report文件中（更多信息见cp命令的帮助）。
    此时不支持--bucket选项，即ossutil不支持同时设置bucket和其中objects的acl，如有需要，请分开操作。
    如果--force选项被指定，则不会进行询问提示。如果用户在命令行中缺失acl信息，会进入交互模式，询问
    用户的acl信息。
        如果指定了--include/--exclude选项，ossutil会查找所有匹配pattern的objects，批量设置。
        --include和--exclude选项说明，请参考cp命令帮助。
`,

        sampleText: ` 
    (1)ossutil set-acl oss://bucket1 public-read-write -b 

    (2)ossutil set-acl oss://bucket1/obj1 private 

    (3)ossutil set-acl oss://bucket1/obj default -r
       ossutil set-acl oss://bucket1/obj default -r --include "*.jpg"
       ossutil set-acl oss://bucket1/obj default -r --exclude "*.jpg"

    (4)ossutil set-acl oss://bucket1/%e4%b8%ad%e6%96%87 default --encoding-type url

    (5)ossutil set-acl oss://bucket1/obj1 private --version-id versionId
`,
}

var specEnglishSetACL = SpecText{

        synopsisText: "Set acl on bucket or objects",

        paramText: "cloud_url [acl] [options]",

        syntaxText: ` 
    ossutil set-acl oss://bucket[/prefix] [acl] [-r] [-b] [-f] [-c file] [--version-id versionId]
`,

        detailHelpText: ` 
    The command set acl on the specified bucket or objects. If you use the command 
    witout acl information, ossutil will ask user for it.

    (1) set acl on bucket, see usage 1)
    (2) set acl on single object, see usage 2)
    (3) batch set acl on many objects, see usage 3)

    When set acl on bucket, the --bucket option must be specified. 
    Set acl on bucket an objects inside simultaneously is not supported, please 
    operate independently.

    Result: if no error displayed before show elasped time, then the setting is completed successfully.
    User can use stat command to check the acl information of bucket or objects.

ACL:

    ossutil supports following bucket acls, shorthand versions in brackets:
        ` + formatACLString(bucketACL, "\n        ") + `

    ossutil support following objet acls:
        ` + formatACLString(objectACL, "\n        ") + `

    More information about acl see ACL Control in https://help.aliyun.com/document_detail/31867.html?spm=5176.doc31960.6.147.8dVwsh.

Usage：

    There are three usages:    

    1) ossutil set-acl oss://bucket [acl] -b [-c file]
        If --bucket option is specified, ossutil will try to set acl on bucket. In the 
    usage, please make sure cloud_url exactly specified the bucket you want to set acl 
    on, and --recursive option is not supported here. No matter --force option is specified 
    or not, ossutil will not show prompt question. If acl information is missed, ossutil 
    will enter interactive mode and ask you for it. 

    2) ossutil set-acl oss://bucket/object [acl] [-c file] [--version-id versionId]
        The usage set acl on single object, if object not exist, error occurs. In the 
    usage, please make sure cloud_url exactly specified the object you want to set acl 
    on, and --recursive option is not specified(or ossutil will search for prefix-matching 
    objects and set acl on those objects). No matter --force option is specified or not, 
    ossutil will not show prompt question. If acl information is missed, ossutil will 
    enter interactive mode and ask you for it. 

    3) ossutil set-acl oss://bucket[/prefix] [acl] -r [-f] [-c file]
        The usage can set acl on many objects, --recursive option is required for the 
    usage, ossutil will search for prefix-matching objects and set acl on those objects. 
    If an error occurs, ossutil will record the error message to report file, and ossutil 
    will continue to attempt to set acl on the remaining objects(more information see 
    help of cp command). In the usage, --bucket option is not supported, which means set 
    acl on bucket an objects inside simultaneously is not supported. If --force option 
    is specified, ossutil will not show prompt question. If acl information is missed, 
    ossutil will enter interactive mode and ask you for it. 
        If --include/--exclude option is specified, ossutil will search for pattern-matching 
    objects and set meta on those objects.
        --include and --exclude option, please refer cp command help.
`,

        sampleText: ` 
    (1)ossutil set-acl oss://bucket1 public-read-write -b 

    (2)ossutil set-acl oss://bucket1/obj1 private 

    (3)ossutil set-acl oss://bucket1/obj default -r
       ossutil set-acl oss://bucket1/obj default -r --include "*.jpg"
       ossutil set-acl oss://bucket1/obj default -r --exclude "*.jpg"

    (4)ossutil set-acl oss://bucket1/%e4%b8%ad%e6%96%87 default --encoding-type url

    (5)ossutil set-acl oss://bucket1/obj1 private --version-id versionId
`,
}

// SetACLCommand is the command set acl
type SetACLCommand struct {
        monitor  Monitor //Put first for atomic op on some fileds
        command  Command
        saOption batchOptionType
        filters  []filterOptionType
}

var setACLCommand = SetACLCommand{
        command: Command{
                name:        "set-acl",
                nameAlias:   []string{"setacl", "set_acl"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseSetACL,
                specEnglish: specEnglishSetACL,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionRecursion,
                        OptionBucket,
                        OptionForce,
                        OptionEncodingType,
                        OptionConfigFile,
                        OptionInclude,
                        OptionExclude,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionRoutines,
                        OptionOutputDir,
                        OptionLogLevel,
                        OptionVersionId,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (sc *SetACLCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return sc.command.formatHelpForWhole()
}</span>

func (sc *SetACLCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return sc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (sc *SetACLCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return sc.command.Init(args, options, sc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (sc *SetACLCommand) RunCommand() error <span class="cov0" title="0">{
        sc.monitor.init("Setted acl on")

        recursive, _ := GetBool(OptionRecursion, sc.command.options)
        toBucket, _ := GetBool(OptionBucket, sc.command.options)
        force, _ := GetBool(OptionForce, sc.command.options)
        routines, _ := GetInt(OptionRoutines, sc.command.options)
        encodingType, _ := GetString(OptionEncodingType, sc.command.options)
        versionId, _ := GetString(OptionVersionId, sc.command.options)

        var res bool
        res, sc.filters = getFilter(os.Args)
        if !res </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude does not support format containing dir info")
        }</span>

        <span class="cov0" title="0">if !recursive &amp;&amp; len(sc.filters) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude only work with --recursive")
        }</span>

        <span class="cov0" title="0">if recursive &amp;&amp; len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--version-id only work on single object")
        }</span>

        <span class="cov0" title="0">cloudURL, err := CloudURLFromString(sc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cloudURL.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", sc.command.args[0])
        }</span>

        <span class="cov0" title="0">bucket, err := sc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if toBucket </span><span class="cov0" title="0">{
                return sc.setBucketACL(&amp;bucket.Client, cloudURL, recursive)
        }</span>
        <span class="cov0" title="0">if !recursive </span><span class="cov0" title="0">{
                return sc.setObjectACL(bucket, cloudURL, versionId)
        }</span>
        <span class="cov0" title="0">return sc.batchSetObjectACL(bucket, cloudURL, force, routines)</span>
}

func (sc *SetACLCommand) setBucketACL(client *oss.Client, cloudURL CloudURL, recursive bool) error <span class="cov0" title="0">{
        if cloudURL.object != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("set bucket acl invalid url: %s, object not empty, if you mean set object acl, you should not use --bucket option", sc.command.args[0])
        }</span>

        <span class="cov0" title="0">if recursive </span><span class="cov0" title="0">{
                return fmt.Errorf("set bucket acl do not support --recursive option, if you mean set object acl recursivlly, you should not use --bucket option")
        }</span>

        <span class="cov0" title="0">acl, err := sc.getACL(bucketACL, recursive)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sc.ossSetBucketACLRetry(client, cloudURL.bucket, acl)</span>
}

func (sc *SetACLCommand) getACL(aclType setACLType, recursive bool) (oss.ACLType, error) <span class="cov0" title="0">{
        var acl string
        if len(sc.command.args) == 2 </span><span class="cov0" title="0">{
                acl = sc.command.args[1]
        }</span> else<span class="cov0" title="0"> {
                str := "bucket"
                if aclType == objectACL </span><span class="cov0" title="0">{
                        str = "object"
                        if recursive </span><span class="cov0" title="0">{
                                str = "objects"
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("Please enter the acl you want to set on the %s(%s):", str, formatACLString(aclType, ", "))
                if _, err := fmt.Scanln(&amp;acl); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid acl: %s, please check", acl)
                }</span>
        }

        <span class="cov0" title="0">return sc.command.checkACL(acl, aclType)</span>
}

func (cmd *Command) checkACL(acl string, aclType setACLType) (oss.ACLType, error) <span class="cov0" title="0">{
        if aclType == bucketACL </span><span class="cov0" title="0">{
                for _, item := range bucketACLList </span><span class="cov0" title="0">{
                        if acl == string(item) </span><span class="cov0" title="0">{
                                return item, nil
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                for _, item := range objectACLList </span><span class="cov0" title="0">{
                        if acl == string(item) </span><span class="cov0" title="0">{
                                return item, nil
                        }</span>
                }

        }

        <span class="cov0" title="0">return "", fmt.Errorf("invalid acl: %s, please check", acl)</span>
}

func (sc *SetACLCommand) ossSetBucketACLRetry(client *oss.Client, bucket string, acl oss.ACLType) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, sc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                err := client.SetBucketACL(bucket, acl)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return BucketError{err, bucket}
                }</span>
        }
}

func (sc *SetACLCommand) setObjectACL(bucket *oss.Bucket, cloudURL CloudURL, versionId string) error <span class="cov0" title="0">{
        if cloudURL.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("set object acl invalid url: %s, object empty, if you mean set bucket acl, you should use --bucket option", sc.command.args[0])
        }</span>

        <span class="cov0" title="0">acl, err := sc.getACL(objectACL, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sc.ossSetObjectACLRetry(bucket, cloudURL.object, acl, versionId)</span>
}

func (sc *SetACLCommand) ossSetObjectACLRetry(bucket *oss.Bucket, object string, acl oss.ACLType, versionId string) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, sc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                var options []oss.Option
                if len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                        options = append(options, oss.VersionId(versionId))
                }</span>
                <span class="cov0" title="0">err := bucket.SetObjectACL(object, acl, options...)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, object}
                }</span>
        }
}

func (sc *SetACLCommand) batchSetObjectACL(bucket *oss.Bucket, cloudURL CloudURL, force bool, routines int64) error <span class="cov0" title="0">{
        if !force </span><span class="cov0" title="0">{
                var val string
                fmt.Printf("Do you really mean to recursivlly set acl on objects of %s(y or N)? ", sc.command.args[0])
                if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                        fmt.Println("operation is canceled.")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">acl, err := sc.getACL(objectACL, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sc.saOption.ctnu = true
        outputDir, _ := GetString(OptionOutputDir, sc.command.options)

        // init reporter
        if sc.saOption.reporter, err = GetReporter(sc.saOption.ctnu, outputDir, commandLine); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sc.saOption.reporter.Clear()

        return sc.setObjectACLs(bucket, cloudURL, acl, force, routines)</span>
}

func (sc *SetACLCommand) setObjectACLs(bucket *oss.Bucket, cloudURL CloudURL, acl oss.ACLType, force bool, routines int64) error <span class="cov0" title="0">{
        // producer list objects
        // consumer set acl
        chObjects := make(chan string, ChannelBuf)
        chError := make(chan error, routines+1)
        chListError := make(chan error, 1)
        go sc.command.objectStatistic(bucket, cloudURL, &amp;sc.monitor, sc.filters)
        go sc.command.objectProducer(bucket, cloudURL, chObjects, chListError, sc.filters)
        for i := 0; int64(i) &lt; routines; i++ </span><span class="cov0" title="0">{
                go sc.setObjectACLConsumer(bucket, acl, chObjects, chError)
        }</span>

        <span class="cov0" title="0">return sc.waitRoutinueComplete(chError, chListError, routines)</span>
}

func (sc *SetACLCommand) setObjectACLConsumer(bucket *oss.Bucket, acl oss.ACLType, chObjects &lt;-chan string, chError chan&lt;- error) <span class="cov0" title="0">{
        for object := range chObjects </span><span class="cov0" title="0">{
                err := sc.setObjectACLWithReport(bucket, object, acl)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        if !sc.saOption.ctnu </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        <span class="cov0" title="0">chError &lt;- nil</span>
}

func (sc *SetACLCommand) setObjectACLWithReport(bucket *oss.Bucket, object string, acl oss.ACLType) error <span class="cov0" title="0">{
        err := sc.ossSetObjectACLRetry(bucket, object, acl, "")
        sc.command.updateMonitor(err, &amp;sc.monitor)
        msg := fmt.Sprintf("set acl on %s", CloudURLToString(bucket.BucketName, object))
        sc.command.report(msg, err, &amp;sc.saOption)
        return err
}</span>

func (sc *SetACLCommand) waitRoutinueComplete(chError, chListError &lt;-chan error, routines int64) error <span class="cov0" title="0">{
        completed := 0
        var ferr error
        for int64(completed) &lt;= routines </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-chListError:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">completed++</span>
                case err := &lt;-chError:<span class="cov0" title="0">
                        if err == nil </span><span class="cov0" title="0">{
                                completed++
                        }</span> else<span class="cov0" title="0"> {
                                ferr = err
                                if !sc.saOption.ctnu </span><span class="cov0" title="0">{
                                        fmt.Printf(sc.monitor.progressBar(true, errExit))
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return sc.formatResultPrompt(ferr)</span>
}

func (sc *SetACLCommand) formatResultPrompt(err error) error <span class="cov0" title="0">{
        fmt.Printf(sc.monitor.progressBar(true, normalExit))
        if err != nil &amp;&amp; sc.saOption.ctnu </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package lib

import (
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var headerOptionMap = map[string]interface{}{
        oss.HTTPHeaderContentType:                  oss.ContentType,
        oss.HTTPHeaderCacheControl:                 oss.CacheControl,
        oss.HTTPHeaderContentDisposition:           oss.ContentDisposition,
        oss.HTTPHeaderContentEncoding:              oss.ContentEncoding,
        oss.HTTPHeaderExpires:                      oss.Expires,
        oss.HTTPHeaderAcceptEncoding:               oss.AcceptEncoding,
        oss.HTTPHeaderOssServerSideEncryption:      oss.ServerSideEncryption,
        oss.HTTPHeaderOssObjectACL:                 oss.ObjectACL,
        oss.HTTPHeaderOrigin:                       oss.Origin,
        oss.HTTPHeaderOssStorageClass:              oss.ObjectStorageClass,
        oss.HTTPHeaderOssServerSideEncryptionKeyID: oss.ServerSideEncryptionKeyID,
        oss.HTTPHeaderOssServerSideDataEncryption:  oss.ServerSideDataEncryption,
        oss.HTTPHeaderSSECAlgorithm:                oss.SSECAlgorithm,
        oss.HTTPHeaderSSECKey:                      oss.SSECKey,
        oss.HTTPHeaderSSECKeyMd5:                   oss.SSECKeyMd5,
}

func formatHeaderString(hopMap map[string]interface{}, sep string) string <span class="cov4" title="4">{
        str := ""
        for header := range hopMap </span><span class="cov10" title="60">{
                if header == oss.HTTPHeaderExpires </span><span class="cov4" title="4">{
                        str += header + fmt.Sprintf("(time.RFC3339: %s)", time.RFC3339) + sep
                }</span> else<span class="cov9" title="56"> {
                        str += header + sep
                }</span>
        }
        <span class="cov4" title="4">if len(str) &gt;= len(sep) </span><span class="cov4" title="4">{
                str = str[:len(str)-len(sep)]
        }</span>
        <span class="cov4" title="4">return str</span>
}

func fetchHeaderOptionMap(hopMap map[string]interface{}, name string) (interface{}, error) <span class="cov0" title="0">{
        for header, f := range hopMap </span><span class="cov0" title="0">{
                if strings.ToLower(name) == strings.ToLower(header) </span><span class="cov0" title="0">{
                        return f, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported header: %s, please check", name)</span>
}

func getOSSOption(hopMap map[string]interface{}, name string, param string) (oss.Option, error) <span class="cov0" title="0">{
        if f, err := fetchHeaderOptionMap(hopMap, name); err == nil </span><span class="cov0" title="0">{
                switch f.(type) </span>{
                case func(string) oss.Option:<span class="cov0" title="0">
                        return f.(func(string) oss.Option)(param), nil</span>
                case func(oss.ACLType) oss.Option:<span class="cov0" title="0">
                        return f.(func(oss.ACLType) oss.Option)(oss.ACLType(param)), nil</span>
                case func(t time.Time) oss.Option:<span class="cov0" title="0">
                        val, err := time.Parse(http.TimeFormat, param)
                        if err != nil </span><span class="cov0" title="0">{
                                val, err = time.Parse(time.RFC3339, param)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">return f.(func(time.Time) oss.Option)(val), nil</span>
                case func(oss.StorageClassType) oss.Option:<span class="cov0" title="0">
                        return f.(func(oss.StorageClassType) oss.Option)(oss.StorageClassType(param)), nil</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("error option type, internal error")</span>
                }
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported header: %s, please check", name)</span>
}

var specChineseSetMeta = SpecText{

        synopsisText: "设置已上传的objects的元信息",

        paramText: "cloud_url [meta] [options]",

        syntaxText: ` 
    ossutil set-meta oss://bucket[/prefix] [header:value#header:value...] [--update] [--delete] [-r] [-f] [-c file] [--version-id versionId]
`,

        detailHelpText: ` 
    该命令可设置或者更新或者删除指定objects的meta信息。当指定--recursive选项时，ossutil
    获取所有与指定cloud_url匹配的objects，批量设置这些objects的meta，否则，设置指定的单个
    object的元信息，如果该object不存在，ossutil会报错。

    （1）设置全量值：如果用户未指定--update选项和--delete选项，ossutil会设置指定objects的
        meta为用户输入的[header:value#header:value...]。当缺失[header:value#header:value...]
        信息时，相当于删除全部meta信息（对于不可删除的headers，即：不以` + oss.HTTPHeaderOssMetaPrefix + `开头的headers，
        其值不会改变）。此时ossutil会进入交互模式并要求用户确认meta信息。

    （2）更新meta：如果用户设置--update选项，ossutil会更新指定objects的指定header为输入
        的value值，其中value可以为空，指定objects的其他meta信息不会改变。此时不支持--delete
        选项。

    （3）删除meta：如果用户设置--delete选项，ossutil会删除指定objects的指定header（对于不可
        删除的headers，即：不以` + oss.HTTPHeaderOssMetaPrefix + `开头的headers，该选项不起作用），该此时value必须
        为空（header:或者header），指定objects的其他meta信息不会改变。此时不支持--update选项。

    该命令不支持bucket的meta设置，需要设置bucket的meta信息，请使用bucket相关操作。
    查看bucket或者object的meta信息，请使用stat命令。

Headers:

    可选的header列表如下：
        ` + formatHeaderString(headerOptionMap, "\n        ") + `
        以及以` + oss.HTTPHeaderOssMetaPrefix + `开头的header

    注意：header不区分大小写，但value区分大小写。

用法：

    该命令有两种用法：

    1) ossutil set-meta oss://bucket/object [header:value#header:value...] [--update] [--delete] [-f] [--version-id versionId]
        如果未指定--recursive选项，ossutil设置指定的单个object的meta信息，此时请确保输入
    的cloud_url精确指定了想要设置meta的object，当object不存在时会报错。如果指定了--force
    选项，则不会进行询问提示。如果用户未输入[header:value#header:value...]，相当于删除
    object的所有meta。
        --update选项和--delete选项的用法参考上文。

    2) ossutil set-meta oss://bucket[/prefix] [header:value#header:value...] -r [--update] [--delete] [-f]
        如果指定了--recursive选项，ossutil会查找所有前缀匹配cloud_url的objects，批量设置
    这些objects的meta信息。当一个object操作出现错误时会将出错object的错误信息记录到report
    文件，并继续操作其他object，成功操作的object信息将不会被记录到report文件中（更多信息
    见cp命令的帮助）。
        如果指定了--include/--exclude选项，ossutil会查找所有匹配pattern的objects，批量设置。
        --include和--exclude选项说明，请参考cp命令帮助。
        如果--force选项被指定，则不会进行询问提示。
        --update选项和--delete选项的用法参考上文。
`,

        sampleText: ` 
    (1)ossutil set-meta oss://bucket1/obj1 Cache-Control:no-cache#Content-Encoding:gzip#X-Oss-Meta-a:b
        设置obj1的Cache-Control，Content-Encoding和X-Oss-Meta-a头域

    (2)ossutil set-meta oss://bucket1/o X-Oss-Meta-empty:#Content-Type:plain/text --update -r
        批量更新以o开头的objects的X-Oss-Meta-empty和Content-Type头域

    (3)ossutil set-meta oss://bucket1/ X-Oss-Meta-empty:#Content-Type:plain/text --update -r --include "*.jpg"
        批量更新后缀为.jpg的objects的X-Oss-Meta-empty和Content-Type头域

    (4)ossutil set-meta oss://bucket1/o X-Oss-Meta-empty:#Content-Type:plain/text --update -r --exclude "*.jpg"
        批量更新以o开头后缀为.jpg的objects的X-Oss-Meta-empty和Content-Type头域

    (5)ossutil set-meta oss://bucket1/obj1 X-Oss-Meta-delete --delete
        删除obj1的X-Oss-Meta-delete头域

    (6)ossutil set-meta oss://bucket/o -r
        批量设置以o开头的objects的meta为空

    (7)ossutil set-meta oss://bucket1/%e4%b8%ad%e6%96%87 X-Oss-Meta-delete --delete --encoding-type url
        删除oss://bucket1/中文的X-Oss-Meta-delete头域

    (6)ossutil set-meta oss://bucket1/obj1 X-Oss-Meta-delete --delete --version-id versionId
        删除指定版本obj1的X-Oss-Meta-delete头域，并生成最新版本
`,
}

var specEnglishSetMeta = SpecText{

        synopsisText: "set metadata on already uploaded objects",

        paramText: "cloud_url [meta] [options]",

        syntaxText: ` 
    ossutil set-meta oss://bucket[/prefix] [header:value#header:value...] [--update] [--delete] [-r] [-f] [-c file] [--version-id versionId]
`,

        detailHelpText: ` 
    The command can be used to set, update or delete the specified objects' meta data. 
    If --recursive option is specified, ossutil find all matching objects and batch set 
    meta on these objects, else, ossutil set meta on single object, if the object not 
    exist, error happens. 

    (1) Set full meta: If --update option and --delete option is not specified, ossutil 
        will set the meta of the specified objects to [header:value#header:value...], what
        user inputs. If [header:value#header:value...] is missing, it means clear the meta 
        data of the specified objects(to those headers which can not be deleted, that is, 
        the headers do not start with: ` + oss.HTTPHeaderOssMetaPrefix + `, the value will not be changed), at the 
        time ossutil will ask user to confirm the input.

    (2) Update meta: If --update option is specified, ossutil will update the specified 
        headers of objects to the values that user inputs(the values can be empty), other 
        meta data of the specified objects will not be changed. --delete option is not 
        supported in the usage. 

    (3) Delete meta: If --delete option is specified, ossutil will delete the specified 
        headers of objects that user inputs(to those headers which can not be deleted, 
        that is, the headers do not start with: ` + oss.HTTPHeaderOssMetaPrefix + `, the value will not be changed), 
        in this usage the value must be empty(like header: or header), other meta data 
        of the specified objects will not be changed. --update option is not supported 
        in the usage.

    The meta data of bucket can not be setted by the command, please use other commands. 
    User can use stat command to check the meta information of bucket or objects.

Headers:

    ossutil supports following headers:
        ` + formatHeaderString(headerOptionMap, "\n        ") + `
        and headers starts with: ` + oss.HTTPHeaderOssMetaPrefix + `

    Warning: headers are case-insensitive, but value are case-sensitive.

Usage:

    There are two usages:

    1) ossutil set-meta oss://bucket/object [header:value#header:value...] [--update] [--delete] [-f] [--version-id versionId]
        If --recursive option is not specified, ossutil set meta on the specified single 
    object. In the usage, please make sure cloud_url exactly specified the object you want to 
    set meta on, if object not exist, error occurs. If --force option is specified, ossutil 
    will not show prompt question. 
        The usage of --update option and --delete option is showed in detailHelpText. 

    2) ossutil set-meta oss://bucket[/prefix] [header:value#header:value...] -r [--update] [--delete] [-f]
        If --recursive option is specified, ossutil will search for prefix-matching objects 
    and set meta on these objects. If an error occurs, ossutil will record the error message 
    to report file, and ossutil will continue to attempt to set acl on the remaining objects(
    more information see help of cp command). 
        If --include/--exclude option is specified, ossutil will search for pattern-matching objects and 
    set meta on those objects. 
            --include and --exclude option, please refer cp command help.
        If --force option is specified, ossutil will not show prompt question.
        The usage of --update option and --delete option is showed in detailHelpText.
`,

        sampleText: ` 
    (1)ossutil set-meta oss://bucket1/obj1 Cache-Control:no-cache#Content-Encoding:gzip#X-Oss-Meta-a:b
        Set Cache-Control, Content-Encoding and X-Oss-Meta-a header for obj1

    (2)ossutil set-meta oss://bucket1/o X-Oss-Meta-empty:#Content-Type:plain/text -u -r
        Batch update X-Oss-Meta-empty and Content-Type header on objects that start with o

    (3)ossutil set-meta oss://bucket1/ X-Oss-Meta-empty:#Content-Type:plain/text --update -r --include "*.jpg"
        Batch update X-Oss-Meta-empty and Content-Type header on objects ending with .jpg

    (4)ossutil set-meta oss://bucket1/o X-Oss-Meta-empty:#Content-Type:plain/text --update -r --exclude ".jpg"
        Batch update X-Oss-Meta-empty and Content-Type header on objects starting with o and ending with .jpg

    (5)ossutil set-meta oss://bucket1/obj1 X-Oss-Meta-delete -d
        Delete X-Oss-Meta-delete header of obj1 

    (6)ossutil set-meta oss://bucket/o -r
        Batch set the meta of objects that start with o to empty

    (7)ossutil set-meta oss://bucket1/%e4%b8%ad%e6%96%87 X-Oss-Meta-delete --delete --encoding-type url
        Delete X-Oss-Meta-delete header of oss://bucket1/中文
    
        (8)ossutil set-meta oss://bucket1/obj1 X-Oss-Meta-delete --delete --version-id versionId
        Delete X-Oss-Meta-delete header of a specific version of obj1，and generate the latest version obj1
`,
}

// SetMetaCommand is the command set meta for object
type SetMetaCommand struct {
        monitor  Monitor //Put first for atomic op on some fileds
        command  Command
        smOption batchOptionType
        filters  []filterOptionType
}

var setMetaCommand = SetMetaCommand{
        command: Command{
                name:        "set-meta",
                nameAlias:   []string{"setmeta", "set_meta"},
                minArgc:     1,
                maxArgc:     2,
                specChinese: specChineseSetMeta,
                specEnglish: specEnglishSetMeta,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionRecursion,
                        OptionUpdate,
                        OptionDelete,
                        OptionForce,
                        OptionEncodingType,
                        OptionInclude,
                        OptionExclude,
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionRoutines,
                        OptionLanguage,
                        OptionOutputDir,
                        OptionLogLevel,
                        OptionVersionId,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (sc *SetMetaCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return sc.command.formatHelpForWhole()
}</span>

func (sc *SetMetaCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return sc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (sc *SetMetaCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return sc.command.Init(args, options, sc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (sc *SetMetaCommand) RunCommand() error <span class="cov0" title="0">{
        sc.monitor.init("Setted meta on")

        isUpdate, _ := GetBool(OptionUpdate, sc.command.options)
        isDelete, _ := GetBool(OptionDelete, sc.command.options)
        recursive, _ := GetBool(OptionRecursion, sc.command.options)
        force, _ := GetBool(OptionForce, sc.command.options)
        routines, _ := GetInt(OptionRoutines, sc.command.options)
        language, _ := GetString(OptionLanguage, sc.command.options)
        language = strings.ToLower(language)
        encodingType, _ := GetString(OptionEncodingType, sc.command.options)
        versionId, _ := GetString(OptionVersionId, sc.command.options)

        var res bool
        res, sc.filters = getFilter(os.Args)
        if !res </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude does not support format containing dir info")
        }</span>

        <span class="cov0" title="0">if !recursive &amp;&amp; len(sc.filters) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude only work with --recursive")
        }</span>

        <span class="cov0" title="0">if recursive &amp;&amp; len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--version-id only work on single object")
        }</span>

        <span class="cov0" title="0">cloudURL, err := CloudURLFromString(sc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = sc.checkArgs(cloudURL, recursive, isUpdate, isDelete); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !sc.confirmOP(recursive, force) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := sc.checkOption(isUpdate, isDelete, force, language); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">str, err := sc.getMetaData(force, language)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">headers, err := sc.command.parseHeaders(str, isDelete)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := sc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !recursive </span><span class="cov0" title="0">{
                return sc.setObjectMeta(bucket, cloudURL.object, headers, isUpdate, isDelete, versionId)
        }</span>
        <span class="cov0" title="0">return sc.batchSetObjectMeta(bucket, cloudURL, headers, isUpdate, isDelete, force, routines)</span>
}

func (sc *SetMetaCommand) checkArgs(cloudURL CloudURL, recursive, isUpdate, isDelete bool) error <span class="cov0" title="0">{
        if cloudURL.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", sc.command.args[0])
        }</span>
        <span class="cov0" title="0">if !recursive &amp;&amp; cloudURL.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("set object meta invalid cloud url: %s, object empty. Set bucket meta is not supported, if you mean batch set meta on objects, please use --recursive", sc.command.args[0])
        }</span>
        <span class="cov0" title="0">if isUpdate &amp;&amp; isDelete </span><span class="cov0" title="0">{
                return fmt.Errorf("--update option and --delete option are not supported for %s at the same time, please check", sc.command.args[0])
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sc *SetMetaCommand) checkOption(isUpdate, isDelete, force bool, language string) error <span class="cov0" title="0">{
        if !isUpdate &amp;&amp; !isDelete &amp;&amp; !force </span><span class="cov0" title="0">{
                if language == LEnglishLanguage </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: --update option means update the specified header, --delete option means delete the specified header, miss both options means update the whole meta info, continue to update the whole meta info(y or N)? ")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("警告：--update选项更新指定的header，--delete选项删除指定的header，两者同时缺失会更改object的全量meta信息，请确认是否要更改全量meta信息(y or N)? ")
                }</span>
                <span class="cov0" title="0">var str string
                if _, err := fmt.Scanln(&amp;str); err != nil || (strings.ToLower(str) != "yes" &amp;&amp; strings.ToLower(str) != "y") </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation is canceled")
                }</span>
                <span class="cov0" title="0">fmt.Println("")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (sc *SetMetaCommand) confirmOP(recursive, force bool) bool <span class="cov0" title="0">{
        if recursive &amp;&amp; !force </span><span class="cov0" title="0">{
                var val string
                fmt.Printf("Do you really mean to recursivlly set meta on objects of %s(y or N)? ", sc.command.args[0])
                if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                        fmt.Println("operation is canceled.")
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (sc *SetMetaCommand) getMetaData(force bool, language string) (string, error) <span class="cov0" title="0">{
        if len(sc.command.args) &gt; 1 </span><span class="cov0" title="0">{
                return strings.TrimSpace(sc.command.args[1]), nil
        }</span>

        <span class="cov0" title="0">if force </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">if language == LEnglishLanguage </span><span class="cov0" title="0">{
                fmt.Printf("Do you really mean the empty meta(or forget to input header:value pair)? \nEnter yes(y) to continue with empty meta, enter no(n) to show supported headers, other inputs will cancel operation: ")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("你是否确定你想设置的meta信息为空（或者忘记了输入header:value对）? \n输入yes(y)使用空meta继续设置，输入no(n)来展示支持的headers，其他输入将取消操作：")
        }</span>
        <span class="cov0" title="0">var str string
        if _, err := fmt.Scanln(&amp;str); err != nil || (strings.ToLower(str) != "yes" &amp;&amp; strings.ToLower(str) != "y" &amp;&amp; strings.ToLower(str) != "no" &amp;&amp; strings.ToLower(str) != "n") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unknown input, operation is canceled")
        }</span>
        <span class="cov0" title="0">if strings.ToLower(str) == "yes" || strings.ToLower(str) == "y" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">if language == LEnglishLanguage </span><span class="cov0" title="0">{
                fmt.Printf("\nSupported headers:\n    %s\n    And the headers start with: \"%s\"\n\nPlease enter the header:value#header:value... pair you want to set: ", formatHeaderString(headerOptionMap, "\n    "), oss.HTTPHeaderOssMetaPrefix)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n支持的headers:\n    %s\n    以及以\"%s\"开头的headers\n\n请输入你想设置的header:value#header:value...：", formatHeaderString(headerOptionMap, "\n    "), oss.HTTPHeaderOssMetaPrefix)
        }</span>
        <span class="cov0" title="0">if _, err := fmt.Scanln(&amp;str); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("meta empty, please check, operation is canceled")
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(str), nil</span>
}

func (cmd *Command) parseHeaders(str string, isDelete bool) (map[string]string, error) <span class="cov0" title="0">{
        if str == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">headers := map[string]string{}
        sli := strings.Split(str, "#")
        for _, s := range sli </span><span class="cov0" title="0">{
                pair := strings.SplitN(s, ":", 2)
                name := pair[0]
                value := ""
                if len(pair) &gt; 1 </span><span class="cov0" title="0">{
                        value = pair[1]
                }</span>
                <span class="cov0" title="0">if isDelete &amp;&amp; value != "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("delete meta for object do no support value for header:%s, please set value:%s to empty", name, value)
                }</span>
                <span class="cov0" title="0">if _, err := fetchHeaderOptionMap(headerOptionMap, name); err != nil &amp;&amp; !strings.HasPrefix(strings.ToLower(name), strings.ToLower(oss.HTTPHeaderOssMetaPrefix)) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unsupported header:%s, please try \"help %s\" to see supported headers", name, cmd.name)
                }</span>
                <span class="cov0" title="0">headers[name] = value</span>
        }
        <span class="cov0" title="0">return headers, nil</span>
}

func (sc *SetMetaCommand) setObjectMeta(bucket *oss.Bucket, object string, headers map[string]string, isUpdate, isDelete bool, versionId string) error <span class="cov0" title="0">{
        allheaders := headers
        if isUpdate || isDelete </span><span class="cov0" title="0">{
                var options []oss.Option
                if len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                        options = append(options, oss.VersionId(versionId))
                }</span>

                // get object meta
                <span class="cov0" title="0">props, err := sc.command.ossGetObjectStatRetry(bucket, object, options...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // get object acl
                <span class="cov0" title="0">objectACL, err := bucket.GetObjectACL(object, options...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">props.Set(StatACL, objectACL.ACL)

                // merge
                allheaders = sc.mergeHeader(props, headers, isUpdate, isDelete)</span>
        }

        <span class="cov0" title="0">options, err := sc.command.getOSSOptions(headerOptionMap, allheaders)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, oss.VersionId(versionId))
        }</span>
        <span class="cov0" title="0">return sc.ossSetObjectMetaRetry(bucket, object, options...)</span>
}

func (sc *SetMetaCommand) mergeHeader(props http.Header, headers map[string]string, isUpdate, isDelete bool) map[string]string <span class="cov0" title="0">{
        allheaders := map[string]string{}
        for name := range props </span><span class="cov0" title="0">{
                if _, err := fetchHeaderOptionMap(headerOptionMap, name); err == nil || strings.HasPrefix(strings.ToLower(name), strings.ToLower(oss.HTTPHeaderOssMetaPrefix)) </span><span class="cov0" title="0">{
                        allheaders[strings.ToLower(name)] = props.Get(name)
                }</span>
                <span class="cov0" title="0">if strings.ToLower(name) == strings.ToLower(StatACL) </span><span class="cov0" title="0">{
                        allheaders[strings.ToLower(oss.HTTPHeaderOssObjectACL)] = props.Get(name)
                }</span>
        }
        <span class="cov0" title="0">if isUpdate </span><span class="cov0" title="0">{
                for name, val := range headers </span><span class="cov0" title="0">{
                        allheaders[strings.ToLower(name)] = val
                }</span>
        }
        <span class="cov0" title="0">if isDelete </span><span class="cov0" title="0">{
                for name := range headers </span><span class="cov0" title="0">{
                        delete(allheaders, strings.ToLower(name))
                }</span>
        }
        <span class="cov0" title="0">return allheaders</span>
}

func (sc *SetMetaCommand) ossSetObjectMetaRetry(bucket *oss.Bucket, object string, options ...oss.Option) error <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, sc.command.options)
        cpOptions := append(options, oss.MetadataDirective(oss.MetaReplace))
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                _, err := bucket.CopyObject(object, object, cpOptions...)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucket.BucketName, object}
                }</span>
        }
}

func (sc *SetMetaCommand) batchSetObjectMeta(bucket *oss.Bucket, cloudURL CloudURL, headers map[string]string, isUpdate, isDelete, force bool, routines int64) error <span class="cov0" title="0">{
        sc.smOption.ctnu = true
        outputDir, _ := GetString(OptionOutputDir, sc.command.options)

        // init reporter
        var err error
        if sc.smOption.reporter, err = GetReporter(sc.smOption.ctnu, outputDir, commandLine); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sc.smOption.reporter.Clear()

        return sc.setObjectMetas(bucket, cloudURL, headers, isUpdate, isDelete, force, routines)</span>
}

func (sc *SetMetaCommand) setObjectMetas(bucket *oss.Bucket, cloudURL CloudURL, headers map[string]string, isUpdate, isDelete, force bool, routines int64) error <span class="cov0" title="0">{
        // producer list objects
        // consumer set meta
        chObjects := make(chan string, ChannelBuf)
        chError := make(chan error, routines+1)
        chListError := make(chan error, 1)
        go sc.command.objectStatistic(bucket, cloudURL, &amp;sc.monitor, sc.filters)
        go sc.command.objectProducer(bucket, cloudURL, chObjects, chListError, sc.filters)

        for i := 0; int64(i) &lt; routines; i++ </span><span class="cov0" title="0">{
                go sc.setObjectMetaConsumer(bucket, headers, isUpdate, isDelete, chObjects, chError)
        }</span>

        <span class="cov0" title="0">return sc.waitRoutinueComplete(chError, chListError, routines)</span>
}

func (sc *SetMetaCommand) setObjectMetaConsumer(bucket *oss.Bucket, headers map[string]string, isUpdate, isDelete bool, chObjects &lt;-chan string, chError chan&lt;- error) <span class="cov0" title="0">{
        for object := range chObjects </span><span class="cov0" title="0">{
                err := sc.setObjectMetaWithReport(bucket, object, headers, isUpdate, isDelete)
                if err != nil </span><span class="cov0" title="0">{
                        chError &lt;- err
                        if !sc.smOption.ctnu </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        <span class="cov0" title="0">chError &lt;- nil</span>
}

func (sc *SetMetaCommand) setObjectMetaWithReport(bucket *oss.Bucket, object string, headers map[string]string, isUpdate, isDelete bool) error <span class="cov0" title="0">{
        err := sc.setObjectMeta(bucket, object, headers, isUpdate, isDelete, "")
        sc.command.updateMonitor(err, &amp;sc.monitor)
        msg := fmt.Sprintf("set meta on %s", CloudURLToString(bucket.BucketName, object))
        sc.command.report(msg, err, &amp;sc.smOption)
        return err
}</span>

func (sc *SetMetaCommand) waitRoutinueComplete(chError, chListError &lt;-chan error, routines int64) error <span class="cov0" title="0">{
        completed := 0
        var ferr error
        for int64(completed) &lt;= routines </span><span class="cov0" title="0">{
                select </span>{
                case err := &lt;-chListError:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">completed++</span>
                case err := &lt;-chError:<span class="cov0" title="0">
                        if err == nil </span><span class="cov0" title="0">{
                                completed++
                        }</span> else<span class="cov0" title="0"> {
                                ferr = err
                                if !sc.smOption.ctnu </span><span class="cov0" title="0">{
                                        fmt.Printf(sc.monitor.progressBar(true, errExit))
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return sc.formatResultPrompt(ferr)</span>
}

func (sc *SetMetaCommand) formatResultPrompt(err error) error <span class="cov0" title="0">{
        fmt.Printf(sc.monitor.progressBar(true, normalExit))
        if err != nil &amp;&amp; sc.smOption.ctnu </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package lib

import (
        "fmt"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseSignurl = SpecText{

        synopsisText: "生成object下载链接",

        paramText: "cloud_url [meta] [options]",

        syntaxText: ` 
    ossutil sign cloud_url [--timeout t] [--version-id versionId] [--trafic-limit limitSpeed] [--disable-encode-slash] [--payer requester]
`,

        detailHelpText: ` 
    该命令签名用户指定的cloud_url，生成经过签名的url可供第三方用户访问object，其中cloud_url
    必须为形如：oss://bucket/object的cloud_url，bucket和object不可缺少。通过--timeout选项指
    定url的过期时间，默认为60s。通过--version-id选项指定版本号。

用法：

    ossutil sign oss://bucket/object [--timeout t] [--version-id versionId] [--trafic-limit limitSpeed] [--disable-encode-slash] [--payer requester]
`,

        sampleText: ` 
    ossutil sign oss://bucket1/object1
        生成oss://bucket1/object1的签名url，超时时间60s

    ossutil sign oss://bucket1/object1 --timeout 300
        生成oss://bucket1/object1的签名url，超时时间300s

    ossutil sign oss://tempb1/test%20a%2Bb' --encoding-type url
        生成oss://tempb1/'test a+b'的签名url，超时时间60s

    ossutil sign oss://bucket1/object1 --version-id versionId
        生成指定版本的 oss://bucket1/object1的签名url，超时时间60s
    
    ossutil sign oss://bucket1/object1 --trafic-limit 8388608
        生成oss://bucket1/object1的签名url, http限速为8388608(bit/s)
    
    ossutil sign oss://bucket1/dir/object1 --disable-encode-slash
        生成oss://bucket1/dir/object1的签名url, 对path中的'/'不进行编码
    
    ossutil sign oss://bucket1/object1  --payer requester
        生成oss://bucket1/dir/object1的签名url, 使用访问者付费模式
`,
}

var specEnglishSignurl = SpecText{

        synopsisText: "Generate download link for object",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil sign cloud_url [--timeout t] [--version-id versionId] [--trafic-limit limitSpeed] [--disable-encode-slash] [--payer requester]
`,

        detailHelpText: ` 
    The command will generate signature for user specified cloud_url. This signed url can
    be used by third-party to access the object. 
    Where, cloud_url must like: oss://bucket/object
    Use --timeout to specify the expire time of url, the default is 60s.
    Use --version-id to specify the version.
    Use --trafic-limit to specify the trafic speed
    use --disable-encode-slash to specify not encoding of '/' in url path section
    use --payer to specify request payment

Usage:

    ossutil sign oss://bucket/object [--timeout t] [--version-id versionId] [--trafic-limit limitSpeed] [--disable-encode-slash] [--payer requester]
`,

        sampleText: ` 
    ossutil sign oss://bucket1/object1
        Generate the signature of oss://bucket1/object1 with expire time 60s

    ossutil sign oss://bucket1/object1 --timeout 300
        Generate the signature of oss://bucket1/object1 with expire time 300s

    ossutil sign oss://tempb1/test%20a%2Bb' --encoding-type url
        Generate the signature of oss://tempb1/'test a+b' with expire time 60s

    ossutil sign oss://bucket1/object1 --version-id versionId
        Generate the signature of a specific version of oss://bucket1/object1 with  expire time 60s
    
    ossutil sign oss://bucket1/object1  --trafic-limit 8388608
        Generate the signature of oss://bucket1/object1, http limit speed is 8388608(bit/s)
    
    ossutil sign oss://bucket1/dir/object1 --disable-encode-slash
        Generate the signature of oss://bucket1/dir/object1,no encoding of '/' in url path section
    
    ossutil sign oss://bucket1/object1  --payer requester
        Generate the signature of oss://bucket1/object1, use requester payment
`,
}

// SignurlCommand definition
type SignurlCommand struct {
        command Command
        signUrl string
}

var signURLCommand = SignurlCommand{
        command: Command{
                name:        "sign",
                nameAlias:   []string{},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseSignurl,
                specEnglish: specEnglishSignurl,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionTimeout,
                        OptionEncodingType,
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionLogLevel,
                        OptionVersionId,
                        OptionTrafficLimit,
                        OptionDisableEncodeSlash,
                        OptionRequestPayer,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (sc *SignurlCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return sc.command.formatHelpForWhole()
}</span>

func (sc *SignurlCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return sc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (sc *SignurlCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return sc.command.Init(args, options, sc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (sc *SignurlCommand) RunCommand() error <span class="cov0" title="0">{
        encodingType, _ := GetString(OptionEncodingType, sc.command.options)
        cloudURL, err := ObjectURLFromString(sc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">timeout, _ := GetInt(OptionTimeout, sc.command.options)
        versionId, _ := GetString(OptionVersionId, sc.command.options)
        trafficLimit, getErr := GetInt(OptionTrafficLimit, sc.command.options)
        if getErr == nil &amp;&amp; trafficLimit &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Option value of --trafic-limit must be greater than 0")
        }</span>

        <span class="cov0" title="0">payer, _ := GetString(OptionRequestPayer, sc.command.options)
        if payer != "" &amp;&amp; payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid request payer: %s, please check", payer)
        }</span>

        <span class="cov0" title="0">bucket, err := sc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var options []oss.Option
        if len(versionId) &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, oss.VersionId(versionId))
        }</span>

        <span class="cov0" title="0">if trafficLimit &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, oss.TrafficLimitParam(trafficLimit))
        }</span>

        <span class="cov0" title="0">if payer != "" </span><span class="cov0" title="0">{
                options = append(options, oss.RequestPayerParam(oss.PayerType(payer)))
        }</span>

        <span class="cov0" title="0">str, err := sc.ossSign(bucket, cloudURL.object, timeout, options...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sc.signUrl = str

        fmt.Println(str)
        return nil</span>
}

func (sc *SignurlCommand) ossSign(bucket *oss.Bucket, object string, timeout int64, options ...oss.Option) (string, error) <span class="cov0" title="0">{
        str, err := bucket.SignURL(object, oss.HTTPMethod(DefaultMethod), timeout, options...)
        if err != nil </span><span class="cov0" title="0">{
                return str, ObjectError{err, bucket.BucketName, object}
        }</span>

        <span class="cov0" title="0">disableEncodeSlash, _ := GetBool(OptionDisableEncodeSlash, sc.command.options)
        if !disableEncodeSlash </span><span class="cov0" title="0">{
                return str, nil
        }</span>

        // replace %2F with /
        <span class="cov0" title="0">urlSlice := strings.SplitN(str, "?", 2)
        headStr := strings.Replace(urlSlice[0], "%2F", "/", -1)
        if len(urlSlice) == 2 </span><span class="cov0" title="0">{
                str = headStr + "?" + urlSlice[1]
        }</span>
        <span class="cov0" title="0">return str, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package lib

import (
        "fmt"
        "net/http"
        "sort"
        "strings"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

var specChineseStat = SpecText{

        synopsisText: "显示bucket或者object的描述信息",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil stat oss://bucket[/object] [--encoding-type url] [--version-id versionId] [--payer requester] [-c file] 
`,

        detailHelpText: ` 
    该命令获取指定bucket或者object的描述信息。通过set-meta命令设置的object元信息，可以通过
    该命令查看。

用法：

    该命令有两种用法：

    1) ossutil stat oss://bucket [--encoding-type url]
        ossutil显示指定bucket的信息，包括创建时间，location，访问的外网域名，内网域名，拥
    有者，acl信息。

    2) ossutil stat oss://bucket/object [--encoding-type url] [--version-id versionId]
        ossutil显示指定object的元信息，包括文件大小，最新更新时间，etag，文件类型，acl，文
    件的自定义meta等信息。
`,

        sampleText: ` 
    ossutil stat oss://bucket1
    ossutil stat oss://bucket1/object  
    ossutil stat oss://bucket1/object --version-id versionId
    ossutil stat oss://bucket1/%e4%b8%ad%e6%96%87 --encoding-type url
    ossutil stat oss://bucket1/object --payer requester
`,
}

var specEnglishStat = SpecText{

        synopsisText: "Display meta information of bucket or objects",

        paramText: "cloud_url [options]",

        syntaxText: ` 
    ossutil stat oss://bucket[/object] [--encoding-type url]  [--version-id versionId] [--payer requester] [-c file] 
`,

        detailHelpText: ` 
    The command display the meta information of bucket or objects. The object meta information 
    setted through set-meta command, can be check by the command.

Usage：

    There are three usages:    

    1) ossutil stat oss://bucket [--encoding-type url]
        ossutil display bucket meta info, include creation date, location, extranet endpoint, 
    intranet endpoint, Owner and acl info.

    2) ossutil stat oss://bucket/object [--encoding-type url] [--version-id versionId]
        ossutil display object meta info, include file size, last modify time, etag, content-type, 
    user meta etc.
`,

        sampleText: ` 
    ossutil stat oss://bucket1
    ossutil stat oss://bucket1/object
    ossutil stat oss://bucket1/object --version-id versionId  
    ossutil stat oss://bucket1/%e4%b8%ad%e6%96%87 --encoding-type url
    ossutil stat oss://bucket1/object --payer requester
`,
}

// StatCommand is the command get bucket's or objects' meta information
type StatCommand struct {
        command       Command
        versionId     string
        commonOptions []oss.Option
}

var statCommand = StatCommand{
        command: Command{
                name:        "stat",
                nameAlias:   []string{"meta", "info"},
                minArgc:     1,
                maxArgc:     1,
                specChinese: specChineseStat,
                specEnglish: specEnglishStat,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionEncodingType,
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionLogLevel,
                        OptionVersionId,
                        OptionRequestPayer,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (sc *StatCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return sc.command.formatHelpForWhole()
}</span>

func (sc *StatCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return sc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (sc *StatCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return sc.command.Init(args, options, sc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (sc *StatCommand) RunCommand() error <span class="cov0" title="0">{
        sc.versionId, _ = GetString(OptionVersionId, sc.command.options)
        encodingType, _ := GetString(OptionEncodingType, sc.command.options)
        cloudURL, err := CloudURLFromString(sc.command.args[0], encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cloudURL.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", sc.command.args[0])
        }</span>

        <span class="cov0" title="0">payer, _ := GetString(OptionRequestPayer, sc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">sc.commonOptions = append(sc.commonOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        <span class="cov0" title="0">bucket, err := sc.command.ossBucket(cloudURL.bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cloudURL.object == "" </span><span class="cov0" title="0">{
                return sc.bucketStat(bucket, cloudURL)
        }</span>
        <span class="cov0" title="0">return sc.objectStat(bucket, cloudURL)</span>
}

func (sc *StatCommand) bucketStat(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov0" title="0">{
        // TODO: go sdk should implement GetBucketInfo
        gbar, err := sc.ossGetBucketStatRetry(bucket)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("%-18s: %s\n", StatName, gbar.BucketInfo.Name)
        fmt.Printf("%-18s: %s\n", StatLocation, gbar.BucketInfo.Location)
        fmt.Printf("%-18s: %s\n", StatCreationDate, utcToLocalTime(gbar.BucketInfo.CreationDate))
        fmt.Printf("%-18s: %s\n", StatExtranetEndpoint, gbar.BucketInfo.ExtranetEndpoint)
        fmt.Printf("%-18s: %s\n", StatIntranetEndpoint, gbar.BucketInfo.IntranetEndpoint)
        fmt.Printf("%-18s: %s\n", StatACL, gbar.BucketInfo.ACL)
        fmt.Printf("%-18s: %s\n", StatOwner, gbar.BucketInfo.Owner.ID)
        fmt.Printf("%-18s: %s\n", StatStorageClass, gbar.BucketInfo.StorageClass)
        if len(gbar.BucketInfo.RedundancyType) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("%-18s: %s\n", StatRedundancyType, gbar.BucketInfo.RedundancyType)
        }</span>
        <span class="cov0" title="0">if len(gbar.BucketInfo.SseRule.SSEAlgorithm) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("%-18s: %s\n", StatSSEAlgorithm, gbar.BucketInfo.SseRule.SSEAlgorithm)
        }</span>
        <span class="cov0" title="0">if len(gbar.BucketInfo.SseRule.KMSMasterKeyID) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("%-18s: %s\n", StatKMSMasterKeyID, gbar.BucketInfo.SseRule.KMSMasterKeyID)
        }</span>
        <span class="cov0" title="0">if len(gbar.BucketInfo.SseRule.KMSDataEncryption) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("%-18s: %s\n", StatKMSDataEncryption, gbar.BucketInfo.SseRule.KMSDataEncryption)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sc *StatCommand) ossGetBucketStatRetry(bucket *oss.Bucket) (oss.GetBucketInfoResult, error) <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, sc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                gbar, err := bucket.Client.GetBucketInfo(bucket.BucketName, sc.commonOptions...)
                if err == nil </span><span class="cov0" title="0">{
                        return gbar, err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return gbar, BucketError{err, bucket.BucketName}
                }</span>
        }
}

func (sc *StatCommand) objectStat(bucket *oss.Bucket, cloudURL CloudURL) error <span class="cov0" title="0">{
        // acl info
        goar, err := sc.ossGetObjectACLRetry(bucket, cloudURL.object)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // normal info
        <span class="cov0" title="0">statOptions := []oss.Option{}
        if len(sc.versionId) &gt; 0 </span><span class="cov0" title="0">{
                statOptions = append(statOptions, oss.VersionId(sc.versionId))
        }</span>
        <span class="cov0" title="0">statOptions = append(statOptions, sc.commonOptions...)

        props, err := sc.command.ossGetObjectStatRetry(bucket, cloudURL.object, statOptions...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sortNames := []string{}
        attrMap := map[string]string{}
        maxNameLen := 0
        for name := range props </span><span class="cov0" title="0">{
                if len(name) &gt; maxNameLen </span><span class="cov0" title="0">{
                        maxNameLen = len(name)
                }</span>

                <span class="cov0" title="0">ln := strings.ToLower(name)
                if ln != strings.ToLower(oss.HTTPHeaderDate) &amp;&amp;
                        ln != strings.ToLower(oss.HTTPHeaderOssRequestID) &amp;&amp;
                        ln != strings.ToLower(oss.HTTPHeaderServer) &amp;&amp;
                        ln != "x-oss-server-time" &amp;&amp;
                        ln != "connection" </span><span class="cov0" title="0">{
                        sortNames = append(sortNames, name)
                        attrMap[name] = props.Get(name)
                }</span>
        }

        <span class="cov0" title="0">sortNames = append(sortNames, "Owner")
        sortNames = append(sortNames, "ACL")
        attrMap[StatOwner] = goar.Owner.ID
        attrMap[StatACL] = goar.ACL
        if lm, err := time.Parse(http.TimeFormat, attrMap[StatLastModified]); err == nil </span><span class="cov0" title="0">{
                attrMap[StatLastModified] = fmt.Sprintf("%s", utcToLocalTime(lm.UTC()))
        }</span>

        <span class="cov0" title="0">sort.Strings(sortNames)
        for _, name := range sortNames </span><span class="cov0" title="0">{
                if strings.ToLower(name) != "etag" </span><span class="cov0" title="0">{
                        fmt.Printf("%-[1]*s: %s\n", maxNameLen+2, name, attrMap[name])
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("%-[1]*s: %s\n", maxNameLen+2, name, strings.Trim(attrMap[name], "\""))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (sc *StatCommand) ossGetObjectACLRetry(bucket *oss.Bucket, object string) (oss.GetObjectACLResult, error) <span class="cov0" title="0">{
        retryTimes, _ := GetInt(OptionRetryTimes, sc.command.options)
        aclOptions := []oss.Option{}
        if len(sc.versionId) &gt; 0 </span><span class="cov0" title="0">{
                aclOptions = append(aclOptions, oss.VersionId(sc.versionId))
        }</span>
        <span class="cov0" title="0">aclOptions = append(aclOptions, sc.commonOptions...)

        for i := 1; ; i++ </span><span class="cov0" title="0">{
                goar, err := bucket.GetObjectACL(object, aclOptions...)
                if err == nil </span><span class="cov0" title="0">{
                        return goar, err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return goar, ObjectError{err, bucket.BucketName, object}
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package lib

import (
        "fmt"
        "net/url"
        "os"
        "strings"
)

// SchemePrefix is the prefix of oss url
const SchemePrefix string = "oss://"

type CloudURLType string

const (
        CloudURLNone    CloudURLType = "none"
        CloudURLService CloudURLType = "service"
        CloudURLBucket  CloudURLType = "bucket"
        CloudURLObject  CloudURLType = "object"
)

// StorageURLer is the interface for all url
type StorageURLer interface {
        IsCloudURL() bool
        IsFileURL() bool
        ToString() string
}

// CloudURL describes oss url
type CloudURL struct {
        urlStr string
        bucket string
        object string
}

// Init is used to create a cloud url from a user input url
func (cu *CloudURL) Init(urlStr, encodingType string) error <span class="cov8" title="64">{
        cu.urlStr = urlStr
        if err := cu.parseBucketObject(encodingType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="64">if err := cu.checkBucketObject(encodingType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="64">return nil</span>
}

func (cu *CloudURL) parseBucketObject(encodingType string) error <span class="cov8" title="64">{
        var err error
        path := cu.urlStr

        if strings.HasPrefix(strings.ToLower(path), SchemePrefix) </span><span class="cov8" title="64">{
                path = string(path[len(SchemePrefix):])
        }</span> else<span class="cov0" title="0"> {
                // deal with the url: /bucket/object
                if strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                        path = string(path[1:])
                }</span>
        }

        <span class="cov8" title="64">sli := strings.SplitN(path, "/", 2)
        cu.bucket = sli[0]
        if len(sli) &gt; 1 </span><span class="cov6" title="24">{
                cu.object = sli[1]
                if encodingType == URLEncodingType </span><span class="cov0" title="0">{
                        if cu.object, err = url.QueryUnescape(cu.object); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid cloud url: %s, object name is not url encoded, %s", cu.urlStr, err.Error())
                        }</span>
                }
        }
        <span class="cov8" title="64">return nil</span>
}

func (cu *CloudURL) checkBucketObject(encodingType string) error <span class="cov8" title="64">{
        if cu.bucket == "" &amp;&amp; cu.object != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", cu.urlStr)
        }</span>
        <span class="cov8" title="64">if encodingType == URLEncodingType &amp;&amp; cu.bucket != "" &amp;&amp; cu.object == "" </span><span class="cov0" title="0">{
                if bucket, err := url.QueryUnescape(cu.bucket); err == nil &amp;&amp; bucket != cu.bucket </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid cloud url: %s, bucket url do not support --encoding-type option", cu.urlStr)
                }</span>
        }
        <span class="cov8" title="64">return nil</span>
}

func (cu *CloudURL) checkObjectPrefix() error <span class="cov5" title="14">{
        if strings.HasPrefix(cu.object, "/") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, object name should not begin with \"/\"", cu.urlStr)
        }</span>
        <span class="cov5" title="14">if strings.HasPrefix(cu.object, "\\") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, object name should not begin with \"\\\"", cu.urlStr)
        }</span>
        <span class="cov5" title="14">return nil</span>
}

func (cu *CloudURL) checkIsObjectURL() error <span class="cov0" title="0">{
        if cu.bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss bucket", cu.urlStr)
        }</span>
        <span class="cov0" title="0">if cu.object == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid cloud url: %s, miss object", cu.urlStr)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsCloudURL shows if the url is a cloud url
func (cu CloudURL) IsCloudURL() bool <span class="cov9" title="84">{
        return true
}</span>

// IsFileURL shows if the url is a file url
func (cu CloudURL) IsFileURL() bool <span class="cov5" title="14">{
        return false
}</span>

// ToString reconstruct url
func (cu CloudURL) ToString() string <span class="cov10" title="134">{
        if cu.object == "" </span><span class="cov8" title="60">{
                return fmt.Sprintf("%s%s", SchemePrefix, cu.bucket)
        }</span>
        <span class="cov8" title="74">return fmt.Sprintf("%s%s/%s", SchemePrefix, cu.bucket, cu.object)</span>
}

// FileURL describes file url
type FileURL struct {
        urlStr string
}

// Init simulate inheritance, and polymorphism
func (fu *FileURL) Init(urlStr, encodingType string) error <span class="cov6" title="24">{
        if encodingType == URLEncodingType </span><span class="cov0" title="0">{
                vurl, err := url.QueryUnescape(urlStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid cloud url: %s, file name is not url encoded, %s", urlStr, err.Error())
                }</span>
                <span class="cov0" title="0">urlStr = vurl</span>
        }

        <span class="cov6" title="24">if len(urlStr) &gt;= 2 &amp;&amp; urlStr[:2] == "~"+string(os.PathSeparator) </span><span class="cov0" title="0">{
                homeDir := currentHomeDir()
                if homeDir != "" </span><span class="cov0" title="0">{
                        urlStr = strings.Replace(urlStr, "~", homeDir, 1)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("current home dir is empty")
                }</span>
        }
        <span class="cov6" title="24">fu.urlStr = urlStr
        return nil</span>
}

// IsCloudURL simulate inheritance, and polymorphism
func (fu FileURL) IsCloudURL() bool <span class="cov8" title="66">{
        return false
}</span>

// IsFileURL simulate inheritance, and polymorphism
func (fu FileURL) IsFileURL() bool <span class="cov5" title="10">{
        return true
}</span>

// ToString simulate inheritance, and polymorphism
func (fu FileURL) ToString() string <span class="cov7" title="40">{
        return fu.urlStr
}</span>

// StorageURLFromString analysis input url type and build a storage url from the url
func StorageURLFromString(urlStr, encodingType string) (StorageURLer, error) <span class="cov9" title="88">{
        if strings.HasPrefix(strings.ToLower(urlStr), SchemePrefix) </span><span class="cov8" title="64">{
                var cloudURL CloudURL
                if err := cloudURL.Init(urlStr, encodingType); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="64">return cloudURL, nil</span>
        }
        <span class="cov6" title="24">var fileURL FileURL
        if err := fileURL.Init(urlStr, encodingType); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="24">return fileURL, nil</span>
}

// CloudURLFromString get a oss url from url, if url is not a cloud url, return error
func CloudURLFromString(urlStr, encodingType string) (CloudURL, error) <span class="cov7" title="40">{
        storageURL, err := StorageURLFromString(urlStr, encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return CloudURL{}, err
        }</span>
        <span class="cov7" title="40">if !storageURL.IsCloudURL() </span><span class="cov0" title="0">{
                return CloudURL{}, fmt.Errorf("invalid cloud url: \"%s\", please make sure the url starts with: \"%s\"", urlStr, SchemePrefix)
        }</span>
        <span class="cov7" title="40">return storageURL.(CloudURL), nil</span>
}

// ObjectURLFromString get a oss url from url, if url is not a cloud url, return error
func ObjectURLFromString(urlStr, encodingType string) (CloudURL, error) <span class="cov0" title="0">{
        cloudURL, err := CloudURLFromString(urlStr, encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return cloudURL, err
        }</span>
        <span class="cov0" title="0">return cloudURL, cloudURL.checkIsObjectURL()</span>
}

// CloudURLToString format url string from input
func CloudURLToString(bucket string, object string) string <span class="cov10" title="134">{
        cloudURL := CloudURL{
                bucket: bucket,
                object: object,
        }
        return cloudURL.ToString()
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package lib

import (
        "bytes"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
)

/*
 * Put same type variables together to make them 64bits alignment to avoid
 * atomic.AddInt64() panic
 * Please guarantee the alignment if you add new filed
 */

var MaxSyncNumbers int = 1000000

type syncOptionType struct {
        bDelete      bool
        encodingType string
        backupDir    string
        force        bool

        enableSymlinkDir  bool
        onlyCurrentDir    bool
        disableDirObject  bool
        disableAllSymlink bool
        cpDir             string
        removeCount       int

        filters      []filterOptionType
        payerOptions []oss.Option
}

var specChineseSync = SpecText{

        synopsisText: "将本地文件目录或者oss prefix从源端同步到目的端",

        paramText: "src dest [options]",

        syntaxText: ` 
    ossutil sync local_dir cloud_url [-f] [-u] [--delete] [--backup-dir] [--enable-symlink-dir] [--disable-all-symlink] [--disable-ignore-error] [--only-current-dir] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--snapshot-path=sdir] [--payer requester]
    ossutil sync cloud_url local_dir [-f] [-u] [--delete] [--backup-dir] [--only-current-dir] [--disable-ignore-error] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--range=x-y] [--payer requester]
    ossutil sync cloud_url cloud_url [-f] [-u] [--delete] [--backup-dir] [--only-current-dir] [--disable-ignore-error] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--payer requester]
`,

        detailHelpText: ` 
    该命令和cp命令类似:支持从本地文件系统上传文件到oss，从oss下载object到本地文件系统，在oss
    上进行object拷贝; 用于源端和目的端数据同步. 

    sync命令和cp命令不同之处如下: 
    1、当输入--delete选项时,该命令会自动删除目的端存在而源端不存在的object或者移走本地文件
       如果目的端是oss, 则会删除多余的object; 如果目的端是本地文件, 则会移走本地多余的文件

       警告: 在没有完全搞清楚sync命令的行为之前, 请慎用--delete

    2、sync强制是以recursive方式遍历文件或者object, 所以不用输入-r --recursive
    3、当源端是oss://bucket/prefix, sync命令会自动在prefix后面加上字符 '/', 但是cp命令不会
       当目的端是oss://bucket/prefix, sync命令会在prefix后面加上字符 '/'; cp命令在--recursive被输入时也会在prefix后面加上字符'/'

--delete选项
    表示需要删除或者移走目的端存在而源端不存在的object或者文件

--backup-dir
    该选项表示用于备份目的端文件的目录, 不能是目的端目录的子目录,如果输入了--delete, 该选项必须输入

  
    其他选项说明、用法和cp命令相同
`,
        sampleText: ` 
    1) 从本地文件上传到oss
    前置条件如下:
    
    [root]# ls -al ./test_sync
    total 16
    drwxr-xr-x 2 root root 4096 Oct  5 13:09 .
    drwxr-xr-x 5 root root 4096 Oct  5 13:10 ..
    -rw-r--r-- 1 root root   38 Oct  5 12:48 a.txt
    -rw-r--r-- 1 root root  118 Oct  5 12:48 b.txt
    
    [root]# ./ossutil ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 13:10:23 +0800 CST          156      Standard   D282A160AB960C11ED797F009858D41D      oss://wangtw-test-sync2/a.txt
    2020-10-05 13:09:06 +0800 CST        21029      Standard   975F9F8EC2B34B15936FDAE1C85E71C9      oss://wangtw-test-sync2/c.txt
    Object Number is: 2
    

    # run ossutil sync command
    [root]# ./ossutil64 sync ./test_sync oss://wangtw-test-sync2/ --delete -f

    total file(directory) count:2
    oss://wangtw-test-sync2,total oss object count:2
    object will be deleted count:1
    Succeed: Total num: 2, size: 156. OK num: 2(upload 2 files).
    
    average speed 6000(byte/s)
    delete object count:1
    0.111655(s) elapsed
    
    [root]# ./ossutil64 ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 13:13:21 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/a.txt
    2020-10-05 13:13:21 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/b.txt
    Object Number is: 2
    

    执行sync命令之后, 本地文件a.txt, b.txt被上传到oss, oss object key c.txt 被删除

    2) 从oss上下载
    前置条件如下:
    
    [root]# ls -al ./test_sync
    total 36
    drwxr-xr-x 2 root root  4096 Oct  5 12:42 .
    drwxr-xr-x 4 root root  4096 Oct  5 12:42 ..
    -rw-r--r-- 1 root root    38 Oct  5 11:22 a.txt
    -rw-r--r-- 1 root root 21029 Oct  5 11:22 d.txt    

    [root]# ./ossutil64 ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 11:55:47 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/a.txt
    2020-10-05 11:55:47 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/b.txt
    2020-10-05 11:55:47 +0800 CST        21029      Standard   975F9F8EC2B34B15936FDAE1C85E71C9      oss://wangtw-test-sync2/c.txt
    Object Number is: 3
    

    # run ossutil sync command
    [root]# ./ossutil64 sync oss://wangtw-test-sync2 ./test_sync  --delete -f --backup-dir backup

    oss://wangtw-test-sync2,total oss object count:3
    total file(directory) count:2
    file(directory) will be removed count:1
    Succeed: Total num: 3, size: 21,185. OK num: 3(download 3 objects).
    
    average speed 243000(byte/s)
    remove file(dir) count:1
    0.172867(s) elapsed

    [root]# ls -al ./test_sync/
    total 40
    drwxr-xr-x 2 root root  4096 Oct  5 12:48 .
    drwxr-xr-x 4 root root  4096 Oct  5 12:48 ..
    -rw-r--r-- 1 root root    38 Oct  5 12:48 a.txt
    -rw-r--r-- 1 root root   118 Oct  5 12:48 b.txt
    -rw-r--r-- 1 root root 21029 Oct  5 12:48 c.txt

    [root]# ls -al ./backup/
    total 32
    drwxr-xr-x 2 root root  4096 Oct  5 12:48 .
    drwxr-xr-x 4 root root  4096 Oct  5 12:48 ..
    -rw-r--r-- 1 root root 21029 Oct  5 11:22 d.txt

    执行sync命令之后, oss object keys a.txt, b.txt, c.txt被下载下来
    本地文件d.txt被移动到备份目录backup

    3) 在oss之间copy
    前置条件如下:

    [root]# ./ossutil64 ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 12:55:47 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/prefix1/a.txt
    2020-10-05 12:55:47 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/prefix1/b.txt
    2020-10-05 13:00:58 +0800 CST           65      Standard   77F476710889A7FAA2603093B08EB31B      oss://wangtw-test-sync2/prefix2/a.txt
    2020-10-05 12:56:23 +0800 CST        21029      Standard   975F9F8EC2B34B15936FDAE1C85E71C9      oss://wangtw-test-sync2/prefix2/c.txt
    Object Number is: 4
    
    0.067659(s) elapsed

    [root]# ./ossutil64 sync oss://wangtw-test-sync2/prefix1 oss://wangtw-test-sync2/prefix2 --delete -f
    oss://wangtw-test-sync2/prefix1/,total oss object count:2
    oss://wangtw-test-sync2/prefix2/,total oss object count:2
    object will be deleted count:1
    Succeed: Total num: 2, size: 156. OK num: 2(copy 2 objects).
    
    average speed 5000(byte/s)
    delete object count:1
    0.071010(s) elapsed

    [root]# ./ossutil64 ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 12:55:47 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/prefix1/a.txt
    2020-10-05 12:55:47 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/prefix1/b.txt
    2020-10-05 13:02:02 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/prefix2/a.txt
    2020-10-05 13:02:02 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/prefix2/b.txt
    Object Number is: 4

    执行sync命令之后, oss object key prefix1/a.txt, prefix1/b.txt 被拷贝到
    prefix2/a.txt, prefix2/b.txt 并且 prefix2/c.txt 被删除
`,
}

var specEnglishSync = SpecText{

        synopsisText: "Sync the local file directory or oss prefix from the source to the destination",

        paramText: "src dest [options]",

        syntaxText: ` 
    ossutil sync local_dir cloud_url [-f] [-u] [--delete] [--backup-dir] [--enable-symlink-dir] [--disable-all-symlink] [--disable-ignore-error] [--only-current-dir] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--snapshot-path=sdir] [--payer requester]
    ossutil sync cloud_url local_dir [-f] [-u] [--delete] [--backup-dir] [--only-current-dir] [--disable-ignore-error] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--range=x-y] [--payer requester]
    ossutil sync cloud_url cloud_url [-f] [-u] [--delete] [--backup-dir] [--only-current-dir] [--disable-ignore-error] [--output-dir=odir] [--bigfile-threshold=size] [--checkpoint-dir=cdir] [--payer requester]
`,

        detailHelpText: ` 
    This command is similar to the cp command: it supports uploading files from the local file
    system to oss, and downloading objects from oss to the local file system, Copying objects between 
    oss; It's used for data synchronization between source and destination. 

    The differences between the sync command and the cp command are as follows:
    1、When the --delete option is entered, the command will automatically delete objects or remove files 
       that exist on the destination but not exist on the source.
       If the destination is oss, the redundant objects will be deleted; 
       If the destination is local directory, the redundant files will be removed to back up directory.
       
       Warning: Before you fully understand the behavior of the sync command, please use --delete carefully
    
    2、Sync is forced to traverse files or objects recursively, so there is no need to enter -r or --recursive
    3、When the src is oss://bucket/prefix, sync command will add character '/' after the prefix, but cp command doesn't add
       When the destination is oss://bucket/prefix, sync command will add character '/' after the prefix; The cp command will also add '/' after the prefix with --recusive is entered

--delete
    Indicates that the objects or files which exist on destination
    and not exist on src needs to be deleted or removed to backup dir

--backup-dir
    This option indicates the directory used to back up the destination files needed to be removed, 
    It cannot be a subdirectory of the destination directory. 
    If you enter --delete, this option must be entered

    Other options descriptions and usage are the same as the cp command
`,

        sampleText: ` 
    1) Upload to oss
    The preconditions are as follows:
    
    [root]# ls -al ./test_sync
    total 16
    drwxr-xr-x 2 root root 4096 Oct  5 13:09 .
    drwxr-xr-x 5 root root 4096 Oct  5 13:10 ..
    -rw-r--r-- 1 root root   38 Oct  5 12:48 a.txt
    -rw-r--r-- 1 root root  118 Oct  5 12:48 b.txt

    [root]# ./ossutil64 ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 13:10:23 +0800 CST          156      Standard   D282A160AB960C11ED797F009858D41D      oss://wangtw-test-sync2/a.txt
    2020-10-05 13:09:06 +0800 CST        21029      Standard   975F9F8EC2B34B15936FDAE1C85E71C9      oss://wangtw-test-sync2/c.txt
    Object Number is: 2
    

    # run ossutil sync command
    [root]# ./ossutil64 sync ./test_sync oss://wangtw-test-sync2/ --delete -f

    total file(directory) count:2
    oss://wangtw-test-sync2,total oss object count:2
    object will be deleted count:1
    Succeed: Total num: 2, size: 156. OK num: 2(upload 2 files).
    
    average speed 6000(byte/s)
    delete object count:1
    0.111655(s) elapsed

    [root]# ./ossutil64 ls oss://wangtw-test-sync2/
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 13:13:21 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/a.txt
    2020-10-05 13:13:21 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/b.txt
    Object Number is: 2

    After the sync command is executed, local files a.txt, b.txt are uploaded and oss object 
    key c.txt is deleted
    
    2) download from oss
    The preconditions are as follows:
    
    [root]# ls -al ./test_sync
    total 36
    drwxr-xr-x 2 root root  4096 Oct  5 12:42 .
    drwxr-xr-x 4 root root  4096 Oct  5 12:42 ..
    -rw-r--r-- 1 root root    38 Oct  5 11:22 a.txt
    -rw-r--r-- 1 root root 21029 Oct  5 11:22 d.txt    

    [root]# ./ossutil64 ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 11:55:47 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/a.txt
    2020-10-05 11:55:47 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/b.txt
    2020-10-05 11:55:47 +0800 CST        21029      Standard   975F9F8EC2B34B15936FDAE1C85E71C9      oss://wangtw-test-sync2/c.txt
    Object Number is: 3
    

    # run ossutil sync command
    [root]# ./ossutil64 sync oss://wangtw-test-sync2 ./test_sync  --delete -f --backup-dir backup

    oss://wangtw-test-sync2,total oss object count:3
    total file(directory) count:2
    file(directory) will be removed count:1
    Succeed: Total num: 3, size: 21,185. OK num: 3(download 3 objects).
    
    average speed 243000(byte/s)
    remove file(dir) count:1
    0.172867(s) elapsed

    [root]# ls -al ./test_sync/
    total 40
    drwxr-xr-x 2 root root  4096 Oct  5 12:48 .
    drwxr-xr-x 4 root root  4096 Oct  5 12:48 ..
    -rw-r--r-- 1 root root    38 Oct  5 12:48 a.txt
    -rw-r--r-- 1 root root   118 Oct  5 12:48 b.txt
    -rw-r--r-- 1 root root 21029 Oct  5 12:48 c.txt

    [root]# ls -al ./backup/
    total 32
    drwxr-xr-x 2 root root  4096 Oct  5 12:48 .
    drwxr-xr-x 4 root root  4096 Oct  5 12:48 ..
    -rw-r--r-- 1 root root 21029 Oct  5 11:22 d.txt

    After the sync command is executed, oss keys a.txt, b.txt, c.txt are downloaded
    and local file d.txt is removed to backup dir

    3) copy between oss
    The preconditions are as follows:

    [root]# ./ossutil64 ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 12:55:47 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/prefix1/a.txt
    2020-10-05 12:55:47 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/prefix1/b.txt
    2020-10-05 13:00:58 +0800 CST           65      Standard   77F476710889A7FAA2603093B08EB31B      oss://wangtw-test-sync2/prefix2/a.txt
    2020-10-05 12:56:23 +0800 CST        21029      Standard   975F9F8EC2B34B15936FDAE1C85E71C9      oss://wangtw-test-sync2/prefix2/c.txt
    Object Number is: 4
    
    0.067659(s) elapsed

    [root]# ./ossutil64 sync oss://wangtw-test-sync2/prefix1 oss://wangtw-test-sync2/prefix2 --delete -f
    oss://wangtw-test-sync2/prefix1/,total oss object count:2
    oss://wangtw-test-sync2/prefix2/,total oss object count:2
    object will be deleted count:1
    Succeed: Total num: 2, size: 156. OK num: 2(copy 2 objects).

    average speed 5000(byte/s)
    delete object count:1
    0.071010(s) elapsed

    [root]# ./ossutil ls oss://wangtw-test-sync2
    LastModifiedTime                   Size(B)  StorageClass   ETAG                                  ObjectName
    2020-10-05 12:55:47 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/prefix1/a.txt
    2020-10-05 12:55:47 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/prefix1/b.txt
    2020-10-05 13:02:02 +0800 CST           38      Standard   533F2D421ED096DBB4CF458AADA64F8E      oss://wangtw-test-sync2/prefix2/a.txt
    2020-10-05 13:02:02 +0800 CST          118      Standard   C6639C466B70758C82596413C2BB050A      oss://wangtw-test-sync2/prefix2/b.txt
    Object Number is: 4

    After the sync command is executed, oss keys prefix1/a.txt, prefix1/b.txt are copied to
    prefix2/a.txt, prefix2/b.txt and prefix2/c.txt is deleted
`,
}

// SyncCommand is the command upload, download and copy objects
type SyncCommand struct {
        command    Command
        syncOption syncOptionType
}

var syncCommand = SyncCommand{
        command: Command{
                name:        "sync",
                nameAlias:   []string{"sync"},
                minArgc:     2,
                maxArgc:     2,
                specChinese: specChineseSync,
                specEnglish: specEnglishSync,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        // The following options are supported by sc command and cp command
                        //OptionRecursion,
                        OptionForce,
                        OptionUpdate,
                        OptionContinue,
                        OptionOutputDir,
                        OptionBigFileThreshold,
                        OptionPartSize,
                        OptionCheckpointDir,
                        OptionRange,
                        OptionEncodingType,
                        OptionInclude,
                        OptionExclude,
                        OptionMeta,
                        OptionACL,
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionRetryTimes,
                        OptionRoutines,
                        OptionParallel,
                        OptionSnapshotPath,
                        OptionDisableCRC64,
                        OptionRequestPayer,
                        OptionLogLevel,
                        OptionMaxUpSpeed,
                        //OptionPartitionDownload,
                        //OptionVersionId,
                        OptionLocalHost,
                        OptionEnableSymlinkDir,
                        OptionOnlyCurrentDir,
                        OptionDisableDirObject,
                        OptionDisableAllSymlink,
                        OptionDisableIgnoreError,
                        OptionTagging,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,

                        // The following options are only supported by sc command, not supported by cp command
                        OptionDelete,
                        OptionBackupDir,
                },
        },
}

// function for FormatHelper interface
func (sc *SyncCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return sc.command.formatHelpForWhole()
}</span>

func (sc *SyncCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return sc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (sc *SyncCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        recursive := true
        bakupOptions := make(OptionMapType)
        for k, v := range options </span><span class="cov0" title="0">{
                bakupOptions[k] = v
        }</span>

        // force to recursive and delete unsurpported options
        <span class="cov0" title="0">bakupOptions[OptionRecursion] = &amp;recursive
        delete(bakupOptions, OptionDelete)
        delete(bakupOptions, OptionBackupDir)

        copyCommand.cpOption.bSyncCommand = true
        err := (&amp;copyCommand).Init(args, bakupOptions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sc.command.Init(args, options, sc)</span>
}

// RunCommand simulate inheritance, and polymorphism
func (sc *SyncCommand) RunCommand() error <span class="cov0" title="0">{
        sc.syncOption.bDelete, _ = GetBool(OptionDelete, sc.command.options)
        sc.syncOption.encodingType, _ = GetString(OptionEncodingType, sc.command.options)
        sc.syncOption.backupDir, _ = GetString(OptionBackupDir, sc.command.options)

        // for list file
        sc.syncOption.enableSymlinkDir, _ = GetBool(OptionEnableSymlinkDir, sc.command.options)
        sc.syncOption.onlyCurrentDir, _ = GetBool(OptionOnlyCurrentDir, sc.command.options)
        sc.syncOption.disableDirObject, _ = GetBool(OptionDisableDirObject, sc.command.options)
        sc.syncOption.disableAllSymlink, _ = GetBool(OptionDisableAllSymlink, sc.command.options)
        sc.syncOption.force, _ = GetBool(OptionForce, sc.command.options)

        // check point dir
        sc.syncOption.cpDir, _ = GetString(OptionCheckpointDir, sc.command.options)

        // payer
        payer, _ := GetString(OptionRequestPayer, sc.command.options)
        if payer != "" </span><span class="cov0" title="0">{
                if payer != strings.ToLower(string(oss.Requester)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid request payer: %s, please check", payer)
                }</span>
                <span class="cov0" title="0">sc.syncOption.payerOptions = append(sc.syncOption.payerOptions, oss.RequestPayer(oss.PayerType(payer)))</span>
        }

        // filters
        <span class="cov0" title="0">var res bool
        res, sc.syncOption.filters = getFilter(os.Args)
        if !res </span><span class="cov0" title="0">{
                return fmt.Errorf("--include or --exclude does not support format containing dir info")
        }</span>

        <span class="cov0" title="0">for k, v := range sc.syncOption.filters </span><span class="cov0" title="0">{
                LogInfo("filter %d,name:%s,pattern:%s\n", k, v.name, v.pattern)
        }</span>

        <span class="cov0" title="0">srcURL, err := StorageURLFromString(sc.command.args[0], sc.syncOption.encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">destURL, err := StorageURLFromString(sc.command.args[1], sc.syncOption.encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if srcURL.IsFileURL() &amp;&amp; destURL.IsFileURL() </span><span class="cov0" title="0">{
                return fmt.Errorf("not support sync between local directory")
        }</span>

        <span class="cov0" title="0">if srcURL.IsFileURL() </span><span class="cov0" title="0">{
                f, err := os.Stat(srcURL.ToString())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !f.IsDir() </span><span class="cov0" title="0">{
                        return fmt.Errorf("src %s is not directory", srcURL.ToString())
                }</span>
        }

        <span class="cov0" title="0">if !sc.syncOption.bDelete </span><span class="cov0" title="0">{
                return copyCommand.RunCommand()
        }</span>

        // sync command add '/' afert cloud prefix
        // cp command must have the same action when run as sync command
        <span class="cov0" title="0">srcURL = sc.adjustCloudUrl(srcURL)
        destURL = sc.adjustCloudUrl(destURL)

        // check backup dir
        if destURL.IsFileURL() </span><span class="cov0" title="0">{
                err = sc.CheckDestBackupDir(destURL)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">opType := sc.getCommandType(srcURL, destURL)

        // get file list or object key list
        srcKeys := make(map[string]string)
        destKeys := make(map[string]string)
        if srcURL.IsFileURL() </span><span class="cov0" title="0">{
                err = sc.GetLocalFileKeys(srcURL, srcKeys)
        }</span> else<span class="cov0" title="0"> {
                err = sc.GetOssKeys(srcURL, srcKeys)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if destURL.IsFileURL() </span><span class="cov0" title="0">{
                err = sc.GetLocalFileKeys(destURL, destKeys)
        }</span> else<span class="cov0" title="0"> {
                err = sc.GetOssKeys(destURL, destKeys)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get keys to be deleted
        <span class="cov0" title="0">bSame := (string(os.PathSeparator) == "/")
        for k, _ := range srcKeys </span><span class="cov0" title="0">{
                if bSame || opType == operationTypeCopy </span><span class="cov0" title="0">{
                        delete(destKeys, k)
                }</span> else<span class="cov0" title="0"> if opType == operationTypePut </span><span class="cov0" title="0">{
                        delete(destKeys, strings.Replace(k, "\\", "/", -1))
                }</span> else<span class="cov0" title="0"> {
                        delete(destKeys, strings.Replace(k, "/", "\\", -1))
                }</span>
        }

        <span class="cov0" title="0">if destURL.IsFileURL() </span><span class="cov0" title="0">{
                fmt.Printf("\nfile(directory) will be removed count:%d\n", len(destKeys))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\nobject will be deleted count:%d\n", len(destKeys))
        }</span>

        <span class="cov0" title="0">err = copyCommand.RunCommand()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // move dest files or rm dest objects which not exist in src
        <span class="cov0" title="0">if opType == operationTypeCopy || opType == operationTypePut </span><span class="cov0" title="0">{
                err = sc.DeleteExtraObjects(destKeys, destURL)
        }</span> else<span class="cov0" title="0"> {
                err = sc.RemoveExtraFiles(destKeys, destURL)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (sc *SyncCommand) adjustCloudUrl(sUrl StorageURLer) StorageURLer <span class="cov0" title="0">{
        if sUrl.IsFileURL() </span><span class="cov0" title="0">{
                return sUrl
        }</span>

        <span class="cov0" title="0">cloudUrl := sUrl.(CloudURL)
        if len(cloudUrl.object) &gt; 0 &amp;&amp; !strings.HasSuffix(cloudUrl.object, "/") </span><span class="cov0" title="0">{
                cloudUrl.object += "/"
        }</span>
        <span class="cov0" title="0">return cloudUrl</span>
}

func (sc *SyncCommand) DeleteExtraObjects(keys map[string]string, sUrl StorageURLer) error <span class="cov0" title="0">{
        bucketName := sUrl.(CloudURL).bucket
        bucket, err := sc.command.ossBucket(bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">deleteCount := 0
        rmOptions := append(sc.syncOption.payerOptions, oss.DeleteObjectsQuiet(true))
        objects := []string{}
        for k, v := range keys </span><span class="cov0" title="0">{
                if len(objects) &gt;= MaxBatchCount </span><span class="cov0" title="0">{
                        if sc.confirm(objects) </span><span class="cov0" title="0">{
                                err := sc.BatchRmObjects(bucket, objects, rmOptions)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">objects = []string{}
                        deleteCount += MaxBatchCount
                        fmt.Printf("\rdelete object count:%d", deleteCount)</span>
                }
                // prefix + relativeKey
                <span class="cov0" title="0">objects = append(objects, v+k)</span>
        }

        <span class="cov0" title="0">if len(objects) &gt; 0 &amp;&amp; sc.confirm(objects) </span><span class="cov0" title="0">{
                err := sc.BatchRmObjects(bucket, objects, rmOptions)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">deleteCount += len(objects)
                fmt.Printf("\rdelete object count:%d", deleteCount)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (sc *SyncCommand) RemoveExtraFiles(keys map[string]string, sUrl StorageURLer) error <span class="cov0" title="0">{
        var sortList []string
        for k, _ := range keys </span><span class="cov0" title="0">{
                sortList = append(sortList, k)
        }</span>
        // remove files first,then remove dir
        <span class="cov0" title="0">sort.Sort(sort.Reverse(sort.StringSlice(sortList)))

        absDirName, err := sc.GetAbsPath(sUrl.ToString())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nowFatherDirName := ""
        for _, k := range sortList </span><span class="cov0" title="0">{
                if strings.HasSuffix(k, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                        // is dir
                        dirName := k[0 : len(k)-1]
                        readerInfos, _ := sc.readDirLimit(absDirName+dirName, 10)

                        if len(readerInfos) &gt; 0 </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                //empty dir,need to remove or delete
                                f, err := os.Stat(sc.syncOption.backupDir + dirName)
                                if err != nil </span><span class="cov0" title="0">{
                                        sc.movePath(absDirName+dirName, sc.syncOption.backupDir+dirName)
                                }</span> else<span class="cov0" title="0"> {
                                        if !f.IsDir() </span><span class="cov0" title="0">{
                                                return fmt.Errorf("backup %s is already exist,but is file", sc.syncOption.backupDir+dirName)
                                        }</span> else<span class="cov0" title="0"> {
                                                // delete the dir
                                                os.RemoveAll(absDirName + dirName)
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // is file
                        fatherDir := absDirName
                        index := strings.LastIndex(k, string(os.PathSeparator))
                        if index &gt;= 0 </span><span class="cov0" title="0">{
                                fatherDir = k[:index]
                        }</span>

                        <span class="cov0" title="0">if fatherDir != nowFatherDirName &amp;&amp; fatherDir != absDirName </span><span class="cov0" title="0">{
                                os.MkdirAll(sc.syncOption.backupDir+fatherDir, 0755)
                                nowFatherDirName = fatherDir
                        }</span>

                        <span class="cov0" title="0">err := sc.movePath(absDirName+k, sc.syncOption.backupDir+k)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (sc *SyncCommand) BatchRmObjects(bucket *oss.Bucket, objects []string, options []oss.Option) error <span class="cov0" title="0">{
        delRes, err := bucket.DeleteObjects(objects, options...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(delRes.DeletedObjects) &gt; 0 </span><span class="cov0" title="0">{
                errMsg := ""
                for _, objectKey := range delRes.DeletedObjects </span><span class="cov0" title="0">{
                        errMsg += (" " + objectKey)
                }</span>
                <span class="cov0" title="0">LogError("delete erro %s\n", errMsg)
                return fmt.Errorf("delete %s error", errMsg)</span>
        }

        <span class="cov0" title="0">for _, v := range objects </span><span class="cov0" title="0">{
                LogInfo("delete object success %s\n", v)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sc *SyncCommand) getCommandType(srcURL StorageURLer, destURL StorageURLer) operationType <span class="cov0" title="0">{
        if srcURL.IsCloudURL() </span><span class="cov0" title="0">{
                if destURL.IsFileURL() </span><span class="cov0" title="0">{
                        return operationTypeGet
                }</span>
                <span class="cov0" title="0">return operationTypeCopy</span>
        }
        <span class="cov0" title="0">return operationTypePut</span>
}

func (sc *SyncCommand) GetLocalFileKeys(sUrl StorageURLer, keys map[string]string) error <span class="cov0" title="0">{
        strPath := sUrl.ToString()
        if !strings.HasSuffix(strPath, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                // for symlink dir
                strPath += string(os.PathSeparator)
        }</span>

        <span class="cov0" title="0">chFiles := make(chan fileInfoType, ChannelBuf)
        chFinish := make(chan error, 2)
        go sc.ReadLocalFileKeys(chFiles, chFinish, keys)
        go sc.GetFileList(strPath, chFiles, chFinish)
        select </span>{
        case err := &lt;-chFinish:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (sc *SyncCommand) GetFileList(strPath string, chFiles chan&lt;- fileInfoType, chFinish chan&lt;- error) <span class="cov0" title="0">{
        err := getFileListCommon(strPath, chFiles, sc.syncOption.onlyCurrentDir,
                sc.syncOption.disableAllSymlink, sc.syncOption.enableSymlinkDir, sc.syncOption.filters)
        if err != nil </span><span class="cov0" title="0">{
                chFinish &lt;- err
        }</span>
}

func (sc *SyncCommand) ReadLocalFileKeys(chFiles &lt;-chan fileInfoType, chFinish chan&lt;- error, keys map[string]string) <span class="cov0" title="0">{
        totalCount := 0
        fmt.Printf("\n")
        for fileInfo := range chFiles </span><span class="cov0" title="0">{
                if copyCommand.filterFile(fileInfo, sc.syncOption.cpDir) </span><span class="cov0" title="0">{ // exclude checkpoint files
                        totalCount++
                        fmt.Printf("\rtotal file(directory) count:%d", totalCount)
                        keys[fileInfo.filePath] = ""
                        if len(keys) &gt; MaxSyncNumbers </span><span class="cov0" title="0">{
                                fmt.Printf("\n")
                                chFinish &lt;- fmt.Errorf("over max sync numbers %d", MaxSyncNumbers)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">fmt.Printf("\rtotal file(directory) count:%d", totalCount)
        chFinish &lt;- nil</span>
}

func (sc *SyncCommand) GetAbsPath(strPath string) (string, error) <span class="cov0" title="0">{
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if !strings.HasSuffix(strPath, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                strPath += string(os.PathSeparator)
        }</span>

        <span class="cov0" title="0">strPath = currentDir + string(os.PathSeparator) + strPath
        absPath, err := filepath.Abs(strPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if !strings.HasSuffix(absPath, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                absPath += string(os.PathSeparator)
        }</span>
        <span class="cov0" title="0">return absPath, err</span>
}

func (sc *SyncCommand) CheckDestBackupDir(sUrl StorageURLer) error <span class="cov0" title="0">{
        // create bacup dir
        createDirectory := false
        f, err := os.Stat(sUrl.ToString())
        if err != nil </span><span class="cov0" title="0">{
                if err := os.MkdirAll(sUrl.ToString(), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">createDirectory = true</span>
        } else<span class="cov0" title="0"> if !f.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("dest dir %s is file,is not directory", sUrl.ToString())
        }</span>

        <span class="cov0" title="0">if createDirectory &amp;&amp; sc.syncOption.backupDir == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if sc.syncOption.backupDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("dest backup dir is empty string,please use --backup-dir")
        }</span>

        <span class="cov0" title="0">if !strings.HasSuffix(sc.syncOption.backupDir, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                sc.syncOption.backupDir += string(os.PathSeparator)
        }</span>

        // check backup dir is Subdirectories or not
        <span class="cov0" title="0">absfilePath, errF := sc.GetAbsPath(sUrl.ToString())
        if errF != nil </span><span class="cov0" title="0">{
                return errF
        }</span>

        <span class="cov0" title="0">absBackPath, errB := sc.GetAbsPath(sc.syncOption.backupDir)
        if errB != nil </span><span class="cov0" title="0">{
                return errB
        }</span>

        <span class="cov0" title="0">if strings.Index(absBackPath, absfilePath) &gt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("backup dir %s is subdirectory of %s", sc.syncOption.backupDir, sUrl.ToString())
        }</span>

        // create bacup dir
        <span class="cov0" title="0">f, err = os.Stat(sc.syncOption.backupDir)
        if err != nil </span><span class="cov0" title="0">{
                if err := os.MkdirAll(sc.syncOption.backupDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> if !f.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("dest backup dir %s is file,is not directory", sc.syncOption.backupDir)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sc *SyncCommand) GetOssKeys(sUrl StorageURLer, keys map[string]string) error <span class="cov0" title="0">{
        bucketName := sUrl.(CloudURL).bucket
        bucket, err := sc.command.ossBucket(bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">chFiles := make(chan objectInfoType, ChannelBuf)
        chFinish := make(chan error, 2)
        go sc.ReadOssKeys(keys, sUrl, chFiles, chFinish)
        go sc.GetOssKeyList(bucket, sUrl, chFiles, chFinish)
        select </span>{
        case err := &lt;-chFinish:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (sc *SyncCommand) GetOssKeyList(bucket *oss.Bucket, sURL StorageURLer, chObjects chan&lt;- objectInfoType, chFinish chan&lt;- error) <span class="cov0" title="0">{
        cloudURL := sURL.(CloudURL)
        err := getObjectListCommon(bucket, cloudURL, chObjects, sc.syncOption.onlyCurrentDir,
                sc.syncOption.filters, sc.syncOption.payerOptions)
        if err != nil </span><span class="cov0" title="0">{
                chFinish &lt;- err
        }</span>
}

func (sc *SyncCommand) ReadOssKeys(keys map[string]string, sURL StorageURLer, chObjects &lt;-chan objectInfoType, chFinish chan&lt;- error) <span class="cov0" title="0">{
        totalCount := 0
        fmt.Printf("\n")
        for objectInfo := range chObjects </span><span class="cov0" title="0">{
                totalCount++
                fmt.Printf("\r%s,total oss object count:%d", sURL.ToString(), totalCount)
                keys[objectInfo.relativeKey] = objectInfo.prefix
                if len(keys) &gt; MaxSyncNumbers </span><span class="cov0" title="0">{
                        fmt.Printf("\n")
                        chFinish &lt;- fmt.Errorf("over max sync numbers %d", MaxSyncNumbers)
                        break</span>
                }
        }
        <span class="cov0" title="0">fmt.Printf("\r%s,total oss object count:%d", sURL.ToString(), totalCount)
        chFinish &lt;- nil</span>
}

func (sc *SyncCommand) confirm(keys []string) bool <span class="cov0" title="0">{
        if sc.syncOption.force </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">var logBuffer bytes.Buffer
        logBuffer.WriteString("\n")
        for _, v := range keys </span><span class="cov0" title="0">{
                logBuffer.WriteString(fmt.Sprintf("%s\n", v))
        }</span>
        <span class="cov0" title="0">logBuffer.WriteString(fmt.Sprintf("sync:delete above objects(y or N)? "))
        fmt.Printf(logBuffer.String())

        var val string
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (sc *SyncCommand) readDirLimit(dirName string, limitCount int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        f, err := os.Open(dirName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">list, err := f.Readdir(limitCount)
        f.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return list, nil</span>
}

func (sc *SyncCommand) movePath(srcName, destName string) error <span class="cov0" title="0">{
        err := os.Rename(srcName, destName)
        if err != nil </span><span class="cov0" title="0">{
                LogError("rename %s %s error,%s\n", srcName, destName, err.Error())
        }</span> else<span class="cov0" title="0"> {
                sc.syncOption.removeCount += 1
                fmt.Printf("\rremove file(directory) count:%d", sc.syncOption.removeCount)
                LogInfo("rename success %s %s\n", srcName, destName)
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package lib

import (
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "os"
        "runtime"
        "sort"
        "strings"
)

var (
        vUpdateEndpoint = updateEndpoint
        vUpdateBucket   = updateBucket
        vVersion        = Version
)

var specChineseUpdate = SpecText{

        synopsisText: "更新ossutil",

        paramText: "[options]",

        syntaxText: ` 
    ossutil update [-f] 
`,

        detailHelpText: ` 
    该命令检查当前ossutil的版本与最新版本，输出两者的版本号，如果有更新版本，询问是否
    进行升级。如果指定了--force选项，则不询问，当有可用更新时，直接升级。

`,

        sampleText: ` 
    ossutil update
    ossutil update -f
`,
}

var specEnglishUpdate = SpecText{

        synopsisText: "Update ossutil",

        paramText: "[options]",

        syntaxText: ` 
    ossutil update [-f]
`,

        detailHelpText: ` 
    The command check version of current ossutil and get the latest version, output the 
    versions, if any updated version exists, the command ask you for upgrading. If --force 
    option is specified, the command upgrade without asking. 
`,

        sampleText: ` 
    ossutil update
    ossutil update -f
`,
}

// UpdateCommand is the command update ossutil
type UpdateCommand struct {
        command Command
}

var updateCommand = UpdateCommand{
        command: Command{
                name:        "update",
                nameAlias:   []string{""},
                minArgc:     0,
                maxArgc:     0,
                specChinese: specChineseUpdate,
                specEnglish: specEnglishUpdate,
                group:       GroupTypeAdditionalCommand,
                validOptionNames: []string{
                        OptionForce,
                        OptionRetryTimes,
                        OptionLanguage,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                },
        },
}

// function for RewriteLoadConfiger interface
func (uc *UpdateCommand) rewriteLoadConfig(configFile string) error <span class="cov0" title="0">{
        // read config file, if error exist, do not print error
        var err error
        if uc.command.configOptions, err = LoadConfig(configFile); err != nil </span><span class="cov0" title="0">{
                uc.command.configOptions = OptionMapType{}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// function for FormatHelper interface
func (uc *UpdateCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return uc.command.formatHelpForWhole()
}</span>

func (uc *UpdateCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return uc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (uc *UpdateCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return uc.command.Init(args, options, uc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (uc *UpdateCommand) RunCommand() error <span class="cov0" title="0">{
        force, _ := GetBool(OptionForce, uc.command.options)
        language, _ := GetString(OptionLanguage, uc.command.options)
        language = strings.ToLower(language)

        // get lastest version
        version, err := uc.getLastestVersion()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get lastest vsersion error, %s", err.Error())
        }</span>

        <span class="cov0" title="0">if language == LEnglishLanguage </span><span class="cov0" title="0">{
                fmt.Printf("current version is: %s, the lastest version is: %s", vVersion, version)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("当前版本为：%s，最新版本为：%s", vVersion, version)
        }</span>

        // version is X.X.X
        // vVersion is vX.X.X
        <span class="cov0" title="0">if vVersion[0] &lt; '0' || vVersion[0] &gt; '9' </span><span class="cov0" title="0">{
                vVersion = vVersion[1:len(vVersion)]
        }</span>
        <span class="cov0" title="0">if version == vVersion </span><span class="cov0" title="0">{
                if language == LEnglishLanguage </span><span class="cov0" title="0">{
                        fmt.Println(", current version is the lastest version, no need to update.")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("，当前版本即为最新版本，无需更新。")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">fmt.Println("")

        if !force </span><span class="cov0" title="0">{
                if language == LEnglishLanguage </span><span class="cov0" title="0">{
                        fmt.Printf("sure to update ossutil(y or N)? ")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("确定更新版本(y or N)? ")
                }</span>

                <span class="cov0" title="0">var val string
                if _, err := fmt.Scanln(&amp;val); err == nil &amp;&amp; (strings.EqualFold(val, "yes") || strings.EqualFold(val, "y")) </span><span class="cov0" title="0">{
                        return uc.updateVersion(version, language)
                }</span>

                <span class="cov0" title="0">if language == LEnglishLanguage </span><span class="cov0" title="0">{
                        fmt.Printf("operation is canceled.")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("操作取消。")
                }</span>
        } else<span class="cov0" title="0"> {
                return uc.updateVersion(version, language)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *UpdateCommand) getLastestVersion() (string, error) <span class="cov0" title="0">{
        if err := uc.anonymousGetToFileRetry(vUpdateBucket, updateVersionObject, updateTmpVersionFile); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">v, err := ioutil.ReadFile(updateTmpVersionFile)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">versionStr := strings.TrimSpace(strings.Trim(string(v), "\n"))

        // get version list and sort
        sli := strings.Split(versionStr, "\n")
        vl := []string{}
        for _, vstr := range sli </span><span class="cov0" title="0">{
                vl = append(vl, strings.TrimSpace(strings.Trim(string(vstr), "\n")))
        }</span>
        <span class="cov0" title="0">sort.Strings(vl)
        version := vl[len(vl)-1]

        os.Remove(updateTmpVersionFile)

        return version, nil</span>
}

func (uc *UpdateCommand) anonymousGetToFileRetry(bucketName, objectName, filePath string) error <span class="cov0" title="0">{
        host := fmt.Sprintf("http://%s.%s/%s", bucketName, vUpdateEndpoint, objectName)
        retryTimes, _ := GetInt(OptionRetryTimes, uc.command.options)
        for i := 1; ; i++ </span><span class="cov0" title="0">{
                err := uc.ossAnonymousGetToFile(host, filePath)
                if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if int64(i) &gt;= retryTimes </span><span class="cov0" title="0">{
                        return ObjectError{err, bucketName, objectName}
                }</span>
        }
}

func (uc *UpdateCommand) ossAnonymousGetToFile(host, filePath string) error <span class="cov0" title="0">{
        response, err := http.Get(host)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()
        statusCode := response.StatusCode
        body, _ := ioutil.ReadAll(response.Body)
        if statusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf(string(body))
        }</span>

        <span class="cov0" title="0">fd, err := os.OpenFile(filePath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0640)
        defer fd.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = io.WriteString(fd, string(body))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *UpdateCommand) updateVersion(version, language string) error <span class="cov0" title="0">{
        // get binary path
        filePath, renameFilePath := getBinaryPath()

        // get binary mode
        f, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">mode := f.Mode()

        // rename the current binary to another one
        if err := os.Rename(filePath, renameFilePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update binary error, %s", err.Error())
        }</span>

        // download the binary of the specified version
        <span class="cov0" title="0">if err := uc.getBinary(filePath, version); err != nil </span><span class="cov0" title="0">{
                uc.revertRename(filePath, renameFilePath)
                return fmt.Errorf("download binary of version: %s error, %s", version, err.Error())
        }</span>

        <span class="cov0" title="0">if err := os.Chmod(filePath, mode); err != nil </span><span class="cov0" title="0">{
                uc.revertRename(filePath, renameFilePath)
                return fmt.Errorf("chmod binary error, %s", err.Error())
        }</span>

        // remove the current one
        <span class="cov0" title="0">if runtime.GOOS != "windows" </span><span class="cov0" title="0">{
                if err := os.Remove(renameFilePath); err != nil </span><span class="cov0" title="0">{
                        uc.revertRename(filePath, renameFilePath)
                        return fmt.Errorf("remove old binary error, %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">if language == LEnglishLanguage </span><span class="cov0" title="0">{
                fmt.Println("Update Success!")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("更新成功!")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *UpdateCommand) revertRename(filePath, renameFilePath string) error <span class="cov0" title="0">{
        if _, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                os.Remove(filePath)
        }</span>

        <span class="cov0" title="0">if err := os.Rename(renameFilePath, filePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (uc *UpdateCommand) getBinaryName() string <span class="cov0" title="0">{
        // get os type
        var object string
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                object = updateBinaryMac64
                if runtime.GOARCH == "386" </span><span class="cov0" title="0">{
                        object = updateBinaryMac32
                }</span>
        case "windows":<span class="cov0" title="0">
                object = updateBinaryWindow64
                if runtime.GOARCH == "386" </span><span class="cov0" title="0">{
                        object = updateBinaryWindow32
                }</span>
        default:<span class="cov0" title="0">
                object = updateBinaryLinux64
                if runtime.GOARCH == "386" </span><span class="cov0" title="0">{
                        object = updateBinaryLinux32
                }</span>
        }
        <span class="cov0" title="0">return object</span>
}

func (uc *UpdateCommand) getBinary(filePath, version string) error <span class="cov0" title="0">{
        object := version + "/" + uc.getBinaryName()
        if err := uc.anonymousGetToFileRetry(vUpdateBucket, object, filePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package lib

import (
        "encoding/xml"
        "fmt"
        "os"
        "strings"
)

var specChineseUserQos = SpecText{
        synopsisText: "查询用户的qos配置",

        paramText: "[local_file] [options]",

        syntaxText: ` 
    ossutil user-qos --method get [local_file] [options]
`,
        detailHelpText: ` 
    user-qos命令通过设置method选项值为get可以查询用户的qos配置

用法:
    该命令只有一种用法:
    1) ossutil user-qos --method get [local_xml_file] [options]
       这个命令查询用户的qos配置,如果输入参数local_xml_file,qos配置将输出到该文件,否则输出到屏幕上
`,
        sampleText: ` 
    1) 查询用户的qos配置，结果输出到标准输出
       ossutil user-qos --method get
        
    2) 查询用户的qos配置，结果输出到本地文件
       ossutil user-qos --method get local_xml_file
`,
}

var specEnglishUserQos = SpecText{
        synopsisText: "Get user's qos configuration",

        paramText: "[local_file] [options]",

        syntaxText: ` 
    ossutil user-qos --method get [local_xml_file] [options]
`,
        detailHelpText: ` 
    user-qos command can get the user's qos configuration by set method option value to get

Usage:
    There are only one usage for this command:

    1) ossutil user-qos --method get [local_xml_file] [options]
       The command gets the user's qos configuration
       If you input parameter local_xml_file,the configuration will be output to local_xml_file
       If you don't input parameter local_xml_file,the configuration will be output to stdout
`,
        sampleText: ` 
    1) get user's qos configuration to stdout
       ossutil user-qos --method get
        
    2) get user's qos configuration to local file
       ossutil user-qos --method get local_xml_file
`,
}

type UserQosCommand struct {
        command Command
}

var userQosCommand = UserQosCommand{
        command: Command{
                name:        "user-qos",
                nameAlias:   []string{"user-qos"},
                minArgc:     0,
                maxArgc:     1,
                specChinese: specChineseUserQos,
                specEnglish: specEnglishUserQos,
                group:       GroupTypeNormalCommand,
                validOptionNames: []string{
                        OptionConfigFile,
                        OptionEndpoint,
                        OptionAccessKeyID,
                        OptionAccessKeySecret,
                        OptionSTSToken,
                        OptionProxyHost,
                        OptionProxyUser,
                        OptionProxyPwd,
                        OptionLogLevel,
                        OptionMethod,
                        OptionPassword,
                        OptionMode,
                        OptionRamRoleName,
                        OptionExpiredSeconds,
                        OptionRamRoleArn,
                        OptionRoleSessionName,
                        OptionReadTimeout,
                        OptionConnectTimeout,
                        OptionSTSRegion,
                },
        },
}

// function for FormatHelper interface
func (uqc *UserQosCommand) formatHelpForWhole() string <span class="cov0" title="0">{
        return uqc.command.formatHelpForWhole()
}</span>

func (uqc *UserQosCommand) formatIndependHelp() string <span class="cov0" title="0">{
        return uqc.command.formatIndependHelp()
}</span>

// Init simulate inheritance, and polymorphism
func (uqc *UserQosCommand) Init(args []string, options OptionMapType) error <span class="cov0" title="0">{
        return uqc.command.Init(args, options, uqc)
}</span>

// RunCommand simulate inheritance, and polymorphism
func (uqc *UserQosCommand) RunCommand() error <span class="cov0" title="0">{
        strMethod, _ := GetString(OptionMethod, uqc.command.options)
        if strMethod == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value is empty")
        }</span>

        <span class="cov0" title="0">strMethod = strings.ToLower(strMethod)
        if strMethod != "get" </span><span class="cov0" title="0">{
                return fmt.Errorf("--method value must be get")
        }</span>

        <span class="cov0" title="0">return uqc.GetUserQos()</span>
}

func (uqc *UserQosCommand) confirm(str string) bool <span class="cov0" title="0">{
        var val string
        fmt.Printf(getClearStr(fmt.Sprintf("user qos: overwrite \"%s\"(y or N)? ", str)))
        if _, err := fmt.Scanln(&amp;val); err != nil || (strings.ToLower(val) != "yes" &amp;&amp; strings.ToLower(val) != "y") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (uqc *UserQosCommand) GetUserQos() error <span class="cov0" title="0">{
        client, err := uqc.command.ossClient("")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">qosRes, err := client.GetUserQoSInfo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">output, err := xml.MarshalIndent(qosRes, "  ", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var outFile *os.File
        if len(uqc.command.args) &gt;= 1 </span><span class="cov0" title="0">{
                fileName := uqc.command.args[0]
                _, err = os.Stat(fileName)
                if err == nil </span><span class="cov0" title="0">{
                        bConitnue := uqc.confirm(fileName)
                        if !bConitnue </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">outFile, err = os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0660)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer outFile.Close()</span>
        } else<span class="cov0" title="0"> {
                outFile = os.Stdout
        }</span>

        <span class="cov0" title="0">outFile.Write([]byte(xml.Header))
        outFile.Write(output)

        fmt.Printf("\n\n")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package lib

import (
        "bytes"
        "fmt"
        "hash"
        "io/ioutil"
        "math/rand"
        "os"
        "os/exec"
        "os/user"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "time"

        oss "github.com/aliyun/aliyun-oss-go-sdk/oss"
        "golang.org/x/crypto/ssh/terminal"
)

var sys_name string
var sys_release string
var sys_machine string

func init() <span class="cov1" title="1">{
        sys_name = runtime.GOOS
        sys_release = "-"
        sys_machine = runtime.GOARCH

        if out, err := exec.Command("uname", "-s").CombinedOutput(); err == nil </span><span class="cov1" title="1">{
                sys_name = string(bytes.TrimSpace(out))
        }</span>
        <span class="cov1" title="1">if out, err := exec.Command("uname", "-r").CombinedOutput(); err == nil </span><span class="cov1" title="1">{
                sys_release = string(bytes.TrimSpace(out))
        }</span>
        <span class="cov1" title="1">if out, err := exec.Command("uname", "-m").CombinedOutput(); err == nil </span><span class="cov1" title="1">{
                sys_machine = string(bytes.TrimSpace(out))
        }</span>
}

// Output print input string to stdout and add '\n'
func Output(str string) <span class="cov0" title="0">{
        fmt.Println(str)
}</span>

// FindPos find the elem position in a string array
func FindPos(elem string, elemArray []string) int <span class="cov7" title="280">{
        for p, v := range elemArray </span><span class="cov10" title="4434">{
                if v == elem </span><span class="cov7" title="280">{
                        return p
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// FindPosCaseInsen find the elem position in a string array, ignore case
func FindPosCaseInsen(elem string, elemArray []string) int <span class="cov5" title="67">{
        for p, v := range elemArray </span><span class="cov6" title="134">{
                if strings.EqualFold(v, elem) </span><span class="cov5" title="67">{
                        return p
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func getBinaryPath() (string, string) <span class="cov0" title="0">{
        filePath, _ := exec.LookPath(os.Args[0])
        if path, err := os.Readlink(filePath); err == nil </span><span class="cov0" title="0">{
                filePath = path
        }</span>

        <span class="cov0" title="0">fileName := filepath.Base(filePath)
        renameFilePath := ".temp_" + fileName
        return filePath, renameFilePath</span>
}

type sysInfo struct {
        name    string // 操作系统名称windows/Linux
        release string // 操作系统版本 2.6.32-220.23.2.ali1089.el5.x86_64等
        machine string // 机器类型amd64/x86_64
}

// Get　system info
// 获取操作系统信息、机器类型
func getSysInfo() sysInfo <span class="cov5" title="62">{
        return sysInfo{name: sys_name, release: sys_release, machine: sys_machine}
}</span>

func getUserAgent() string <span class="cov5" title="62">{
        sys := getSysInfo()
        return fmt.Sprintf("aliyun-sdk-go/%s (%s/%s/%s;%s)/%s-%s", oss.Version, sys.name, sys.release, sys.machine, runtime.Version(), Package, Version)
}</span>

func utcToLocalTime(utc time.Time) time.Time <span class="cov2" title="6">{
        return utc.In(time.Local)
}</span>

func max(a, b int64) int64 <span class="cov4" title="38">{
        if a &gt;= b </span><span class="cov4" title="38">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func getSizeString(size int64) string <span class="cov4" title="20">{
        prefix := ""
        str := fmt.Sprintf("%d", size)
        if size &lt; 0 </span><span class="cov0" title="0">{
                prefix = "-"
                str = str[1:]
        }</span>
        <span class="cov4" title="20">len := len(str)
        strList := []string{}
        i := len % 3
        if i != 0 </span><span class="cov0" title="0">{
                strList = append(strList, str[0:i])
        }</span>
        <span class="cov4" title="20">for ; i &lt; len; i += 3 </span><span class="cov4" title="20">{
                strList = append(strList, str[i:i+3])
        }</span>
        <span class="cov4" title="20">return fmt.Sprintf("%s%s", prefix, strings.Join(strList, ","))</span>
}

// Returns a new slice containing all strings in the
// slice that satisfy the predicate `f`.
func filter(vs []string, f func(string) bool) []string <span class="cov0" title="0">{
        vsf := make([]string, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                if f(v) </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>
        }
        <span class="cov0" title="0">return vsf</span>
}

// predicate `f` has 2 parameters
func filter2(vs []string, s string, f func(_, _ string) bool) []string <span class="cov0" title="0">{
        vsf := make([]string, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                if f(v, s) </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>
        }
        <span class="cov0" title="0">return vsf</span>
}

func filterStr(v string, s string, f func(string, string) bool) bool <span class="cov0" title="0">{
        return f(v, s)
}</span>

func filterStrWithPattern(v, p string) bool <span class="cov0" title="0">{
        _, name := filepath.Split(v)
        res, _ := filepath.Match(p, name)
        return res
}</span>

func filterStrsWithPattern(vs []string, p string) []string <span class="cov0" title="0">{
        vsf := make([]string, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                _, name := filepath.Split(v)
                res, _ := filepath.Match(p, name)
                if res </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>
        }
        <span class="cov0" title="0">return vsf</span>
}

func filterObjectsFromListResultWithPattern(lor oss.ListObjectsResult, pattern string) []string <span class="cov0" title="0">{
        objs := make([]string, 0)
        for _, obj := range lor.Objects </span><span class="cov0" title="0">{
                objs = append(objs, obj.Key)
        }</span>
        <span class="cov0" title="0">return filterStrsWithPattern(objs, pattern)</span>
}

func filterObjectsFromChanWithPattern(srcCh &lt;-chan string, pattern string, dstCh chan&lt;- string) <span class="cov0" title="0">{
        for obj := range srcCh </span><span class="cov0" title="0">{
                if filterStrWithPattern(obj, pattern) </span><span class="cov0" title="0">{
                        dstCh &lt;- obj
                }</span>
        }
        <span class="cov0" title="0">defer close(dstCh)</span>
}

// Following for strings
func getFilter(cmdline []string) (bool, []filterOptionType) <span class="cov5" title="52">{
        filters := make([]filterOptionType, 0)
        for i, item := range cmdline </span><span class="cov7" title="312">{
                var strTag = ""
                if strings.Index(item, IncludePrompt) == 0 </span><span class="cov0" title="0">{
                        strTag = IncludePrompt
                }</span> else<span class="cov7" title="312"> if strings.Index(item, ExcludePrompt) == 0 </span><span class="cov0" title="0">{
                        strTag = ExcludePrompt
                }</span>

                <span class="cov7" title="312">if strTag != "" </span><span class="cov0" title="0">{
                        var filter filterOptionType
                        var strArg string

                        filter.name = strTag
                        if item == strTag </span><span class="cov0" title="0">{
                                strArg = cmdline[i+1]
                        }</span> else<span class="cov0" title="0"> if item[len(strTag)] == '=' </span><span class="cov0" title="0">{
                                strArg = item[len(strTag)+1:]
                        }</span>

                        <span class="cov0" title="0">if strArg == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // To support standard glob
                        <span class="cov0" title="0">filter.pattern = strings.Replace(strArg, "[!", "[^", -1)
                        dir, _ := filepath.Split(filter.pattern)
                        if dir != "" </span><span class="cov0" title="0">{
                                return false, filters
                        }</span>
                        <span class="cov0" title="0">filters = append(filters, filter)</span>
                }
        }

        <span class="cov5" title="52">return true, filters</span>
}

func containsInStrsSlice(vs []string, t string) bool <span class="cov0" title="0">{
        if len(vs) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, v := range vs </span><span class="cov0" title="0">{
                if v == t </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func filterSingleStr(v, p string, include bool) bool <span class="cov0" title="0">{
        _, name := filepath.Split(v)
        res, _ := filepath.Match(p, name)

        if include </span><span class="cov0" title="0">{
                return res
        }</span> else<span class="cov0" title="0"> {
                return !res
        }</span>
}

func filterStrsWithInclude(vs []string, p string) []string <span class="cov0" title="0">{
        vsf := make([]string, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                _, name := filepath.Split(v)
                res, _ := filepath.Match(p, name)
                if res </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>

        }
        <span class="cov0" title="0">return vsf</span>
}

func filterStrsWithExclude(vs []string, p string) []string <span class="cov0" title="0">{
        vsf := make([]string, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                _, name := filepath.Split(v)
                res, _ := filepath.Match(p, name)
                if !res </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>

        }
        <span class="cov0" title="0">return vsf</span>
}

func matchFiltersForStr(str string, filters []filterOptionType) bool <span class="cov0" title="0">{
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">var res bool
        if filters[0].name == IncludePrompt </span><span class="cov0" title="0">{
                res = filterSingleStr(str, filters[0].pattern, true)
        }</span> else<span class="cov0" title="0"> {
                res = filterSingleStr(str, filters[0].pattern, false)
        }</span>

        <span class="cov0" title="0">for _, filter := range filters[1:] </span><span class="cov0" title="0">{
                if filter.name == IncludePrompt </span><span class="cov0" title="0">{
                        res = res || filterSingleStr(str, filter.pattern, true)
                }</span> else<span class="cov0" title="0"> {
                        res = res &amp;&amp; filterSingleStr(str, filter.pattern, false)
                }</span>
        }

        <span class="cov0" title="0">return res</span>
}

func matchFiltersForStrs(strs []string, filters []filterOptionType) []string <span class="cov0" title="0">{
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return strs
        }</span>

        <span class="cov0" title="0">vsf := make([]string, 0)

        for _, str := range strs </span><span class="cov0" title="0">{
                if matchFiltersForStr(str, filters) </span><span class="cov0" title="0">{
                        vsf = append(vsf, str)
                }</span>
        }

        <span class="cov0" title="0">return vsf</span>
}

func matchFiltersForStrsInArray(strs []string, filters []filterOptionType) []string <span class="cov0" title="0">{
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return strs
        }</span>
        <span class="cov0" title="0">vsf := make([]string, 0)

        if filters[0].name == IncludePrompt </span><span class="cov0" title="0">{
                vsf = append(vsf, filterStrsWithInclude(strs, filters[0].pattern)...)
        }</span> else<span class="cov0" title="0"> {
                vsf = append(vsf, filterStrsWithExclude(strs, filters[0].pattern)...)
        }</span>

        <span class="cov0" title="0">for _, filter := range filters[1:] </span><span class="cov0" title="0">{
                if filter.name == IncludePrompt </span><span class="cov0" title="0">{
                        vsf = append(vsf, filterStrsWithInclude(strs, filter.pattern)...)
                }</span> else<span class="cov0" title="0"> {
                        vsf = filterStrsWithExclude(vsf, filter.pattern)
                }</span>
        }

        <span class="cov0" title="0">return vsf</span>
}

// Following for files

func doesSingleFileMatchPatterns(filename string, filters []filterOptionType) bool <span class="cov0" title="0">{
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">files := []string{filename}
        vsf := matchFiltersForStrs(files, filters)

        if len(vsf) &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func containsInFileSlice(vs []fileInfoType, t fileInfoType) bool <span class="cov0" title="0">{
        if len(vs) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, v := range vs </span><span class="cov0" title="0">{
                if v == t </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func filterFilesWithInclude(vs []fileInfoType, p string) []fileInfoType <span class="cov0" title="0">{
        vsf := make([]fileInfoType, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                _, filename := filepath.Split(v.filePath)
                res, _ := filepath.Match(p, filename)

                if res </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>

        }
        <span class="cov0" title="0">return vsf</span>
}

func filterFilesWithExclude(vs []fileInfoType, p string) []fileInfoType <span class="cov0" title="0">{
        vsf := make([]fileInfoType, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                _, filename := filepath.Split(v.filePath)
                res, _ := filepath.Match(p, filename)
                if !res </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>

        }
        <span class="cov0" title="0">return vsf</span>
}

// Following for objects

func doesSingleObjectMatchPatterns(object string, filters []filterOptionType) bool <span class="cov3" title="7">{
        if len(filters) == 0 </span><span class="cov3" title="7">{
                return true
        }</span>

        <span class="cov0" title="0">return doesSingleFileMatchPatterns(object, filters)</span>
}

func getObjectsFromChanToArray(chObjects &lt;-chan objectInfoType) []objectInfoType <span class="cov0" title="0">{
        objects := make([]objectInfoType, 0)
        for f := range chObjects </span><span class="cov0" title="0">{
                objects = append(objects, f)
        }</span>
        <span class="cov0" title="0">return objects</span>
}

func filterObjectsWithInclude(vs []objectInfoType, p string) []objectInfoType <span class="cov0" title="0">{
        vsf := make([]objectInfoType, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                _, key := filepath.Split(v.relativeKey)
                //_, key := filepath.Split(v.key)
                res, _ := filepath.Match(p, key)
                if res </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>
        }
        <span class="cov0" title="0">return vsf</span>
}

func filterObjectsWithExclude(vs []objectInfoType, p string) []objectInfoType <span class="cov0" title="0">{
        vsf := make([]objectInfoType, 0)
        for _, v := range vs </span><span class="cov0" title="0">{
                _, key := filepath.Split(v.relativeKey)
                //_, key := filepath.Split(v.key)
                res, _ := filepath.Match(p, key)
                if !res </span><span class="cov0" title="0">{
                        vsf = append(vsf, v)
                }</span>
        }
        <span class="cov0" title="0">return vsf</span>
}

func matchFiltersForObjects(objects []objectInfoType, filters []filterOptionType) []objectInfoType <span class="cov0" title="0">{
        if len(filters) == 0 </span><span class="cov0" title="0">{
                return objects
        }</span>

        <span class="cov0" title="0">vsf := make([]objectInfoType, 0)

        for i, filter := range filters </span><span class="cov0" title="0">{
                if filter.name == IncludePrompt </span><span class="cov0" title="0">{
                        vsf = append(vsf, filterObjectsWithInclude(objects, filter.pattern)...)
                }</span> else<span class="cov0" title="0"> {
                        if i == 0 </span><span class="cov0" title="0">{
                                vsf = append(vsf, filterObjectsWithExclude(objects, filter.pattern)...)
                        }</span> else<span class="cov0" title="0"> {
                                vsf = filterObjectsWithExclude(vsf, filter.pattern)
                        }</span>
                }
        }

        <span class="cov0" title="0">return vsf</span>
}

func makeObjectChanFromArray(objects []objectInfoType, chObjs chan&lt;- objectInfoType) <span class="cov0" title="0">{
        for _, f := range objects </span><span class="cov0" title="0">{
                chObjs &lt;- f
        }</span>
}

func filterObjectsFromChanWithPatterns(chObjects &lt;-chan objectInfoType, filters []filterOptionType, dstObjs chan&lt;- objectInfoType) <span class="cov0" title="0">{
        objects := getObjectsFromChanToArray(chObjects)
        vsf := matchFiltersForObjects(objects, filters)
        makeObjectChanFromArray(vsf, dstObjs)
        defer close(dstObjs)
}</span>

func GetCloudUrl(strlUrl, encodingType string) (*CloudURL, error) <span class="cov0" title="0">{
        bucketUrL, err := StorageURLFromString(strlUrl, encodingType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !bucketUrL.IsCloudURL() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter is not a cloud url,url is %s", bucketUrL.ToString())
        }</span>

        <span class="cov0" title="0">cloudUrl := bucketUrL.(CloudURL)
        if cloudUrl.bucket == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bucket name is empty,url is %s", bucketUrL.ToString())
        }</span>
        <span class="cov0" title="0">return &amp;cloudUrl, nil</span>
}

func matchHash(fnvIns hash.Hash64, key string, modeValue int, countValue int) bool <span class="cov0" title="0">{
        fnvIns.Reset()
        fnvIns.Write([]byte(key))
        if fnvIns.Sum64()%uint64(countValue) == uint64(modeValue) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

var letters = []rune("0123456789abcdefghijklmnopqrstuvwxyz")

func randStr(n int) string <span class="cov5" title="67">{
        b := make([]rune, n)
        r := rand.New(rand.NewSource(time.Now().UnixNano()))
        for i := range b </span><span class="cov9" title="1834">{
                b[i] = letters[r.Intn(len(letters))]
        }</span>
        <span class="cov5" title="67">return string(b)</span>
}

func currentHomeDir() string <span class="cov2" title="6">{
        homeDir := ""
        homeDrive := os.Getenv("HOMEDRIVE")
        homePath := os.Getenv("HOMEPATH")
        if runtime.GOOS == "windows" &amp;&amp; homeDrive != "" &amp;&amp; homePath != "" </span><span class="cov0" title="0">{
                homeDir = homeDrive + string(os.PathSeparator) + homePath
        }</span>

        <span class="cov2" title="6">if homeDir != "" </span><span class="cov0" title="0">{
                return homeDir
        }</span>

        <span class="cov2" title="6">usr, _ := user.Current()
        if usr != nil </span><span class="cov2" title="6">{
                homeDir = usr.HomeDir
        }</span> else<span class="cov0" title="0"> {
                homeDir = os.Getenv("HOME")
        }</span>
        <span class="cov2" title="6">return homeDir</span>
}

func getCurrentDirFileListCommon(dpath string, chFiles chan&lt;- fileInfoType, filters []filterOptionType) error <span class="cov0" title="0">{
        if !strings.HasSuffix(dpath, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                dpath += string(os.PathSeparator)
        }</span>

        <span class="cov0" title="0">fileList, err := ioutil.ReadDir(dpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, fileInfo := range fileList </span><span class="cov0" title="0">{
                if !fileInfo.IsDir() </span><span class="cov0" title="0">{
                        realInfo, errF := os.Stat(dpath + fileInfo.Name())
                        if errF == nil &amp;&amp; realInfo.IsDir() </span><span class="cov0" title="0">{
                                // for symlink
                                continue</span>
                        }

                        <span class="cov0" title="0">if doesSingleFileMatchPatterns(fileInfo.Name(), filters) </span><span class="cov0" title="0">{
                                chFiles &lt;- fileInfoType{fileInfo.Name(), dpath}
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func getFileListCommon(dpath string, chFiles chan&lt;- fileInfoType, onlyCurrentDir bool, disableAllSymlink bool,
        enableSymlinkDir bool, filters []filterOptionType) error <span class="cov0" title="0">{
        defer close(chFiles)
        if onlyCurrentDir </span><span class="cov0" title="0">{
                return getCurrentDirFileListCommon(dpath, chFiles, filters)
        }</span>

        <span class="cov0" title="0">name := dpath
        symlinkDiretorys := []string{dpath}
        walkFunc := func(fpath string, f os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if f == nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dpath = filepath.Clean(dpath)
                fpath = filepath.Clean(fpath)

                fileName, err := filepath.Rel(dpath, fpath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("list file error: %s, info: %s", fpath, err.Error())
                }</span>

                <span class="cov0" title="0">if f.IsDir() </span><span class="cov0" title="0">{
                        if fpath != dpath </span><span class="cov0" title="0">{
                                if strings.HasSuffix(fileName, "\\") || strings.HasSuffix(fileName, "/") </span><span class="cov0" title="0">{
                                        chFiles &lt;- fileInfoType{fileName, name}
                                }</span> else<span class="cov0" title="0"> {
                                        chFiles &lt;- fileInfoType{fileName + string(os.PathSeparator), name}
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if disableAllSymlink &amp;&amp; (f.Mode()&amp;os.ModeSymlink) != 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if enableSymlinkDir &amp;&amp; (f.Mode()&amp;os.ModeSymlink) != 0 </span><span class="cov0" title="0">{
                        // there is difference between os.Stat and os.Lstat in filepath.Walk
                        realInfo, err := os.Stat(fpath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if realInfo.IsDir() </span><span class="cov0" title="0">{
                                // it's symlink dir
                                // if linkDir has suffix os.PathSeparator,os.Lstat determine it is a dir
                                if !strings.HasSuffix(name, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                                        name += string(os.PathSeparator)
                                }</span>
                                <span class="cov0" title="0">linkDir := name + fileName + string(os.PathSeparator)
                                symlinkDiretorys = append(symlinkDiretorys, linkDir)
                                return nil</span>
                        }
                }

                <span class="cov0" title="0">if doesSingleFileMatchPatterns(fileName, filters) </span><span class="cov0" title="0">{
                        chFiles &lt;- fileInfoType{fileName, name}
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">var err error
        for </span><span class="cov0" title="0">{
                symlinks := symlinkDiretorys
                symlinkDiretorys = []string{}
                for _, v := range symlinks </span><span class="cov0" title="0">{
                        err = filepath.Walk(v, walkFunc)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if len(symlinkDiretorys) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func getObjectListCommon(bucket *oss.Bucket, cloudURL CloudURL, chObjects chan&lt;- objectInfoType,
        onlyCurrentDir bool, filters []filterOptionType, payerOptions []oss.Option) error <span class="cov0" title="0">{
        defer close(chObjects)
        pre := oss.Prefix(cloudURL.object)
        marker := oss.Marker("")
        //while the src object is end with "/", use object key as marker, exclude the object itself
        if strings.HasSuffix(cloudURL.object, "/") </span><span class="cov0" title="0">{
                marker = oss.Marker(cloudURL.object)
        }</span>
        <span class="cov0" title="0">del := oss.Delimiter("")
        if onlyCurrentDir </span><span class="cov0" title="0">{
                del = oss.Delimiter("/")
        }</span>

        <span class="cov0" title="0">listOptions := append(payerOptions, pre, marker, del, oss.MaxKeys(1000))
        for </span><span class="cov0" title="0">{
                lor, err := bucket.ListObjects(listOptions...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, object := range lor.Objects </span><span class="cov0" title="0">{
                        prefix := ""
                        relativeKey := object.Key
                        index := strings.LastIndex(cloudURL.object, "/")
                        if index &gt; 0 </span><span class="cov0" title="0">{
                                prefix = object.Key[:index+1]
                                relativeKey = object.Key[index+1:]
                        }</span>

                        <span class="cov0" title="0">if doesSingleObjectMatchPatterns(object.Key, filters) </span><span class="cov0" title="0">{
                                if strings.ToLower(object.Type) == "symlink" </span><span class="cov0" title="0">{
                                        props, err := bucket.GetObjectDetailedMeta(object.Key, payerOptions...)
                                        if err != nil </span><span class="cov0" title="0">{
                                                LogError("ossGetObjectStatRetry error info:%s\n", err.Error())
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">size, err := strconv.ParseInt(props.Get(oss.HTTPHeaderContentLength), 10, 64)
                                        if err != nil </span><span class="cov0" title="0">{
                                                LogError("strconv.ParseInt error info:%s\n", err.Error())
                                                return err

                                        }</span>
                                        <span class="cov0" title="0">object.Size = size</span>
                                }
                                <span class="cov0" title="0">chObjects &lt;- objectInfoType{prefix, relativeKey, int64(object.Size), object.LastModified}</span>
                        }
                }

                <span class="cov0" title="0">pre = oss.Prefix(lor.Prefix)
                marker = oss.Marker(lor.NextMarker)
                listOptions = append(payerOptions, pre, marker, oss.MaxKeys(1000))
                if !lor.IsTruncated </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func GetPassword(prompt string) ([]byte, error) <span class="cov0" title="0">{
        fd := int(os.Stdin.Fd())
        if terminal.IsTerminal(fd) </span><span class="cov0" title="0">{
                state, err := terminal.MakeRaw(fd)
                if err != nil </span><span class="cov0" title="0">{
                        f := "getpass: cannot disable terminal echoing — %v"
                        return nil, fmt.Errorf(f, err)
                }</span>
                <span class="cov0" title="0">defer terminal.Restore(fd, state)
                defer fmt.Println()</span>
        }

        <span class="cov0" title="0">if prompt == "" </span><span class="cov0" title="0">{
                prompt = "enter password: "
        }</span>
        <span class="cov0" title="0">fmt.Fprint(os.Stderr, prompt)
        return terminal.ReadPassword(fd)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
